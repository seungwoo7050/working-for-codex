# v2.0.0 WebFlux & R2DBC 전환 설계

> 블로킹 → 리액티브 전환을 통한 고성능 API 구현

## 개요

### 목표
- Spring MVC → Spring WebFlux 전환
- JPA → R2DBC 전환
- SSE(Server-Sent Events) 스트리밍 지원
- 논블로킹 I/O 기반 고성능 API

### 성능 목표
| 메트릭 | 목표 |
|--------|------|
| API 응답 시간 | < 50ms (p99) |
| 처리량 | 10,000 req/s |
| 메모리 | < 1GB per instance |

---

## 패치별 상세 설계

### 2.0.1: WebFlux & R2DBC 의존성 추가

#### 변경 파일
- `build.gradle`

#### 변경 내용
```gradle
// 제거
implementation 'org.springframework.boot:spring-boot-starter-web'
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

// 추가 (이미 webflux 있음, r2dbc 추가)
implementation 'org.springframework.boot:spring-boot-starter-data-r2dbc'
runtimeOnly 'io.r2dbc:r2dbc-h2'
runtimeOnly 'io.r2dbc:r2dbc-postgresql'
```

#### 주의사항
- 기존 JPA 코드와 병행 운영 (점진적 마이그레이션)
- WebFlux와 MVC 혼용 시 WebFlux 우선

---

### 2.0.2: R2DBC Repository 전환

#### 새로운 파일
- `src/main/java/com/example/training/reactive/domain/ProductEntity.java`
- `src/main/java/com/example/training/reactive/repository/ProductR2dbcRepository.java`

#### 데이터 구조
```java
@Table("products")
public class ProductEntity {
    @Id
    private Long id;
    
    @Column("name")
    private String name;
    
    @Column("description")
    private String description;
    
    @Column("price")
    private BigDecimal price;
    
    @Column("stock")
    private Integer stock;
    
    @Column("created_at")
    private LocalDateTime createdAt;
    
    @Column("updated_at")
    private LocalDateTime updatedAt;
}
```

#### Repository 인터페이스
```java
@Repository
@Profile("reactive")
public interface ProductR2dbcRepository 
    extends ReactiveCrudRepository<ProductEntity, Long> {
    
    Flux<ProductEntity> findByNameContaining(String keyword);
    
    @Query("SELECT * FROM products WHERE price BETWEEN :min AND :max")
    Flux<ProductEntity> findByPriceRange(BigDecimal min, BigDecimal max);
    
    @Query("SELECT * FROM products WHERE stock > 0")
    Flux<ProductEntity> findInStock();
}
```

#### 프로파일 분리
- `@Profile("reactive")`: reactive 프로파일에서만 활성화
- 기존 JPA 코드와 충돌 방지를 위한 프로파일 분리

---

### 2.0.3: 리액티브 컨트롤러 구현

#### 새로운 파일
- `src/main/java/com/example/training/reactive/controller/ReactiveProductController.java`
- `src/main/java/com/example/training/reactive/controller/ReactiveExceptionHandler.java`

#### API 엔드포인트
| Method | Path | 설명 | 반환 타입 |
|--------|------|------|----------|
| GET | `/api/v2/products` | 상품 목록 | `Flux<ProductResponse>` |
| GET | `/api/v2/products/{id}` | 상품 상세 | `Mono<ProductResponse>` |
| GET | `/api/v2/products/search?keyword=xxx` | 이름 검색 | `Flux<ProductResponse>` |
| GET | `/api/v2/products/price-range?min=x&max=y` | 가격 범위 검색 | `Flux<ProductResponse>` |
| GET | `/api/v2/products/in-stock` | 재고 있는 상품 | `Flux<ProductResponse>` |
| POST | `/api/v2/products` | 상품 생성 | `Mono<ProductResponse>` |
| PUT | `/api/v2/products/{id}` | 상품 수정 | `Mono<ProductResponse>` |
| DELETE | `/api/v2/products/{id}` | 상품 삭제 | `Mono<Void>` |

#### 핵심 구현
```java
@RestController
@RequestMapping("/api/v2/products")
@Profile("reactive")
public class ReactiveProductController {
    
    private final ReactiveProductService productService;
    private final ProductEventPublisher eventPublisher;
    
    @GetMapping
    public Flux<ProductResponse> getAllProducts() {
        return productService.findAll();
    }
    
    @GetMapping("/{id}")
    public Mono<ProductResponse> getProduct(@PathVariable Long id) {
        return productService.findById(id);
    }
    
    @GetMapping("/search")
    public Flux<ProductResponse> searchProducts(@RequestParam String keyword) {
        return productService.searchByName(keyword);
    }
    
    @GetMapping("/price-range")
    public Flux<ProductResponse> getProductsByPriceRange(
            @RequestParam BigDecimal min, @RequestParam BigDecimal max) {
        return productService.findByPriceRange(min, max);
    }
    
    @GetMapping("/in-stock")
    public Flux<ProductResponse> getProductsInStock() {
        return productService.findInStock();
    }
}
```

---

### 2.0.4: 리액티브 서비스 구현

#### 새로운 파일
- `src/main/java/com/example/training/reactive/service/ReactiveProductService.java`
- `src/main/java/com/example/training/reactive/dto/ProductRequest.java`
- `src/main/java/com/example/training/reactive/dto/ProductResponse.java`

#### 서비스 책임
- CRUD 비즈니스 로직
- 에러 핸들링 (Mono.error, switchIfEmpty)
- Backpressure 처리
- SSE 이벤트 발행

#### 핵심 구현
```java
@Service
@Profile("reactive")
public class ReactiveProductService {
    
    private final ProductR2dbcRepository repository;
    private final ProductEventPublisher eventPublisher;
    
    public Flux<ProductResponse> findAll() {
        return repository.findAll()
            .map(ProductResponse::from);
    }
    
    public Mono<ProductResponse> findById(Long id) {
        return repository.findById(id)
            .map(ProductResponse::from)
            .switchIfEmpty(Mono.error(
                new ResourceNotFoundException("Product not found: " + id)));
    }
    
    public Flux<ProductResponse> searchByName(String keyword) {
        return repository.findByNameContaining(keyword)
            .map(ProductResponse::from);
    }
    
    public Flux<ProductResponse> findByPriceRange(BigDecimal min, BigDecimal max) {
        return repository.findByPriceRange(min, max)
            .map(ProductResponse::from);
    }
    
    public Flux<ProductResponse> findInStock() {
        return repository.findInStock()
            .map(ProductResponse::from);
    }
    
    public Mono<ProductResponse> create(ProductRequest request) {
        return repository.save(toEntity(request))
            .map(ProductResponse::from)
            .doOnNext(eventPublisher::publish);
    }
}
```

---

### 2.0.5: SSE 스트리밍 구현

#### 변경 파일
- `src/main/java/com/example/training/reactive/controller/ReactiveProductController.java`

#### 새로운 파일
- `src/main/java/com/example/training/reactive/event/ProductEventPublisher.java`

#### API 엔드포인트
| Method | Path | 설명 | Content-Type |
|--------|------|------|--------------|
| GET | `/api/v2/products/stream` | 실시간 상품 업데이트 | `text/event-stream` |

#### 핵심 구현
```java
@GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<ServerSentEvent<ProductResponse>> streamProducts() {
    return productEventPublisher.getEventStream()
        .map(product -> ServerSentEvent.<ProductResponse>builder()
            .id(String.valueOf(product.getId()))
            .event("product-update")
            .data(product)
            .build());
}
```

#### 이벤트 발행
```java
@Component
@Profile("reactive")
public class ProductEventPublisher {
    private final Sinks.Many<ProductResponse> sink;
    
    public ProductEventPublisher() {
        // 멀티캐스트 싱크: 여러 구독자에게 동시에 이벤트 발행
        // onBackpressureBuffer: 백프레셔 발생 시 버퍼링
        this.sink = Sinks.many().multicast().onBackpressureBuffer();
    }
    
    public void publish(ProductResponse product) {
        sink.tryEmitNext(product);
    }
    
    public Flux<ProductResponse> getEventStream() {
        return sink.asFlux();
    }
}
```

---

## 테스트 관점

### 단위 테스트
- `ReactiveProductServiceTest`: StepVerifier 사용
- Mono/Flux 검증

### 통합 테스트
- `ReactiveProductControllerTest`: WebTestClient 사용
- SSE 스트리밍 테스트

### 테스트 예시
```java
@Test
void findById_whenExists_returnsProduct() {
    StepVerifier.create(productService.findById(1L))
        .expectNextMatches(p -> p.getName().equals("Test Product"))
        .verifyComplete();
}

@Test
void findById_whenNotExists_returnsError() {
    StepVerifier.create(productService.findById(999L))
        .expectError(ResourceNotFoundException.class)
        .verify();
}
```

---

## 데이터베이스 스키마

### products 테이블
```sql
CREATE TABLE IF NOT EXISTS products (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    price DECIMAL(19, 2) NOT NULL,
    stock INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 설정 파일

### application.yml 추가 설정
```yaml
spring:
  r2dbc:
    url: r2dbc:h2:mem:///testdb
    username: sa
    password:
    
  # 스키마 초기화
  sql:
    init:
      mode: always
      schema-locations: classpath:schema-r2dbc.sql
```

---

## 아키텍처 다이어그램

```
┌─────────────────────────────────────────────────────────┐
│                    Client Request                        │
└─────────────────────────┬───────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│              ReactiveProductController                   │
│         (Mono<T> / Flux<T> / ServerSentEvent)           │
└─────────────────────────┬───────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│               ReactiveProductService                     │
│            (Backpressure, Error Handling)               │
└─────────────────────────┬───────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│              ProductR2dbcRepository                      │
│         (ReactiveCrudRepository<Product, Long>)         │
└─────────────────────────┬───────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                  R2DBC Driver                            │
│              (H2 / PostgreSQL)                          │
└─────────────────────────────────────────────────────────┘
```

---

## 프로젝트 구조

```
src/main/java/com/example/training/reactive/
├── controller/
│   ├── ReactiveProductController.java
│   └── ReactiveExceptionHandler.java
├── domain/
│   └── ProductEntity.java
├── dto/
│   ├── ProductRequest.java
│   └── ProductResponse.java
├── event/
│   └── ProductEventPublisher.java
├── repository/
│   └── ProductR2dbcRepository.java
└── service/
    └── ReactiveProductService.java
```

---

## 다음 단계 (v2.1.0)

v2.1.0에서는 Virtual Threads를 도입하여 기존 블로킹 API와 리액티브 API를 병행 운영하는 하이브리드 아키텍처를 구현합니다:
- Java 21 Virtual Threads 설정
- Hybrid Controller (MVC + WebFlux 혼용)
- 프로파일 기반 전략 선택
