# WebGL 렌더링 파이프라인 설계 일지 (v3.1.3)
> Phase 3.1 - 고급 렌더링 기법

## 1. 문제 정의 & 요구사항

### 1.1 핵심 목표

**v3.1.3 - WebGL Rendering Pipeline**:
- **프레임버퍼**: 오프스크린 렌더링
- **렌더버퍼**: 깊이/스텐실 버퍼
- **다중 패스 렌더링**: 복잡한 효과 체인
- **포스트 프로세싱**: 블룸, 블러 등

---

## 2. 패치별 상세 설계

### 3.1.3.1: 프레임버퍼 객체

**파일**: `frontend/src/webgl/Framebuffer.ts`

```typescript
interface FramebufferOptions {
  width: number;
  height: number;
  colorFormat?: number;      // 컴러 포맷 (기본: RGBA8)
  depthBuffer?: boolean;     // 깊이 버퍼 사용 여부
  stencilBuffer?: boolean;   // 스텐실 버퍼 사용 여부
}

class Framebuffer {
  private gl: WebGL2RenderingContext;
  private fbo: WebGLFramebuffer;
  private colorTexture: WebGLTexture;     // 단일 컴러 어태치먼트
  private depthRenderbuffer: WebGLRenderbuffer | null = null;
  private width: number;
  private height: number;
  private isDisposed = false;
  
  constructor(gl: WebGL2RenderingContext, options: FramebufferOptions) {
    this.gl = gl;
    this.width = options.width;
    this.height = options.height;
    this.fbo = gl.createFramebuffer()!;
    this.colorTexture = this.createColorTexture(options);
    this.setup(options);
  }
  
  bind(): void {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
    this.gl.viewport(0, 0, this.width, this.height);
  }
  
  unbind(): void {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
  }
  
  getColorTexture(): WebGLTexture {
    return this.colorTexture;
  }
  
  getWidth(): number { return this.width; }
  getHeight(): number { return this.height; }
}
```

---

### 3.1.3.2: 렌더버퍼 관리

**파일**: `frontend/src/webgl/Renderbuffer.ts`

```typescript
type RenderbufferFormat = 'depth16' | 'depth24' | 'depth32f' | 'depth24stencil8' | 'stencil8';

class Renderbuffer {
  private gl: WebGL2RenderingContext;
  private rbo: WebGLRenderbuffer;
  private width: number;
  private height: number;
  private format: RenderbufferFormat;
  private isDisposed = false;
  
  constructor(
    gl: WebGL2RenderingContext,
    width: number,
    height: number,
    format: RenderbufferFormat = 'depth24'
  ) {
    this.gl = gl;
    this.width = width;
    this.height = height;
    this.format = format;
    this.rbo = gl.createRenderbuffer()!;
    this.allocate();
  }
  
  private allocate(): void {
    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.rbo);
    this.gl.renderbufferStorage(
      this.gl.RENDERBUFFER,
      this.getInternalFormat(),
      this.width,
      this.height
    );
  }
  
  private getInternalFormat(): number {
    switch (this.format) {
      case 'depth16': return this.gl.DEPTH_COMPONENT16;
      case 'depth24': return this.gl.DEPTH_COMPONENT24;
      case 'depth32f': return this.gl.DEPTH_COMPONENT32F;
      case 'depth24stencil8': return this.gl.DEPTH24_STENCIL8;
      case 'stencil8': return this.gl.STENCIL_INDEX8;
    }
  }
  
  getAttachmentType(): number {
    switch (this.format) {
      case 'depth16':
      case 'depth24':
      case 'depth32f':
        return this.gl.DEPTH_ATTACHMENT;
      case 'depth24stencil8':
        return this.gl.DEPTH_STENCIL_ATTACHMENT;
      case 'stencil8':
        return this.gl.STENCIL_ATTACHMENT;
    }
  }
  
  bind(): void { this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.rbo); }
  unbind(): void { this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null); }
  getRenderbuffer(): WebGLRenderbuffer { return this.rbo; }
}
```

---

### 3.1.3.3: 다중 패스 렌더링

**파일**: `frontend/src/webgl/MultiPassRenderer.ts`

```typescript
interface RenderPass {
  name: string;
  shader: ShaderProgram;
  inputs: WebGLTexture[];
  output: Framebuffer | null; // null = 화면 출력
  setup?: (gl: WebGL2RenderingContext) => void;
  uniforms?: Record<string, unknown>;
}

class MultiPassRenderer {
  private gl: WebGL2RenderingContext;
  private passes: RenderPass[] = [];
  private quadVAO: WebGLVertexArrayObject;
  private quadVBO: WebGLBuffer;
  private viewportWidth: number;
  private viewportHeight: number;
  
  constructor(gl: WebGL2RenderingContext, viewportWidth: number, viewportHeight: number) {
    this.gl = gl;
    this.viewportWidth = viewportWidth;
    this.viewportHeight = viewportHeight;
    const { vao, vbo } = this.createFullscreenQuad();
    this.quadVAO = vao;
    this.quadVBO = vbo;
  }
  
  addPass(pass: RenderPass): void {
    this.passes.push(pass);
  }
  
  removePass(name: string): void {
    this.passes = this.passes.filter(p => p.name !== name);
  }
  
  clearPasses(): void {
    this.passes = [];
  }
  
  render(): void {
    for (const pass of this.passes) {
      if (pass.output) {
        pass.output.bind();
      } else {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.gl.viewport(0, 0, this.viewportWidth, this.viewportHeight);
      }
      
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      pass.shader.use();
      pass.setup?.(this.gl);
      
      // Bind input textures
      pass.inputs.forEach((tex, i) => {
        this.gl.activeTexture(this.gl.TEXTURE0 + i);
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
      });
      
      // Draw fullscreen quad
      this.gl.bindVertexArray(this.quadVAO);
      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }
  }
}
```

---

### 3.1.3.4: 포스트 프로세싱

**파일**: `frontend/src/webgl/PostProcessor.ts`

```typescript
type PostEffect = 'blur' | 'brightness' | 'contrast' | 'saturation' | 'vignette';

class PostProcessor {
  private gl: WebGL2RenderingContext;
  private shaders: Map<PostEffect, ShaderProgram> = new Map();
  private tempFramebuffers: Framebuffer[] = [];
  private quadVAO: WebGLVertexArrayObject;
  private quadVBO: WebGLBuffer;
  
  constructor(gl: WebGL2RenderingContext) {
    this.gl = gl;
    const { vao, vbo } = this.createQuad();
    this.quadVAO = vao;
    this.quadVBO = vbo;
    this.initShaders();
  }
  
  private initShaders(): void {
    const vertexShader = ShaderCompiler.getDefaultVertexShader();
    
    // Blur 셰이더
    this.shaders.set('blur', new ShaderProgram(this.gl, {
      vertexSource: vertexShader,
      fragmentSource: `#version 300 es
        precision highp float;
        uniform sampler2D uTexture;
        uniform vec2 uDirection;
        uniform vec2 uResolution;
        in vec2 vTexCoord;
        out vec4 fragColor;
        
        void main() {
          vec2 texelSize = 1.0 / uResolution;
          vec4 result = vec4(0.0);
          float weights[5] = float[](0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);
          
          result += texture(uTexture, vTexCoord) * weights[0];
          for (int i = 1; i < 5; i++) {
            vec2 offset = uDirection * texelSize * float(i);
            result += texture(uTexture, vTexCoord + offset) * weights[i];
            result += texture(uTexture, vTexCoord - offset) * weights[i];
          }
          
          fragColor = result;
        }
      `,
    }));
    
    // Brightness/Contrast 셰이더
    this.shaders.set('brightness', new ShaderProgram(this.gl, {
      vertexSource: vertexShader,
      fragmentSource: `#version 300 es
        precision highp float;
        uniform sampler2D uTexture;
        uniform float uBrightness;
        uniform float uContrast;
        in vec2 vTexCoord;
        out vec4 fragColor;
        
        void main() {
          vec4 color = texture(uTexture, vTexCoord);
          color.rgb += uBrightness;
          color.rgb = (color.rgb - 0.5) * uContrast + 0.5;
          fragColor = color;
        }
      `,
    }));
  }
}
```

---

## 3. 완료 기준

- [ ] FBO 기반 오프스크린 렌더링
- [ ] 깊이/스텐실 버퍼 동작
- [ ] 다중 패스 효과 적용
- [ ] 포스트 프로세싱 효과 동작 (blur, bloom 등)

---

## 4. 다음 단계

→ v3.1.4: WebGL 성능 최적화
