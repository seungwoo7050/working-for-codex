# v2.0.2 설계 문서: 서버 간 통신 및 gRPC

## 개요

gRPC를 사용하여 분산된 게임 서버 간 통신을 구현하고, Redis Pub/Sub으로 글로벌 이벤트를 브로드캐스팅합니다.

## 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                        클라이언트                           │
└───────────────────────────┬─────────────────────────────────┘
                            │ (UDP/WebSocket)
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                      게임 서버 클러스터                      │
│                                                             │
│  ┌─────────────┐    gRPC    ┌─────────────┐                │
│  │  서버 A     │◄──────────►│  서버 B     │                │
│  │ (매칭)      │            │ (게임)      │                │
│  └──────┬──────┘            └──────┬──────┘                │
│         │                          │                       │
│         └──────────┬───────────────┘                       │
│                    │                                        │
└────────────────────┼────────────────────────────────────────┘
                     │
              ┌──────▼──────┐
              │   Redis     │
              │ (Pub/Sub)   │
              └─────────────┘
```

## gRPC 서비스 정의

### game_server.proto

```protobuf
syntax = "proto3";

package pvpserver;

option cc_generic_services = true;

// ========== Matchmaking Service ==========

service MatchmakingService {
    // 매치 요청
    rpc RequestMatch(MatchRequest) returns (MatchResponse);

    // 매치 취소
    rpc CancelMatch(CancelMatchRequest) returns (CancelMatchResponse);

    // 매치 상태 조회
    rpc GetMatchStatus(MatchStatusRequest) returns (MatchStatusResponse);

    // 매치 완료 알림 (스트리밍)
    rpc StreamMatchEvents(MatchEventRequest) returns (stream MatchEvent);
}

message MatchRequest {
    string player_id = 1;
    int32 elo_rating = 2;
    string preferred_region = 3;
    repeated string game_modes = 4;
}

message MatchResponse {
    bool success = 1;
    string match_id = 2;
    string server_address = 3;
    int32 udp_port = 4;
    int32 estimated_wait_seconds = 5;
    string error_message = 6;
}

message CancelMatchRequest {
    string player_id = 1;
    string match_id = 2;
}

message CancelMatchResponse {
    bool success = 1;
    string error_message = 2;
}

message MatchStatusRequest {
    string player_id = 1;
}

message MatchStatusResponse {
    enum Status {
        NOT_IN_QUEUE = 0;
        WAITING = 1;
        MATCHED = 2;
        CONNECTING = 3;
        IN_GAME = 4;
    }
    Status status = 1;
    string match_id = 2;
    int32 wait_time_seconds = 3;
    int32 players_in_queue = 4;
}

message MatchEventRequest {
    string player_id = 1;
}

message MatchEvent {
    enum EventType {
        MATCH_FOUND = 0;
        MATCH_CANCELLED = 1;
        MATCH_STARTED = 2;
        OPPONENT_DISCONNECTED = 3;
    }
    EventType event_type = 1;
    string match_id = 2;
    string server_address = 3;
    int32 udp_port = 4;
    map<string, string> metadata = 5;
}

// ========== Game Server Service ==========

service GameServerService {
    // 서버 상태 조회
    rpc GetServerStatus(ServerStatusRequest) returns (ServerStatusResponse);

    // 플레이어 이전 (서버 간)
    rpc TransferPlayer(TransferPlayerRequest) returns (TransferPlayerResponse);

    // 이벤트 브로드캐스트
    rpc BroadcastEvent(EventRequest) returns (EventResponse);

    // 헬스체크
    rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
}

message ServerStatusRequest {
    string server_id = 1;
}

message ServerStatusResponse {
    string server_id = 1;
    string region = 2;
    int32 current_players = 3;
    int32 max_players = 4;
    int32 active_matches = 5;
    double cpu_usage = 6;
    double memory_usage = 7;
    int64 uptime_seconds = 8;
}

message TransferPlayerRequest {
    string player_id = 1;
    string session_id = 2;
    string target_server_id = 3;
    bytes player_state = 4;  // 직렬화된 플레이어 상태
}

message TransferPlayerResponse {
    bool success = 1;
    string error_message = 2;
    string new_server_address = 3;
    int32 new_udp_port = 4;
}

message EventRequest {
    string event_type = 1;
    string source_server_id = 2;
    bytes event_data = 3;
    repeated string target_server_ids = 4;  // 비어있으면 전체 브로드캐스트
}

message EventResponse {
    bool success = 1;
    int32 servers_notified = 2;
}

message HealthCheckRequest {
    string client_id = 1;
}

message HealthCheckResponse {
    enum ServingStatus {
        UNKNOWN = 0;
        SERVING = 1;
        NOT_SERVING = 2;
    }
    ServingStatus status = 1;
}
```

## 서비스 구현

### MatchmakingServiceImpl

```cpp
// grpc/matchmaking_service.h
#pragma once

#include "game_server.grpc.pb.h"
#include "pvpserver/matchmaking/matchmaker.h"
#include "pvpserver/distributed/load_balancer.h"
#include <grpcpp/grpcpp.h>

namespace pvpserver {
namespace grpc {

class MatchmakingServiceImpl final : public MatchmakingService::Service {
public:
    MatchmakingServiceImpl(
        std::shared_ptr<matchmaking::Matchmaker> matchmaker,
        std::shared_ptr<distributed::LoadBalancer> balancer);

    ::grpc::Status RequestMatch(
        ::grpc::ServerContext* context,
        const MatchRequest* request,
        MatchResponse* response) override;

    ::grpc::Status CancelMatch(
        ::grpc::ServerContext* context,
        const CancelMatchRequest* request,
        CancelMatchResponse* response) override;

    ::grpc::Status GetMatchStatus(
        ::grpc::ServerContext* context,
        const MatchStatusRequest* request,
        MatchStatusResponse* response) override;

    ::grpc::Status StreamMatchEvents(
        ::grpc::ServerContext* context,
        const MatchEventRequest* request,
        ::grpc::ServerWriter<MatchEvent>* writer) override;

private:
    std::shared_ptr<matchmaking::Matchmaker> matchmaker_;
    std::shared_ptr<distributed::LoadBalancer> balancer_;
};

}  // namespace grpc
}  // namespace pvpserver
```

### GameServerServiceImpl

```cpp
// grpc/game_server_service.h
#pragma once

#include "game_server.grpc.pb.h"
#include "pvpserver/network/udp_game_server.h"
#include <grpcpp/grpcpp.h>

namespace pvpserver {
namespace grpc {

class GameServerServiceImpl final : public GameServerService::Service {
public:
    explicit GameServerServiceImpl(
        std::shared_ptr<network::UdpGameServer> game_server,
        const std::string& server_id);

    ::grpc::Status GetServerStatus(
        ::grpc::ServerContext* context,
        const ServerStatusRequest* request,
        ServerStatusResponse* response) override;

    ::grpc::Status TransferPlayer(
        ::grpc::ServerContext* context,
        const TransferPlayerRequest* request,
        TransferPlayerResponse* response) override;

    ::grpc::Status BroadcastEvent(
        ::grpc::ServerContext* context,
        const EventRequest* request,
        EventResponse* response) override;

    ::grpc::Status HealthCheck(
        ::grpc::ServerContext* context,
        const HealthCheckRequest* request,
        HealthCheckResponse* response) override;

private:
    std::shared_ptr<network::UdpGameServer> game_server_;
    std::string server_id_;
};

}  // namespace grpc
}  // namespace pvpserver
```

## EventBroadcaster

Redis Pub/Sub을 사용한 글로벌 이벤트 브로드캐스팅입니다.

```cpp
// distributed/event_broadcaster.h
#pragma once

#include <functional>
#include <memory>
#include <string>
#include <thread>
#include <unordered_map>

namespace pvpserver {
namespace distributed {

struct GameEvent {
    std::string type;
    std::string source_server;
    std::string payload;
    int64_t timestamp;

    std::string Serialize() const;
    static GameEvent Deserialize(const std::string& data);
};

class RedisClient;

class EventBroadcaster {
public:
    explicit EventBroadcaster(std::shared_ptr<RedisClient> redis);
    ~EventBroadcaster();

    // 이벤트 발행
    void Publish(const std::string& channel, const GameEvent& event);

    // 글로벌 브로드캐스트
    void BroadcastGlobal(const GameEvent& event);

    // 채널 구독
    void Subscribe(const std::string& channel,
                  std::function<void(const GameEvent&)> handler);

    // 구독 해제
    void Unsubscribe(const std::string& channel);

    // 구독 시작 (백그라운드 스레드)
    void Start();
    void Stop();

private:
    std::shared_ptr<RedisClient> redis_;
    std::unordered_map<std::string,
                      std::function<void(const GameEvent&)>> handlers_;
    std::mutex handlers_mutex_;

    std::atomic<bool> running_{false};
    std::thread subscriber_thread_;

    static constexpr const char* GLOBAL_CHANNEL = "pvp:events:global";

    void SubscriberLoop();
};

}  // namespace distributed
}  // namespace pvpserver
```

## gRPC 서버 설정

```cpp
// grpc/grpc_server.h
#pragma once

#include <grpcpp/grpcpp.h>
#include <memory>
#include <string>

namespace pvpserver {
namespace grpc {

class GrpcServer {
public:
    GrpcServer(const std::string& address, int port);
    ~GrpcServer();

    void RegisterService(::grpc::Service* service);
    void Start();
    void Stop();
    void Wait();

private:
    std::string address_;
    int port_;
    std::unique_ptr<::grpc::Server> server_;
    ::grpc::ServerBuilder builder_;
};

}  // namespace grpc
}  // namespace pvpserver
```

## 이벤트 유형

### 글로벌 이벤트
| 이벤트 | 설명 |
|--------|------|
| `server.online` | 서버 온라인 |
| `server.offline` | 서버 오프라인 |
| `match.created` | 매치 생성됨 |
| `match.ended` | 매치 종료됨 |
| `player.banned` | 플레이어 밴 처리 |
| `system.maintenance` | 시스템 점검 알림 |

### 이벤트 채널
| 채널 | 용도 |
|------|------|
| `pvp:events:global` | 전체 서버 |
| `pvp:events:match:{match_id}` | 특정 매치 |
| `pvp:events:region:{region}` | 특정 리전 |

## 의존성

### vcpkg.json 추가
```json
{
  "dependencies": [
    "grpc",
    "protobuf"
  ]
}
```

### CMakeLists.txt 추가
```cmake
find_package(gRPC CONFIG REQUIRED)
find_package(protobuf CONFIG REQUIRED)

# Proto 파일 컴파일
add_custom_command(
    OUTPUT ${PROTO_SRCS} ${PROTO_HDRS} ${GRPC_SRCS} ${GRPC_HDRS}
    COMMAND protobuf::protoc
    ARGS --grpc_out=${CMAKE_CURRENT_BINARY_DIR}
         --cpp_out=${CMAKE_CURRENT_BINARY_DIR}
         --plugin=protoc-gen-grpc=$<TARGET_FILE:gRPC::grpc_cpp_plugin>
         -I ${CMAKE_SOURCE_DIR}/proto
         ${CMAKE_SOURCE_DIR}/proto/game_server.proto
    DEPENDS ${CMAKE_SOURCE_DIR}/proto/game_server.proto
)
```

## 테스트 전략

### 단위 테스트
- gRPC 서비스 메서드 동작
- 이벤트 직렬화/역직렬화
- 에러 처리

### 통합 테스트
- 서버 간 gRPC 통신
- Redis Pub/Sub 이벤트 전파
- 플레이어 이전 시나리오

## 성능 목표

| 메트릭 | 목표 |
|--------|------|
| gRPC 요청/응답 | < 5ms |
| 이벤트 브로드캐스트 | < 10ms |
| 동시 gRPC 연결 | 1000+ |
| 이벤트 처리량 | 10,000 events/sec |
