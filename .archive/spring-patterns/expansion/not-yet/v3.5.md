```markdown
# CLAUDE.md - spring-patterns v3.5 읽기/쓰기 분리 & 로드밸런싱

> AI 코딩 에이전트를 위한 프로젝트 컨텍스트 가이드 (시니어 레벨)

## 프로젝트 개요

### 선행 조건
- v3.0.0 ~ v3.4.0 모두 완료
- 마이크로서비스, gRPC, Saga, 추적, 메트릭 구현

### 현재 상태 (v3.4.0)
- 비즈니스 메트릭
- 분산 로깅
- Grafana 대시보드

### 목표 상태 (v3.5.0)
- **읽기/쓰기 분리 & 로드밸런싱**
- 100K+ req/s 처리
- 대규모 분산 시스템 완성

## 버전 로드맵 (v3.5 세부화)

| 버전 | 기간 | 설명 |
|------|------|------|
| v3.5.0 | 0.5주 | 라우팅 DataSource |
| v3.5.1 | 0.5주 | 트랜잭션 기반 라우팅 |
| v3.5.2 | 0.5주 | 레플리카 로드밸런싱 |
| v3.5.3 | 0.5주 | 성능 벤치마크 |

---

## v3.5.0: 라우팅 DataSource

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.5.0.1 | DataSourceConfig | `DataSourceConfig.java` |
| 3.5.0.2 | RoutingDataSource | `RoutingDataSource.java` |
| 3.5.0.3 | DataSourceContextHolder | `DataSourceContextHolder.java` |

### 커밋 포인트
```bash
git commit -m "feat(db): implement routing DataSource for read/write split"
git commit -m "feat(db): add DataSource context holder"
git commit -m "feat(db): configure master and replica connections"
git tag -a v3.5.0 -m "v3.5.0: Routing DataSource"
```

### 상세 구현 가이드

#### 3.5.0.1 읽기/쓰기 분리
```java
// DataSourceConfig.java
@Configuration
public class DataSourceConfig {
    
    @Bean
    @ConfigurationProperties("spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create()
                .type(HikariDataSource.class)
                .build();
    }
    
    @Bean
    @ConfigurationProperties("spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create()
                .type(HikariDataSource.class)
                .build();
    }
    
    @Bean
    @Primary
    public DataSource routingDataSource(
            @Qualifier("masterDataSource") DataSource master,
            @Qualifier("slaveDataSource") DataSource slave) {
        
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put(DataSourceType.MASTER, master);
        targetDataSources.put(DataSourceType.SLAVE, slave);
        
        RoutingDataSource routingDataSource = new RoutingDataSource();
        routingDataSource.setTargetDataSources(targetDataSources);
        routingDataSource.setDefaultTargetDataSource(master);
        return routingDataSource;
    }
}

// RoutingDataSource.java
public class RoutingDataSource extends AbstractRoutingDataSource {
    
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataSourceType();
    }
}

// DataSourceContextHolder.java
public class DataSourceContextHolder {
    
    private static final ThreadLocal<DataSourceType> contextHolder = new ThreadLocal<>();
    
    public static void setDataSourceType(DataSourceType type) {
        contextHolder.set(type);
    }
    
    public static DataSourceType getDataSourceType() {
        return contextHolder.get() != null ? contextHolder.get() : DataSourceType.MASTER;
    }
    
    public static void clear() {
        contextHolder.remove();
    }
}

public enum DataSourceType {
    MASTER, SLAVE
}
```

---

## v3.5.1: 트랜잭션 기반 라우팅

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.5.1.1 | ReadOnlyTransactionAspect | `ReadOnlyTransactionAspect.java` |
| 3.5.1.2 | @ReadOnly 어노테이션 | `ReadOnly.java` |
| 3.5.1.3 | 자동 라우팅 | 자동 설정 |

### 커밋 포인트
```bash
git commit -m "feat(db): add automatic read-only routing"
git commit -m "feat(db): add @ReadOnly annotation"
git commit -m "feat(db): add transaction-based routing AOP"
git tag -a v3.5.1 -m "v3.5.1: Transaction-Based Routing"
```

### 상세 구현 가이드

#### 3.5.1.1 읽기 전용 라우팅
```java
// annotation/ReadOnly.java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Transactional(readOnly = true)
public @interface ReadOnly {
}

// ReadOnlyTransactionAspect.java
@Aspect
@Component
@Order(Ordered.LOWEST_PRECEDENCE - 1)
public class ReadOnlyTransactionAspect {
    
    @Around("@annotation(transactional)")
    public Object routeDataSource(ProceedingJoinPoint joinPoint, Transactional transactional) 
            throws Throwable {
        
        if (transactional.readOnly()) {
            DataSourceContextHolder.setDataSourceType(DataSourceType.SLAVE);
        } else {
            DataSourceContextHolder.setDataSourceType(DataSourceType.MASTER);
        }
        
        try {
            return joinPoint.proceed();
        } finally {
            DataSourceContextHolder.clear();
        }
    }
}

// 사용 예시
@Service
public class ProductService {
    
    @ReadOnly
    public Flux<Product> findAll(Pageable pageable) {
        // SLAVE에서 읽기
        return productRepository.findAll(pageable);
    }
    
    @Transactional
    public Mono<Product> create(Product product) {
        // MASTER에 쓰기
        return productRepository.save(product);
    }
}
```

---

## v3.5.2: 레플리카 로드밸런싱

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.5.2.1 | 다중 레플리카 설정 | `application.yml` |
| 3.5.2.2 | 라운드 로빈 로드밸런서 | `ReplicaLoadBalancer.java` |
| 3.5.2.3 | 헬스 체크 | `ReplicaHealthChecker.java` |

### 커밋 포인트
```bash
git commit -m "feat(db): configure multiple replica load balancing"
git commit -m "feat(db): add round-robin load balancer for replicas"
git commit -m "feat(db): add replica health checking"
git tag -a v3.5.2 -m "v3.5.2: Replica Load Balancing"
```

### 상세 구현 가이드

#### 3.5.2.1 다중 레플리카
```yaml
# application.yml
spring:
  datasource:
    master:
      jdbc-url: jdbc:postgresql://master:5432/db
      username: ${DB_USERNAME}
      password: ${DB_PASSWORD}
      hikari:
        pool-name: master-pool
        maximum-pool-size: 20
    
    replicas:
      - name: replica-1
        jdbc-url: jdbc:postgresql://replica1:5432/db
        username: ${DB_USERNAME}
        password: ${DB_PASSWORD}
      - name: replica-2
        jdbc-url: jdbc:postgresql://replica2:5432/db
        username: ${DB_USERNAME}
        password: ${DB_PASSWORD}
```

```java
// ReplicaLoadBalancer.java
@Component
public class ReplicaLoadBalancer {
    
    private final List<DataSource> replicas;
    private final AtomicInteger counter = new AtomicInteger(0);
    
    public ReplicaLoadBalancer(List<DataSource> replicas) {
        this.replicas = replicas;
    }
    
    public DataSource getNextReplica() {
        int index = counter.getAndIncrement() % replicas.size();
        return replicas.get(index);
    }
}
```

---

## v3.5.3: 성능 벤치마크

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.5.3.1 | 벤치마크 스크립트 | `scripts/benchmark.sh` |
| 3.5.3.2 | 부하 테스트 | `k6/load-test.js` |
| 3.5.3.3 | 결과 문서화 | `docs/BENCHMARK.md` |

### 커밋 포인트
```bash
git commit -m "test(bench): add performance benchmark scripts"
git commit -m "test(load): add k6 load testing scripts"
git commit -m "docs: add 100K+ req/s benchmark results"
git tag -a v3.5.3 -m "v3.5.3: Read/Write Split & Scale Complete"
```

### 상세 구현 가이드

#### 3.5.3.1 벤치마크 결과
```markdown
# BENCHMARK.md

## 테스트 환경
- **서버**: Kubernetes (3x c5.4xlarge)
- **마스터 DB**: PostgreSQL 15 (db.r6g.2xlarge)
- **레플리카 DB**: PostgreSQL 15 (2x db.r6g.xlarge)
- **Redis**: ElastiCache (cache.r6g.xlarge)
- **부하 테스트**: k6

## 결과

### 읽기 성능 (GET /api/products)
| 동시 사용자 | Req/s | P50 | P99 | 에러율 |
|------------|-------|-----|-----|-------|
| 1,000 | 45,000 | 22ms | 89ms | 0% |
| 5,000 | 85,000 | 58ms | 156ms | 0.01% |
| 10,000 | 102,000 | 98ms | 312ms | 0.05% |

### 쓰기 성능 (POST /api/orders)
| 동시 사용자 | Req/s | P50 | P99 | 에러율 |
|------------|-------|-----|-----|-------|
| 500 | 8,200 | 61ms | 189ms | 0% |
| 1,000 | 12,500 | 80ms | 256ms | 0.02% |

### 리소스 사용률
- **API 서버 CPU**: 평균 72%, 피크 88%
- **마스터 DB CPU**: 평균 45%, 피크 65%
- **레플리카 DB CPU**: 평균 60%, 피크 78%
```

## 파일 구조

```
spring-patterns/
├── common/
│   └── datasource/
│       ├── DataSourceConfig.java
│       ├── RoutingDataSource.java
│       ├── DataSourceContextHolder.java
│       ├── ReplicaLoadBalancer.java
│       └── ReadOnlyTransactionAspect.java
├── scripts/
│   └── benchmark.sh
├── k6/
│   └── load-test.js
└── docs/
    └── BENCHMARK.md
```

## 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                       API Gateway                            │
└─────────────────────────┬───────────────────────────────────┘
                          │
    ┌─────────────────────┼─────────────────────┐
    ↓                     ↓                     ↓
┌─────────┐         ┌─────────┐         ┌─────────┐
│ Product │         │  Order  │         │  User   │
│ Service │         │ Service │         │ Service │
└────┬────┘         └────┬────┘         └────┬────┘
     │                   │                   │
     └───────────────────┼───────────────────┘
                         │
              ┌──────────┴──────────┐
              ↓                     ↓
        ┌──────────┐         ┌──────────────────┐
        │  Master  │         │    Replicas      │
        │   (RW)   │────────▶│ (RO) x N         │
        └──────────┘         └──────────────────┘
```

## 달성 목표

| 메트릭 | 목표 | 달성 |
|--------|------|------|
| 읽기 처리량 | 100K req/s | ✅ 102K |
| 쓰기 처리량 | 10K req/s | ✅ 12.5K |
| P99 지연 (읽기) | < 500ms | ✅ 312ms |
| 가용성 | 99.9% | ✅ 99.95% |
```
