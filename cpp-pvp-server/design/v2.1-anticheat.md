# v2.1 설계 문서: 안티 치트 시스템

## 개요

서버 권위 모델을 강화하고 치트 행위를 탐지/차단하는 안티 치트 시스템을 구현합니다.

## 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                     게임 서버                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                Anti-Cheat System                     │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │   │
│  │  │ HitValidator│  │ Movement    │  │  Anomaly    │  │   │
│  │  │             │  │ Validator   │  │  Detector   │  │   │
│  │  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  │   │
│  │         │                │                │         │   │
│  │  ┌──────▼────────────────▼────────────────▼──────┐  │   │
│  │  │             Suspicion System                   │  │   │
│  │  └───────────────────────┬───────────────────────┘  │   │
│  │                          │                          │   │
│  │  ┌───────────────────────▼───────────────────────┐  │   │
│  │  │              Ban Service                       │  │   │
│  │  └───────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Replay Recorder                         │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

## v2.1.0: 서버 권위적 히트 검증

### 문제점
클라이언트가 "히트"를 주장하면 서버가 그대로 수락하는 경우 에임봇 치트에 취약합니다.

### 해결책
1. 서버 측 레이캐스팅으로 히트 검증
2. 지연 보상을 위한 과거 월드 상태 버퍼링
3. AABB 및 상세 히트박스 충돌 감지

### 컴포넌트

#### HitValidator
```cpp
// anticheat/hit_validator.h
struct HitRequest {
    std::string shooter_id;
    std::string target_id;
    Vec3 origin;
    Vec3 direction;
    int64_t client_timestamp;  // 지연 보상용
};

struct HitResult {
    bool valid;
    std::string target_id;
    Vec3 hit_point;
    float damage;
    HitboxType hitbox;  // HEAD, BODY, LIMB
    std::string reject_reason;
};

class HitValidator {
public:
    HitResult ValidateHit(const HitRequest& request);

private:
    RaycastSystem raycast_system_;
    WorldStateBuffer state_buffer_;
};
```

#### RaycastSystem
```cpp
// anticheat/raycast_system.h
struct RaycastHit {
    std::string entity_id;
    Vec3 hit_point;
    Vec3 hit_normal;
    float distance;
    HitboxType hitbox;
};

class RaycastSystem {
public:
    std::optional<RaycastHit> Cast(
        const WorldState& world,
        const Vec3& origin,
        const Vec3& direction,
        float max_distance,
        const std::vector<std::string>& ignore_list);

private:
    bool IntersectAABB(const Ray& ray, const AABB& box, float& t);
    bool IntersectCapsule(const Ray& ray, const Capsule& capsule, float& t);
};
```

#### WorldStateBuffer
```cpp
// anticheat/world_state_buffer.h
class WorldStateBuffer {
public:
    static constexpr int BUFFER_SIZE = 64;  // 60 TPS 기준 약 1초
    static constexpr int MAX_REWIND_MS = 200;  // 최대 되감기 200ms

    void SaveState(int64_t tick, const WorldState& state);
    WorldState GetStateAt(int64_t timestamp);
    WorldState InterpolateState(const WorldState& a, const WorldState& b, float t);

private:
    struct TimestampedState {
        int64_t timestamp;
        WorldState state;
    };
    std::array<TimestampedState, BUFFER_SIZE> buffer_;
    int head_ = 0;
};
```

## v2.1.1: 이동 속도 및 월핵 탐지

### MovementValidator
```cpp
// anticheat/movement_validator.h
struct MovementCheck {
    bool valid;
    float actual_speed;
    float max_allowed_speed;
    ViolationType violation;  // NONE, SPEEDHACK, TELEPORT, WALLCLIP
};

class MovementValidator {
public:
    static constexpr float BASE_SPEED = 5.0f;
    static constexpr float SPRINT_MULTIPLIER = 1.5f;
    static constexpr float TOLERANCE = 1.1f;  // 10% 오차 허용

    MovementCheck ValidateMovement(
        const std::string& player_id,
        const Vec3& old_pos,
        const Vec3& new_pos,
        float delta_time);

private:
    struct PlayerMovementState {
        bool is_sprinting;
        bool is_slowed;
        float speed_modifier;
    };

    std::unordered_map<std::string, PlayerMovementState> states_;

    bool DetectTeleport(const Vec3& old_pos, const Vec3& new_pos, float delta_time);
    bool DetectWallClip(const Vec3& old_pos, const Vec3& new_pos);
};
```

### 탐지 로직

#### 속도핵 탐지
```cpp
float max_speed = BASE_SPEED;
if (state.is_sprinting) max_speed *= SPRINT_MULTIPLIER;
max_speed *= state.speed_modifier * TOLERANCE;

float actual_speed = Distance(old_pos, new_pos) / delta_time;
if (actual_speed > max_speed) {
    return {false, actual_speed, max_speed, ViolationType::SPEEDHACK};
}
```

#### 텔레포트 탐지
```cpp
float distance = Distance(old_pos, new_pos);
float max_possible = MAX_SPEED * delta_time * 3.0f;  // 3배 버퍼
if (distance > max_possible) {
    return ViolationType::TELEPORT;
}
```

#### 월핵 탐지
```cpp
RaycastResult result = StaticRaycast(old_pos, new_pos);
if (result.hit_obstacle) {
    return ViolationType::WALLCLIP;
}
```

## v2.1.2: 이상 행동 통계 탐지

### CombatStats
```cpp
// anticheat/combat_stats.h
struct CombatStats {
    // 기본 통계
    int total_shots = 0;
    int hits = 0;
    int headshots = 0;
    int kills = 0;
    int deaths = 0;

    // 반응 시간 (적 발견 → 사격)
    std::vector<float> reaction_times;

    // 연속 킬
    int current_streak = 0;
    int max_kill_streak = 0;

    // 계산 메서드
    float Accuracy() const { return total_shots > 0 ? float(hits) / total_shots : 0; }
    float HeadshotRatio() const { return hits > 0 ? float(headshots) / hits : 0; }
    float AvgReactionTime() const;
    float StdReactionTime() const;
};
```

### AnomalyDetector
```cpp
// anticheat/anomaly_detector.h
struct AnomalyScore {
    float accuracy;       // 0.0 ~ 1.0
    float headshot;       // 0.0 ~ 1.0
    float reaction;       // 0.0 ~ 1.0
    float consistency;    // 0.0 ~ 1.0 (너무 일정하면 봇 의심)

    float Combined() const {
        return accuracy * 0.3f + headshot * 0.3f +
               reaction * 0.2f + consistency * 0.2f;
    }
};

class AnomalyDetector {
public:
    AnomalyScore Analyze(const CombatStats& stats);

private:
    // 글로벌 평균/표준편차 (모든 플레이어 기준)
    struct GlobalStats {
        float avg_accuracy = 0.25f;
        float std_accuracy = 0.1f;
        float avg_headshot = 0.15f;
        float std_headshot = 0.08f;
        float avg_reaction = 250.0f;  // ms
        float std_reaction = 100.0f;
    };
    GlobalStats global_;

    float CalculateZScore(float value, float mean, float stddev);
    float ZScoreToAnomaly(float zscore);
};
```

### SuspicionSystem
```cpp
// anticheat/suspicion_system.h
enum class SuspicionLevel {
    NONE = 0,
    LOW = 1,       // 주의 관찰
    MEDIUM = 2,    // 상세 모니터링
    HIGH = 3,      // 리플레이 자동 저장
    CRITICAL = 4   // 자동 밴 후보
};

struct Violation {
    std::string type;
    float severity;
    int64_t timestamp;
    std::string details;
};

class SuspicionSystem {
public:
    void RecordViolation(const std::string& player_id, const Violation& v);
    void UpdateAnomalyScore(const std::string& player_id, const AnomalyScore& score);

    SuspicionLevel GetLevel(const std::string& player_id) const;
    std::vector<Violation> GetHistory(const std::string& player_id) const;
    float GetTotalScore(const std::string& player_id) const;

private:
    struct PlayerSuspicion {
        float total_score = 0.0f;
        std::vector<Violation> violations;
        SuspicionLevel level = SuspicionLevel::NONE;
    };

    std::unordered_map<std::string, PlayerSuspicion> suspicions_;

    SuspicionLevel CalculateLevel(float score) const;
};
```

## v2.1.3: 리플레이 시스템

### ReplayRecorder
```cpp
// anticheat/replay_recorder.h
struct ReplayFrame {
    int64_t tick;
    int64_t timestamp;
    std::vector<PlayerState> players;
    std::vector<ProjectileState> projectiles;
    std::vector<GameEvent> events;
};

class ReplayRecorder {
public:
    void StartRecording(const std::string& match_id);
    void RecordFrame(const ReplayFrame& frame);
    void StopRecording();

    std::vector<uint8_t> GetCompressedReplay();
    std::vector<uint8_t> GetPlayerPOV(const std::string& player_id);

private:
    std::string match_id_;
    std::vector<ReplayFrame> frames_;
    bool recording_ = false;

    std::vector<uint8_t> Compress(const std::vector<ReplayFrame>& frames);
};
```

### ReplayStorage
```cpp
// anticheat/replay_storage.h
class ReplayStorage {
public:
    void SaveReplay(const std::string& match_id, const std::vector<uint8_t>& data);
    std::optional<std::vector<uint8_t>> LoadReplay(const std::string& match_id);
    void DeleteReplay(const std::string& match_id);

    // 메타데이터 조회
    struct ReplayMetadata {
        std::string match_id;
        int64_t recorded_at;
        int duration_seconds;
        std::vector<std::string> players;
        size_t file_size;
    };
    std::optional<ReplayMetadata> GetMetadata(const std::string& match_id);
    std::vector<ReplayMetadata> GetReplaysByPlayer(const std::string& player_id);
};
```

## v2.1.4: 밴 시스템

### BanPolicy
```cpp
// anticheat/ban_policy.h
enum class BanDuration {
    WARNING,
    TEMP_1_HOUR,
    TEMP_24_HOURS,
    TEMP_7_DAYS,
    TEMP_30_DAYS,
    PERMANENT
};

struct BanPolicy {
    SuspicionLevel trigger_level;
    BanDuration first_offense;
    BanDuration second_offense;
    BanDuration third_and_beyond;
};

// 기본 정책
static const std::vector<BanPolicy> DEFAULT_POLICIES = {
    {SuspicionLevel::CRITICAL, BanDuration::TEMP_7_DAYS, BanDuration::TEMP_30_DAYS, BanDuration::PERMANENT},
    {SuspicionLevel::HIGH, BanDuration::TEMP_24_HOURS, BanDuration::TEMP_7_DAYS, BanDuration::TEMP_30_DAYS},
};
```

### BanService
```cpp
// anticheat/ban_service.h
struct BanRecord {
    std::string player_id;
    std::string hardware_id;
    std::string ip_address;
    BanDuration duration;
    int64_t ban_start;
    int64_t ban_end;  // 0 = 영구
    std::string reason;
    std::vector<std::string> evidence;  // 리플레이 ID 등
};

class BanService {
public:
    // 밴 확인
    bool IsPlayerBanned(const std::string& player_id);
    bool IsHardwareBanned(const std::string& hardware_id);
    bool IsIpBanned(const std::string& ip);

    // 밴 적용
    void BanPlayer(const BanRecord& record);
    void UnbanPlayer(const std::string& player_id);

    // 이력 조회
    std::vector<BanRecord> GetBanHistory(const std::string& player_id);
    std::optional<BanRecord> GetActiveBan(const std::string& player_id);

private:
    std::shared_ptr<SessionStore> store_;  // Redis 사용
};
```

## 성능 고려사항

| 작업 | 목표 시간 |
|------|----------|
| 히트 검증 (레이캐스트) | < 100μs |
| 이동 검증 | < 10μs |
| 이상치 분석 | < 1ms |
| 리플레이 프레임 저장 | < 50μs |

## 테스트 전략

### 단위 테스트
- 레이캐스트 AABB/캡슐 교차 테스트
- 속도/텔레포트 탐지 로직
- Z-score 이상치 계산

### 통합 테스트
- 실제 치트 시뮬레이션 (가상 치터)
- 오탐지율 (False Positive) 측정
- 미탐지율 (False Negative) 측정

### 성능 테스트
- 100명 동시 플레이어 검증 부하
- 리플레이 저장 IO 성능
