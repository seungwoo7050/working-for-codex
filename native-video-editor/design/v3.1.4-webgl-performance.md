# WebGL 성능 최적화 설계 일지 (v3.1.4)
> Phase 3.1 완료 - GPU 성능 최적화

## 1. 문제 정의 & 요구사항

### 1.1 핵심 목표

**v3.1.4 - WebGL Performance Optimization**:
- **상태 캐싱**: WebGL 상태 변경 최소화
- **배치 렌더링**: 드로우콜 최적화
- **GPU 메모리 최적화**: 텍스처/버퍼 재사용
- **프로파일링**: 성능 측정 및 병목 분석

### 1.2 성능 목표

- 60 FPS 유지 (16.67ms/프레임)
- 드로우콜 < 100/프레임
- GPU 메모리 < 500MB

---

## 2. 패치별 상세 설계

### 3.1.4.1: WebGL 상태 캐싱

**파일**: `frontend/src/webgl/StateCache.ts`

```typescript
interface BlendState {
  enabled: boolean;
  srcRGB: number;
  dstRGB: number;
  srcAlpha: number;
  dstAlpha: number;
}

interface DepthState {
  testEnabled: boolean;
  writeEnabled: boolean;
  func: number;
}

interface CullState {
  enabled: boolean;
  face: number;
}

class StateCache {
  private gl: WebGL2RenderingContext;
  private currentProgram: WebGLProgram | null = null;
  private currentVAO: WebGLVertexArrayObject | null = null;
  private boundTextures: Map<number, WebGLTexture | null> = new Map();
  private currentFramebuffer: WebGLFramebuffer | null = null;
  private activeTextureUnit: number = 0;
  
  private blendState: BlendState;
  private depthState: DepthState;
  private cullState: CullState;
  private viewport: { x: number; y: number; width: number; height: number };
  
  private stateChanges = 0;
  private stateSaved = 0;
  
  constructor(gl: WebGL2RenderingContext) {
    this.gl = gl;
    this.initializeState();
  }
  
  private initializeState(): void {
    // Read current GL state to initialize cache
  }
  
  useProgram(program: WebGLProgram | null): void {
    if (this.currentProgram !== program) {
      this.gl.useProgram(program);
      this.currentProgram = program;
      this.stateChanges++;
    } else {
      this.stateSaved++;
    }
  }
  
  bindTexture(unit: number, texture: WebGLTexture): void {
    if (this.boundTextures.get(unit) !== texture) {
      this.gl.activeTexture(this.gl.TEXTURE0 + unit);
      this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
      this.boundTextures.set(unit, texture);
      this.stateChanges++;
    } else {
      this.stateSaved++;
    }
  }
  
  invalidate(): void {
    this.currentProgram = null;
    this.currentVAO = null;
    this.boundTextures.clear();
    this.currentFramebuffer = null;
  }
  
  getStats(): { stateChanges: number; stateSaved: number } {
    return { stateChanges: this.stateChanges, stateSaved: this.stateSaved };
  }
}
```

---

### 3.1.4.2: 배치 렌더링

**파일**: `frontend/src/webgl/BatchRenderer.ts`

```typescript
interface BatchItem {
  texture: WebGLTexture;
  x: number;
  y: number;
  width: number;
  height: number;
  u0?: number;  // 텍스쳐 좌표 (default: 0)
  v0?: number;
  u1?: number;  // (default: 1)
  v1?: number;
}

class BatchRenderer {
  private gl: WebGL2RenderingContext;
  private stateCache: StateCache;
  private shader: ShaderProgram;
  
  private vao: WebGLVertexArrayObject;
  private vbo: WebGLBuffer;
  private ibo: WebGLBuffer;
  
  private maxBatchSize: number;
  private batchSize: number = 0;
  private vertices: Float32Array;
  private indices: Uint16Array;
  
  private currentTexture: WebGLTexture | null = null;
  private drawCalls: number = 0;
  private totalSprites: number = 0;
  
  // Per vertex: x, y, u, v (4 floats)
  private static readonly FLOATS_PER_VERTEX = 4;
  private static readonly VERTICES_PER_SPRITE = 4;
  private static readonly INDICES_PER_SPRITE = 6;
  
  constructor(
    gl: WebGL2RenderingContext,
    stateCache: StateCache,
    shader: ShaderProgram,
    maxBatchSize: number = 1000
  ) {
    this.gl = gl;
    this.stateCache = stateCache;
    this.shader = shader;
    this.maxBatchSize = maxBatchSize;
    this.setupBuffers();
  }
  
  add(item: BatchItem): void {
    if (item.texture !== this.currentTexture) {
      this.flush();
      this.currentTexture = item.texture;
    }
    
    if (this.batchSize >= this.maxBatchSize) {
      this.flush();
    }
    
    this.addSprite(item);
    this.batchSize++;
  }
  
  flush(): void {
    if (this.batchSize === 0) return;
    
    // Upload vertices and draw
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbo);
    this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.vertices);
    
    this.gl.bindVertexArray(this.vao);
    this.gl.drawElements(this.gl.TRIANGLES, this.batchSize * 6, this.gl.UNSIGNED_SHORT, 0);
    
    this.drawCalls++;
    this.totalSprites += this.batchSize;
    this.batchSize = 0;
  }
  
  getStats(): { drawCalls: number; totalSprites: number } {
    return { drawCalls: this.drawCalls, totalSprites: this.totalSprites };
  }
}
```

---

### 3.1.4.3: GPU 메모리 최적화

**파일**: `frontend/src/webgl/GPUMemoryOptimizer.ts`

```typescript
interface TextureInfo {
  id: string;
  texture: WebGLTexture;
  width: number;
  height: number;
  format: number;
  lastUsed: number;
  bytesPerPixel: number;
}

interface MemoryStats {
  textureCount: number;
  textureMemory: number;
  bufferMemory: number;
  totalMemory: number;
  memoryLimit: number;
  usagePercent: number;
}

class GPUMemoryOptimizer {
  private gl: WebGL2RenderingContext;
  private textures: Map<string, TextureInfo> = new Map();
  private bufferMemory: number = 0;
  private memoryLimit: number;
  private evictionThreshold: number;
  private evictionCount: number = 0;
  private peakMemory: number = 0;
  
  constructor(
    gl: WebGL2RenderingContext,
    memoryLimitMB: number = 256,
    evictionThreshold: number = 0.8
  ) {
    this.gl = gl;
    this.memoryLimit = memoryLimitMB * 1024 * 1024;
    this.evictionThreshold = evictionThreshold;
  }
  
  registerTexture(
    id: string,
    texture: WebGLTexture,
    width: number,
    height: number,
    format: number = this.gl.RGBA
  ): void {
    const bytesPerPixel = this.getBytesPerPixel(format);
    this.textures.set(id, {
      id, texture, width, height, format,
      lastUsed: Date.now(),
      bytesPerPixel,
    });
    this.checkMemoryPressure();
  }
  
  unregisterTexture(id: string): void {
    const info = this.textures.get(id);
    if (info) {
      this.gl.deleteTexture(info.texture);
      this.textures.delete(id);
    }
  }
  
  registerBuffer(sizeBytes: number): void {
    this.bufferMemory += sizeBytes;
    this.checkMemoryPressure();
  }
  
  touchTexture(id: string): void {
    const info = this.textures.get(id);
    if (info) info.lastUsed = Date.now();
  }
  
  getStats(): MemoryStats {
    const textureMemory = this.calculateTextureMemory();
    const totalMemory = textureMemory + this.bufferMemory;
    return {
      textureCount: this.textures.size,
      textureMemory,
      bufferMemory: this.bufferMemory,
      totalMemory,
      memoryLimit: this.memoryLimit,
      usagePercent: (totalMemory / this.memoryLimit) * 100,
    };
  }
}
```

---

### 3.1.4.4: WebGL 프로파일링

**파일**: `frontend/src/webgl/WebGLProfiler.ts`

```typescript
interface FrameStats {
  frameTime: number;
  drawCalls: number;
  triangles: number;
  stateChanges: number;
  textureBinds: number;
  shaderSwitches: number;
}

interface ProfilerReport {
  averageFrameTime: number;
  fps: number;
  minFrameTime: number;
  maxFrameTime: number;
  totalFrames: number;
  totalDrawCalls: number;
  averageDrawCalls: number;
}

class WebGLProfiler {
  private gl: WebGL2RenderingContext;
  private frameHistory: FrameStats[] = [];
  private maxHistorySize: number = 120;
  
  private currentFrame: FrameStats = this.createEmptyStats();
  private frameStartTime: number = 0;
  private isEnabled: boolean = true;
  
  // GPU timing support (EXT_disjoint_timer_query_webgl2)
  private gpuTimerExt: unknown | null;
  
  constructor(gl: WebGL2RenderingContext) {
    this.gl = gl;
    this.gpuTimerExt = gl.getExtension('EXT_disjoint_timer_query_webgl2');
  }
  
  private createEmptyStats(): FrameStats {
    return {
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      stateChanges: 0,
      textureBinds: 0,
      shaderSwitches: 0,
    };
  }
  
  enable(): void { this.isEnabled = true; }
  disable(): void { this.isEnabled = false; }
  
  beginFrame(): void {
    if (!this.isEnabled) return;
    this.frameStartTime = performance.now();
    this.currentFrame = this.createEmptyStats();
  }
  
  recordDrawCall(triangleCount: number = 0): void {
    if (!this.isEnabled) return;
    this.currentFrame.drawCalls++;
    this.currentFrame.triangles += triangleCount;
  }
  
  endFrame(): void {
    if (!this.isEnabled) return;
    this.currentFrame.frameTime = performance.now() - this.frameStartTime;
    
    this.frameHistory.push({ ...this.currentFrame });
    if (this.frameHistory.length > this.maxHistorySize) {
      this.frameHistory.shift();
    }
  }
  
  getReport(): ProfilerReport {
    if (this.frameHistory.length === 0) {
      return { averageFrameTime: 0, fps: 0, minFrameTime: 0, maxFrameTime: 0,
               totalFrames: 0, totalDrawCalls: 0, averageDrawCalls: 0 };
    }
    
    const times = this.frameHistory.map(f => f.frameTime);
    const avg = times.reduce((a, b) => a + b, 0) / times.length;
    
    return {
      averageFrameTime: avg,
      fps: 1000 / avg,
      minFrameTime: Math.min(...times),
      maxFrameTime: Math.max(...times),
      totalFrames: this.frameHistory.length,
      totalDrawCalls: this.frameHistory.reduce((a, f) => a + f.drawCalls, 0),
      averageDrawCalls: this.frameHistory.reduce((a, f) => a + f.drawCalls, 0) / this.frameHistory.length,
    };
  }
}
```

---

## 3. 완료 기준

- [ ] 상태 변경 캐싱으로 API 호출 50% 감소
- [ ] 배치 렌더링으로 드로우콜 최소화
- [ ] 텍스처/버퍼 풀링 동작
- [ ] 프로파일러 메트릭 확인 가능
- [ ] 60 FPS 실시간 프리뷰 달성

---

## 4. Phase 3.1 완료

→ 다음: Phase 3.2 (WebAudio 기반 오디오 편집)
