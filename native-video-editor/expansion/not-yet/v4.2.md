# CLAUDE.md - native-video-editor v4.2 GPU 가속 (하드웨어 인코더)

> 이 문서는 Claude AI 코딩 에이전트가 프로젝트 컨텍스트를 이해하기 위한 가이드입니다.

## 프로젝트 개요

### 선행 조건
- v4.1.0 GPU 필터 체인 완료
- 필터 처리된 프레임이 GPU 메모리에 유지

### 현재 상태 (v4.1.0)
- HW 디코더 + GPU 필터 체인 통합
- 실시간 필터링 가능 (제로카피)
- 기존 WebGL/WebAudio 기능 유지

### 목표 상태 (v4.2.0)
- **목표**: GPU 메모리에서 직접 하드웨어 인코딩 (완전 제로카피 파이프라인)
- **핵심 변경**: NVENC/VideoToolbox 인코더 통합
- **성능 향상**: 전체 파이프라인 15-25배 속도 향상

## 아키텍처

### 현재 (v4.1 - GPU 필터)
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Input     │────▶│ HW Decoder  │────▶│ GPU Filters │────▶│ SW Encoder  │
│   Video     │     │ (GPU 메모리)│     │ (CUDA/Metal)│     │   (CPU)     │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
```

### 목표 (v4.2 - HW 인코더)
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Input     │────▶│ HW Decoder  │────▶│ GPU Filters │────▶│ HW Encoder  │
│   Video     │     │ (GPU 메모리)│     │ (CUDA/Metal)│     │ (NVENC/VT)  │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
                          │                   │                   │
                       GPU 메모리 ────────────┴───────────────────┘
                        (완전 제로카피)
```

## 구현할 기능

### Phase 3: 하드웨어 인코더 (Week 5)

#### 3.1 하드웨어 인코더 래퍼
```cpp
// HWEncoder.hpp
class HWEncoder {
public:
    struct EncoderParams {
        int width, height;
        int fps = 30;
        int64_t bitrate = 5000000;  // 5 Mbps
        std::string codec = "h264";  // h264, hevc
        std::string preset = "fast";
    };

    static std::unique_ptr<HWEncoder> create(
        const std::string& outputPath,
        const EncoderParams& params,
        HWDecoder::Backend backend
    );

    // GPU 메모리에서 직접 인코딩 (제로카피)
    virtual bool encode(const IGPUFilter::Frame& frame) = 0;
    virtual void finalize() = 0;
};
```

#### 3.2 NVENC 구현
```cpp
// NVENCEncoder.cpp
class NVENCEncoder : public HWEncoder {
public:
    bool init(const std::string& outputPath, const EncoderParams& params) {
        // 1. 출력 포맷 컨텍스트
        avformat_alloc_output_context2(&formatCtx_, nullptr, nullptr, 
                                       outputPath.c_str());
        
        // 2. NVENC 인코더 찾기
        const AVCodec* encoder = avcodec_find_encoder_by_name("h264_nvenc");
        // 또는 hevc_nvenc
        
        // 3. 인코더 설정
        codecCtx_ = avcodec_alloc_context3(encoder);
        codecCtx_->width = params.width;
        codecCtx_->height = params.height;
        codecCtx_->time_base = {1, params.fps};
        codecCtx_->framerate = {params.fps, 1};
        codecCtx_->bit_rate = params.bitrate;
        codecCtx_->pix_fmt = AV_PIX_FMT_CUDA;  // GPU 메모리 직접 사용
        
        // 4. NVENC 옵션
        av_opt_set(codecCtx_->priv_data, "preset", params.preset.c_str(), 0);
        av_opt_set(codecCtx_->priv_data, "rc", "vbr", 0);  // Variable bitrate
        
        // 5. 하드웨어 컨텍스트 연결
        codecCtx_->hw_frames_ctx = av_hwframe_ctx_alloc(hwDeviceCtx_);
        
        return true;
    }

    bool encode(const IGPUFilter::Frame& frame) override {
        // GPU 메모리에서 직접 인코딩
        AVFrame* gpuFrame = av_frame_alloc();
        gpuFrame->data[0] = (uint8_t*)frame.gpuBuffer;
        gpuFrame->width = frame.width;
        gpuFrame->height = frame.height;
        gpuFrame->format = frame.format;
        
        // 인코딩
        int ret = avcodec_send_frame(codecCtx_, gpuFrame);
        if (ret < 0) return false;
        
        AVPacket* pkt = av_packet_alloc();
        ret = avcodec_receive_packet(codecCtx_, pkt);
        if (ret == 0) {
            // 패킷 쓰기
            av_interleaved_write_frame(formatCtx_, pkt);
        }
        
        av_packet_free(&pkt);
        av_frame_free(&gpuFrame);
        return true;
    }

    void finalize() override {
        // 남은 프레임 플러시
        avcodec_send_frame(codecCtx_, nullptr);
        AVPacket* pkt = av_packet_alloc();
        while (avcodec_receive_packet(codecCtx_, pkt) == 0) {
            av_interleaved_write_frame(formatCtx_, pkt);
            av_packet_free(&pkt);
            pkt = av_packet_alloc();
        }
        
        av_write_trailer(formatCtx_);
        avcodec_free_context(&codecCtx_);
        avformat_free_context(formatCtx_);
    }
};
```

#### 3.3 VideoToolbox 인코더 (macOS)
```cpp
// VideoToolboxEncoder.cpp
class VideoToolboxEncoder : public HWEncoder {
public:
    bool init(const std::string& outputPath, const EncoderParams& params) {
        av_hwdevice_ctx_create(&hwDeviceCtx_, AV_HWDEVICE_TYPE_VIDEOTOOLBOX,
                               nullptr, nullptr, 0);
        
        const AVCodec* encoder = avcodec_find_encoder_by_name("h264_videotoolbox");
        // ...
    }
    
    // VideoToolbox는 CVPixelBufferRef를 입력으로 받음
    // GPU 메모리에서 Metal 텍스처로 변환하여 인코딩
};
```

#### 3.4 VAAPI 인코더 (Linux)
```cpp
// VAAPIEncoder.cpp
class VAAPIEncoder : public HWEncoder {
public:
    bool init(const std::string& outputPath, const EncoderParams& params) {
        av_hwdevice_ctx_create(&hwDeviceCtx_, AV_HWDEVICE_TYPE_VAAPI,
                               nullptr, nullptr, 0);
        
        const AVCodec* encoder = avcodec_find_encoder_by_name("h264_vaapi");
        // ...
    }
};
```

## 구현 순서

1. **Week 5**: HWEncoder 인터페이스 및 NVENC 구현
2. **테스트**: 전체 파이프라인 성능 측정, 제로카피 확인

## 호환성 요구사항

- v4.1 GPU 필터와 통합 (GPU 메모리 공유)
- HW 인코더 지원되지 않는 경우 SW 인코더 폴백
- 기존 출력 포맷 유지
- WebGL/WebAudio와의 호환성 유지

## 성공 지표

- [ ] 전체 파이프라인 15배 이상 성능 향상
- [ ] GPU 메모리에서 완전 제로카피 인코딩
- [ ] NVENC/VideoToolbox 플랫폼 지원
- [ ] 기존 v3.x/v4.x 기능 유지

---

*Generated: 2025년 12월 6일*  
*For Claude AI Implementation*