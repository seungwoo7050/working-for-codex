# CLAUDE.md - cpp-pvp-server v2.1 안티 치트 시스템

> AI 코딩 에이전트를 위한 프로젝트 컨텍스트 가이드 (안티 치트 전문성 추가)

## 프로젝트 개요

### 선행 조건
- v2.0.0 분산 서버 아키텍처 완료

### 현재 상태 (v2.0.0)
- 분산 서버 구축
- 서버 간 통신 가능

### 목표 상태 (v2.1.0)
- 서버 권위 모델 강화
- 이상 행동 탐지 및 밴 시스템

## 버전 로드맵 (v2.1 세부화)

| 버전 | 기간 | 설명 |
|------|------|------|
| v2.1.0 | 2주 | 서버 권위적 히트 검증 |
| v2.1.1 | 2주 | 이동 속도 및 월핵 탐지 |
| v2.1.2 | 2주 | 이상 행동 통계 탐지 |
| v2.1.3 | 2주 | 리플레이 시스템 |
| v2.1.4 | 2주 | 밴 시스템 |

---

## v2.1.0: 서버 권위적 히트 검증

### 작업 내용
| 순서 | 작업 | 핵심 요구사항 |
|------|------|---------------|
| 2.1.0.1 | HitValidator 인터페이스 정의 | 히트 요청 검증 구조 |
| 2.1.0.2 | RaycastSystem 구현 | 레이캐스팅 기반 히트 계산 |
| 2.1.0.3 | WorldStateBuffer 구현 | 지연 보상용 과거 상태 저장 |
| 2.1.0.4 | 히트 검증 통합 | 기존 전투 시스템에 적용 |

### 구현 세부 사항
- 클라이언트 히트 주장 대신 서버 측 레이캐스팅 검증
- 지연 보상을 위한 과거 월드 상태 버퍼링
- AABB 및 히트박스 충돌 감지

---

## v2.1.1: 이동 속도 및 월핵 탐지

### 작업 내용
| 순서 | 작업 | 핵심 요구사항 |
|------|------|---------------|
| 2.1.1.1 | MovementValidator 구현 | 이동 속도 검증 |
| 2.1.1.2 | 텔레포트 탐지 | 순간 이동 감지 |
| 2.1.1.3 | 월핵 탐지 | 벽 통과 이동 감지 |
| 2.1.1.4 | 이동 검증 통합 | 게임 루프에 적용 |

### 구현 세부 사항
- 최대 허용 속도 기반 이동 검증
- 이동 경로의 장애물 체크
- 네트워크 지터 고려 오차 허용

---

## v2.1.2: 이상 행동 통계 탐지

### 작업 내용
| 순서 | 작업 | 핵심 요구사항 |
|------|------|---------------|
| 2.1.2.1 | CombatStats 수집 | 명중률, 헤드샷 비율 등 통계 |
| 2.1.2.2 | AnomalyDetector 구현 | Z-score 기반 이상치 탐지 |
| 2.1.2.3 | SuspicionSystem 구현 | 의심 레벨 관리 |
| 2.1.2.4 | 통계 분석 통합 | 비동기 처리 |

### 구현 세부 사항
- 플레이어 행동 패턴 분석
- 글로벌 통계와 비교한 이상치 검출
- 누적 의심 점수 기반 레벨링

---

## v2.1.3: 리플레이 시스템

### 작업 내용
| 순서 | 작업 | 핵심 요구사항 |
|------|------|---------------|
| 2.1.3.1 | ReplayRecorder 구현 | 게임 상태 프레임 녹화 |
| 2.1.3.2 | ReplayStorage 구현 | 압축 저장 및 로드 |
| 2.1.3.3 | 리플레이 뷰어 API | HTTP API로 리플레이 조회 |
| 2.1.3.4 | 의심 플레이어 자동 저장 | HIGH 레벨 이상 시 녹화 |

### 구현 세부 사항
- 프레임 단위 게임 상태 저장
- 압축을 통한 저장 효율화
- 특정 플레이어 시점 필터링

---

## v2.1.4: 밴 시스템

### 작업 내용
| 순서 | 작업 | 핵심 요구사항 |
|------|------|---------------|
| 2.1.4.1 | BanPolicy 정의 | 경고 및 밴 기간 정책 |
| 2.1.4.2 | BanService 구현 | 밴 관리 및 조회 |
| 2.1.4.3 | 밴 우회 방지 | 하드웨어 ID 및 IP 범위 밴 |
| 2.1.4.4 | 밴 시스템 통합 | 의심 레벨에 따른 자동 액션 |

### 구현 세부 사항
- 단계적 밴 정책 (경고 → 임시밴 → 영구밴)
- Redis 기반 밴 정보 저장
- 밴 이력 조회 및 항소 지원
        Vec3 hitPoint;
        float damage;
        std::string rejectReason;  // 거부 시 사유
    };

    // 서버 측 히트 검증
    HitResult validateHit(const HitRequest& request);

private:
    // 레이캐스팅으로 실제 히트 계산
    std::optional<RaycastHit> raycast(
        const Vec3& origin, 
        const Vec3& direction, 
        float maxDistance
    );

    // 지연 보상 (Lag Compensation)
    WorldState getWorldStateAt(Timestamp time);
};
```

#### 1.3 레이캐스팅 구현
```cpp
// Raycast.hpp
struct RaycastHit {
    PlayerId hitEntity;
    Vec3 hitPoint;
    Vec3 hitNormal;
    float distance;
    HitboxType hitbox;  // HEAD, BODY, LIMB
};

class RaycastSystem {
public:
    // 월드의 모든 엔티티에 대해 레이캐스트
    std::optional<RaycastHit> cast(
        const Vec3& origin,
        const Vec3& direction,
        float maxDistance,
        const std::vector<PlayerId>& ignoreList
    );

private:
    // AABB (Axis-Aligned Bounding Box) 충돌 체크
    bool intersectAABB(const Ray& ray, const AABB& box, float& t);
    
    // 상세 히트박스 체크 (캡슐, 구 등)
    bool intersectHitbox(const Ray& ray, const Hitbox& hitbox, float& t);
};
```

#### 1.4 지연 보상 (Lag Compensation)
```
문제: 
- 클라이언트 A가 t=0에서 쏨
- 네트워크 지연 100ms
- 서버가 t=100ms에 요청 받음
- 이때 적 B는 이미 다른 위치에 있음

해결:
- 서버가 과거 월드 상태를 저장 (최근 1초)
- 클라이언트 타임스탬프 기준으로 과거 상태에서 검증
```

```cpp
// WorldStateBuffer.hpp
class WorldStateBuffer {
public:
    static constexpr int BUFFER_SIZE = 64;  // 60 TPS 기준 약 1초

    void saveState(const WorldState& state);
    
    // 특정 시간의 월드 상태 조회 (보간 포함)
    WorldState getStateAt(Timestamp time);

private:
    std::array<WorldState, BUFFER_SIZE> buffer_;
    int head_ = 0;
};
```

### Phase 2: 이동 속도 체크 (Week 2)

#### 2.1 속도핵 탐지
```cpp
// MovementValidator.hpp
class MovementValidator {
public:
    struct MovementCheck {
        bool valid;
        float actualSpeed;
        float maxAllowedSpeed;
        std::string violation;
    };

    MovementCheck validateMovement(
        PlayerId player,
        const Vec3& oldPos,
        const Vec3& newPos,
        float deltaTime
    );

private:
    static constexpr float BASE_SPEED = 5.0f;      // 기본 이동 속도
    static constexpr float SPRINT_MULTIPLIER = 1.5f;
    static constexpr float TOLERANCE = 1.1f;       // 10% 오차 허용 (네트워크 지터)

    // 현재 플레이어 상태 (스프린트, 슬로우 등)
    std::unordered_map<PlayerId, PlayerMovementState> states_;
};
```

#### 2.2 텔레포트 탐지
```cpp
// 순간이동 탐지
bool detectTeleport(
    const Vec3& oldPos, 
    const Vec3& newPos, 
    float deltaTime
) {
    float distance = (newPos - oldPos).length();
    float maxPossible = MAX_SPEED * deltaTime * TOLERANCE;
    
    if (distance > maxPossible * 3.0f) {  // 3배 이상이면 명백한 텔레포트
        return true;
    }
    return false;
}
```

#### 2.3 월핵 탐지 (기초)
```cpp
// 벽 통과 탐지
bool detectWallClip(
    const Vec3& oldPos,
    const Vec3& newPos
) {
    // 이동 경로에 벽이 있는지 체크
    return raycastStatic(oldPos, newPos).hasObstacle;
}
```

### Phase 3: 이상 행동 통계 탐지 (Week 3)

#### 3.1 통계 수집
```cpp
// PlayerStats.hpp
struct CombatStats {
    // 명중률
    int totalShots = 0;
    int hits = 0;
    float accuracy() const { return (float)hits / totalShots; }

    // 헤드샷 비율
    int headshots = 0;
    float headshotRatio() const { return (float)headshots / hits; }

    // 반응 시간 (적 발견 → 사격)
    std::vector<float> reactionTimes;
    float avgReactionTime() const;

    // 연속 킬
    int maxKillStreak = 0;

    // 시간대별 성적 (피로도 체크)
    std::map<int, SessionStats> hourlyStats;
};
```

#### 3.2 이상치 탐지
```cpp
// AnomalyDetector.hpp
class AnomalyDetector {
public:
    struct AnomalyScore {
        float accuracy;      // 0.0 ~ 1.0 (1.0 = 매우 의심)
        float headshot;      // 0.0 ~ 1.0
        float reaction;      // 0.0 ~ 1.0
        float consistency;   // 0.0 ~ 1.0 (너무 일정하면 봇 의심)
        
        float combined() const {
            return accuracy * 0.3f + headshot * 0.3f + 
                   reaction * 0.2f + consistency * 0.2f;
        }
    };

    AnomalyScore analyze(const CombatStats& stats);

private:
    // 전체 플레이어 통계 (기준선)
    GlobalStats globalStats_;

    // Z-score 계산
    float calculateZScore(float value, float mean, float stddev);

    // 임계값 (예: Z-score > 3 이면 의심)
    static constexpr float SUSPICION_THRESHOLD = 3.0f;
};
```

#### 3.3 의심 레벨 시스템
```cpp
// SuspicionSystem.hpp
enum class SuspicionLevel {
    NONE = 0,       // 정상
    LOW = 1,        // 관찰 대상
    MEDIUM = 2,     // 상세 로깅 시작
    HIGH = 3,       // 리플레이 저장
    CRITICAL = 4    // 즉시 검토 필요
};

class SuspicionSystem {
public:
    void updateSuspicion(PlayerId player, const AnomalyScore& score);
    SuspicionLevel getLevel(PlayerId player) const;
    
    // 의심 레벨에 따른 액션
    void onSuspicionChanged(PlayerId player, SuspicionLevel newLevel);

private:
    std::unordered_map<PlayerId, float> suspicionScores_;  // 누적 점수
    
    // 레벨별 임계값
    static constexpr float THRESHOLD_LOW = 10.0f;
    static constexpr float THRESHOLD_MEDIUM = 30.0f;
    static constexpr float THRESHOLD_HIGH = 60.0f;
    static constexpr float THRESHOLD_CRITICAL = 90.0f;
};
```

### Phase 4: 리플레이 시스템 (Week 4)

#### 4.1 게임 상태 녹화
```cpp
// ReplayRecorder.hpp
class ReplayRecorder {
public:
    struct ReplayFrame {
        Timestamp timestamp;
        std::vector<EntityState> entities;
        std::vector<GameEvent> events;
    };

    void startRecording(MatchId match);
    void recordFrame(const WorldState& state);
    void stopRecording();

    // 의심 플레이어가 있으면 저장
    void markForSave(PlayerId suspiciousPlayer);

private:
    std::vector<ReplayFrame> frames_;
    bool shouldSave_ = false;
};
```

#### 4.2 리플레이 저장
```cpp
// ReplayStorage.hpp
class ReplayStorage {
public:
    struct ReplayMetadata {
        MatchId matchId;
        Timestamp startTime;
        Timestamp endTime;
        std::vector<PlayerId> players;
        PlayerId suspiciousPlayer;
        SuspicionLevel suspicionLevel;
        std::string reason;
    };

    void saveReplay(
        const ReplayMetadata& metadata,
        const std::vector<ReplayFrame>& frames
    );

    std::optional<Replay> loadReplay(MatchId matchId);

private:
    // 압축 저장 (protobuf 또는 flatbuffers)
    std::vector<uint8_t> compress(const std::vector<ReplayFrame>& frames);
};
```

#### 4.3 리플레이 뷰어 API
```cpp
// HTTP API for replay viewing
GET /api/replays/{matchId}
→ 리플레이 메타데이터

GET /api/replays/{matchId}/frames?start=0&end=1000
→ 프레임 데이터 (청크 단위)

GET /api/replays/{matchId}/player/{playerId}/pov
→ 특정 플레이어 시점으로 필터링된 데이터
```

### Phase 5: 밴 시스템

#### 5.1 밴 정책
```cpp
// BanPolicy.hpp
struct BanPolicy {
    // 경고 단계
    static constexpr int WARN_BEFORE_BAN = 3;
    
    // 밴 기간 (시간)
    static constexpr int TEMP_BAN_1ST = 24;       // 1일
    static constexpr int TEMP_BAN_2ND = 24 * 7;   // 7일
    static constexpr int TEMP_BAN_3RD = 24 * 30;  // 30일
    // 4번째 이후: 영구 밴

    // 밴 우회 방지
    bool shouldBanHardwareId;
    bool shouldBanIpRange;
};
```

#### 5.2 밴 서비스
```cpp
// BanService.hpp
class BanService {
public:
    void warn(PlayerId player, const std::string& reason);
    void tempBan(PlayerId player, int hours, const std::string& reason);
    void permaBan(PlayerId player, const std::string& reason);
    
    bool isBanned(PlayerId player) const;
    bool isBanned(const std::string& hardwareId) const;
    bool isBanned(const IpAddress& ip) const;
    
    // 밴 이력 조회
    std::vector<BanRecord> getBanHistory(PlayerId player) const;

private:
    // Redis에 밴 정보 저장
    RedisClient& redis_;
};
```

## 파일 구조

```
src/
├── anticheat/
│   ├── HitValidator.cpp/hpp
│   ├── MovementValidator.cpp/hpp
│   ├── AnomalyDetector.cpp/hpp
│   ├── SuspicionSystem.cpp/hpp
│   └── BanService.cpp/hpp
├── combat/
│   ├── Raycast.cpp/hpp
│   └── WorldStateBuffer.cpp/hpp
├── replay/
│   ├── ReplayRecorder.cpp/hpp
│   ├── ReplayStorage.cpp/hpp
│   └── ReplayFrame.hpp
└── ...
```

## 테스트 전략

### 단위 테스트
- 레이캐스팅 정확성
- Z-score 계산 정확성
- 밴 정책 로직

### 통합 테스트
- 치트 시나리오 시뮬레이션
  - 속도핵: 2배 속도 이동
  - 에임봇: 100% 명중률
  - 월핵: 벽 통과 이동
- 리플레이 녹화/재생

### 수동 테스트
- 실제 치트 툴로 테스트 (격리 환경)

## 성능 요구사항

- 히트 검증: < 0.5ms per shot
- 이상 탐지: 비동기 처리 (게임 루프 영향 없음)
- 리플레이 저장: 백그라운드 스레드

## 윤리적 고려사항

### False Positive 최소화
- 자동 밴 없음 (사람 검토 필수)
- 의심 레벨 HIGH 이상만 검토 대상
- 항소 시스템 (리플레이로 증거 제시)

### 개인정보
- 하드웨어 ID: 해시 처리 후 저장
- IP: 범위 단위로만 저장 (마지막 옥텟 마스킹)
- 리플레이: 30일 후 자동 삭제 (법적 요청 제외)