# CLAUDE.md - native-video-editor v4.0 GPU 가속 (하드웨어 디코더 통합)

> 이 문서는 Claude AI 코딩 에이전트가 프로젝트 컨텍스트를 이해하기 위한 가이드입니다.

## 프로젝트 개요

### 현재 상태 (v3.2.0)
- **위치**: `/native-video-editor/`
- **기술 스택**: Node.js + C++ Native Addon (N-API), WebGL/WebAudio 추가
- **FFmpeg**: C API 직접 사용 (libavformat, libavcodec, libavutil, libswscale)
- **완성된 기능**: 썸네일 추출, 메타데이터 분석, 트림/스플릿, 자막/속도 조절, RAII 메모리 관리, WebGL 필터 미리보기, WebAudio 파형 시각화

### 목표 상태 (v4.0.0)
- **목표**: CPU 기반 디코딩을 GPU 하드웨어 가속으로 전환
- **핵심 변경**: 플랫폼별 하드웨어 디코더 통합 (NVDEC, VideoToolbox 등)
- **성능 향상**: 디코딩 속도 5-10배 향상, CPU 사용량 감소

## 아키텍처

### 현재 (v3.x - CPU 기반)
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Input     │────▶│  libavcodec │────▶│   Output    │
│   Video     │     │   (CPU)     │     │   Video     │
└─────────────┘     └─────────────┘     └─────────────┘
                          │
                    CPU 연산 100%
```

### 목표 (v4.0 - HW 디코더)
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Input     │────▶│ HW Decoder  │────▶│   Output    │
│   Video     │     │ (NVDEC/VT)  │     │   Video     │
└─────────────┘     └─────────────┘     └─────────────┘
                          │
                       GPU 메모리 유지
```

## 구현할 기능

### Phase 1: 하드웨어 디코더 통합 (Week 1-2)

#### 1.1 플랫폼별 하드웨어 가속
```
NVIDIA (Linux/Windows):
- NVDEC: 하드웨어 디코딩
- 지원 코덱: H.264, HEVC, VP9, AV1

macOS:
- VideoToolbox: 디코딩/인코딩
- 지원 코덱: H.264, HEVC, ProRes

Linux (Intel/AMD):
- VAAPI: 하드웨어 가속
- 지원 코덱: H.264, HEVC, VP9

Windows:
- DXVA2/D3D11: 하드웨어 가속
- 지원 코덱: H.264, HEVC, VP9
```

#### 1.2 하드웨어 디코더 래퍼
```cpp
// HWDecoder.hpp
class HWDecoder {
public:
    enum class Backend {
        NVDEC,       // NVIDIA
        VIDEOTOOLBOX, // macOS
        VAAPI,       // Linux (Intel/AMD)
        DXVA2,       // Windows
        SOFTWARE     // 폴백
    };

    static std::unique_ptr<HWDecoder> create(Backend preferred = Backend::NVDEC);

    // 디코딩된 프레임을 GPU 메모리에 유지
    struct DecodedFrame {
        void* gpuBuffer;      // GPU 메모리 포인터
        int width, height;
        AVPixelFormat format;
        int64_t pts;
    };

    virtual bool open(const std::string& inputPath) = 0;
    virtual std::optional<DecodedFrame> decode() = 0;
    virtual void close() = 0;

protected:
    AVFormatContext* formatCtx_ = nullptr;
    AVCodecContext* codecCtx_ = nullptr;
    AVBufferRef* hwDeviceCtx_ = nullptr;
};
```

#### 1.3 NVDEC 구현 (NVIDIA)
```cpp
// NVDECDecoder.cpp
class NVDECDecoder : public HWDecoder {
public:
    bool open(const std::string& inputPath) override {
        // 1. 입력 파일 열기
        avformat_open_input(&formatCtx_, inputPath.c_str(), nullptr, nullptr);
        
        // 2. CUDA 디바이스 컨텍스트 생성
        av_hwdevice_ctx_create(&hwDeviceCtx_, AV_HWDEVICE_TYPE_CUDA, 
                               nullptr, nullptr, 0);
        
        // 3. 하드웨어 가속 디코더 찾기
        const AVCodec* decoder = avcodec_find_decoder_by_name("h264_cuvid");
        // 또는 hevc_cuvid, vp9_cuvid 등
        
        // 4. 디코더 컨텍스트에 하드웨어 컨텍스트 연결
        codecCtx_->hw_device_ctx = av_buffer_ref(hwDeviceCtx_);
        codecCtx_->get_format = get_hw_format;  // NV12 또는 P010 선택
        
        return true;
    }

    std::optional<DecodedFrame> decode() override {
        AVFrame* frame = av_frame_alloc();
        
        // 디코딩 (결과는 GPU 메모리에)
        int ret = avcodec_receive_frame(codecCtx_, frame);
        
        if (ret == 0) {
            // frame->data[0]은 GPU 메모리 (CUdeviceptr)
            return DecodedFrame{
                .gpuBuffer = frame->data[0],
                .width = frame->width,
                .height = frame->height,
                .format = (AVPixelFormat)frame->format,
                .pts = frame->pts
            };
        }
        
        return std::nullopt;
    }
};
```

#### 1.4 VideoToolbox 구현 (macOS)
```cpp
// VideoToolboxDecoder.cpp
class VideoToolboxDecoder : public HWDecoder {
public:
    bool open(const std::string& inputPath) override {
        av_hwdevice_ctx_create(&hwDeviceCtx_, AV_HWDEVICE_TYPE_VIDEOTOOLBOX,
                               nullptr, nullptr, 0);
        
        const AVCodec* decoder = avcodec_find_decoder_by_name("h264_videotoolbox");
        // ...
    }
    
    // VideoToolbox는 CVPixelBufferRef로 프레임 반환
    // Metal 텍스처로 변환하여 GPU 처리 가능
};
```

#### 1.5 VAAPI 구현 (Linux)
```cpp
// VAAPIDecoder.cpp
class VAAPIDecoder : public HWDecoder {
public:
    bool open(const std::string& inputPath) override {
        av_hwdevice_ctx_create(&hwDeviceCtx_, AV_HWDEVICE_TYPE_VAAPI,
                               nullptr, nullptr, 0);
        
        const AVCodec* decoder = avcodec_find_decoder_by_name("h264_vaapi");
        // ...
    }
};
```

#### 1.6 DXVA2 구현 (Windows)
```cpp
// DXVA2Decoder.cpp
class DXVA2Decoder : public HWDecoder {
public:
    bool open(const std::string& inputPath) override {
        av_hwdevice_ctx_create(&hwDeviceCtx_, AV_HWDEVICE_TYPE_DXVA2,
                               nullptr, nullptr, 0);
        
        const AVCodec* decoder = avcodec_find_decoder_by_name("h264_dxva2");
        // ...
    }
};
```

## 구현 순서

1. **Week 1**: HWDecoder 인터페이스 및 NVDEC 구현
2. **Week 2**: VideoToolbox, VAAPI, DXVA2 구현 및 통합
3. **테스트**: 각 플랫폼에서 디코딩 성능 측정, 폴백 동작 확인

## 호환성 요구사항

- 기존 v3.x 코드 수정 금지
- HW 디코더를 옵션으로 추가 (활성화 시 GPU 사용)
- 지원되지 않는 플랫폼에서는 기존 CPU 디코딩 유지
- 메모리 관리: GPU 메모리 누수 방지

## 성공 지표

- [ ] NVDEC/VAAPI에서 5배 이상 성능 향상
- [ ] VideoToolbox에서 3배 이상 성능 향상
- [ ] 모든 플랫폼에서 폴백 동작
- [ ] 기존 기능 유지 (WebGL/WebAudio 호환)

---

*Generated: 2025년 12월 6일*  
*For Claude AI Implementation*