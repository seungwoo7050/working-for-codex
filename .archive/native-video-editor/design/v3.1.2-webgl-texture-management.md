# WebGL 텍스처 관리 설계 일지 (v3.1.2)
> Phase 3.1 - GPU 텍스처 파이프라인

## 1. 문제 정의 & 요구사항

### 1.1 핵심 목표

**v3.1.2 - WebGL Texture Management**:
- **비디오 텍스처**: HTML5 Video → WebGL 텍스처 변환
- **텍스처 필터링**: LINEAR, NEAREST 샘플링 모드
- **Mipmap 생성**: LOD(Level of Detail) 지원
- **텍스처 압축**: 메모리 최적화

---

## 2. 패치별 상세 설계

### 3.1.2.1: 비디오 텍스처 로딩

**파일**: `frontend/src/webgl/VideoTexture.ts`

```typescript
class VideoTexture {
  private gl: WebGL2RenderingContext;
  private texture: WebGLTexture;
  private video: HTMLVideoElement;
  private needsUpdate = true;  // 업데이트 필요 플래그
  private isDisposed = false;
  
  constructor(gl: WebGL2RenderingContext, video: HTMLVideoElement) {
    this.gl = gl;
    this.video = video;
    this.texture = this.createTexture();
    
    // 비디오 상태 변경 시 업데이트 플래그 설정
    this.video.addEventListener('playing', this.markForUpdate);
    this.video.addEventListener('seeked', this.markForUpdate);
  }
  
  private markForUpdate = (): void => {
    this.needsUpdate = true;
  };
  
  update(): boolean {
    if (this.isDisposed) return false;
    
    if (this.video.readyState < HTMLMediaElement.HAVE_CURRENT_DATA) {
      return false;
    }
    
    if (!this.needsUpdate && this.video.paused) {
      return false;
    }
    
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    this.gl.texImage2D(
      this.gl.TEXTURE_2D,
      0,
      this.gl.RGBA,
      this.gl.RGBA,
      this.gl.UNSIGNED_BYTE,
      this.video
    );
    
    this.needsUpdate = false;
    return true;
  }
  
  bind(unit: number): void {
    this.gl.activeTexture(this.gl.TEXTURE0 + unit);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
  }
}
```

---

### 3.1.2.2: 텍스처 필터링

**파일**: `frontend/src/webgl/TextureFilter.ts`

```typescript
type FilterMode = 'linear' | 'nearest' | 'mipmap';
type WrapMode = 'repeat' | 'clamp' | 'mirror';

interface TextureFilterOptions {
  minFilter: FilterMode;
  magFilter: Exclude<FilterMode, 'mipmap'>;
  wrapS: WrapMode;
  wrapT: WrapMode;
  anisotropy?: number;
}

class TextureFilter {
  private gl: WebGL2RenderingContext;
  private maxAnisotropy: number;
  private anisotropyExt: EXT_texture_filter_anisotropic | null;
  
  constructor(gl: WebGL2RenderingContext) {
    this.gl = gl;
    this.anisotropyExt = gl.getExtension('EXT_texture_filter_anisotropic');
    this.maxAnisotropy = this.anisotropyExt
      ? gl.getParameter(this.anisotropyExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
      : 1;
  }
  
  apply(texture: WebGLTexture, options: Partial<TextureFilterOptions> = {}): void {
    const {
      minFilter = 'linear',
      magFilter = 'linear',
      wrapS = 'clamp',
      wrapT = 'clamp',
      anisotropy = 1,
    } = options;
    
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    
    this.gl.texParameteri(
      this.gl.TEXTURE_2D,
      this.gl.TEXTURE_MIN_FILTER,
      this.getGLMinFilter(minFilter)
    );
    
    this.gl.texParameteri(
      this.gl.TEXTURE_2D,
      this.gl.TEXTURE_MAG_FILTER,
      this.getGLMagFilter(magFilter)
    );
    
    // Anisotropic filtering
    if (this.anisotropyExt && anisotropy > 1) {
      const level = Math.min(anisotropy, this.maxAnisotropy);
      this.gl.texParameterf(
        this.gl.TEXTURE_2D,
        this.anisotropyExt.TEXTURE_MAX_ANISOTROPY_EXT,
        level
      );
    }
  }
  
  applyLinear(texture: WebGLTexture): void {
    this.apply(texture, { minFilter: 'linear', magFilter: 'linear' });
  }
  
  applyNearest(texture: WebGLTexture): void {
    this.apply(texture, { minFilter: 'nearest', magFilter: 'nearest' });
  }
  
  applyMipmap(texture: WebGLTexture): void {
    this.apply(texture, { minFilter: 'mipmap', magFilter: 'linear' });
  }
}
```

---

### 3.1.2.3: Mipmap 생성

**파일**: `frontend/src/webgl/MipmapGenerator.ts`

```typescript
class MipmapGenerator {
  private gl: WebGL2RenderingContext;
  
  constructor(gl: WebGL2RenderingContext) {
    this.gl = gl;
  }
  
  generate(texture: WebGLTexture): void {
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    this.gl.generateMipmap(this.gl.TEXTURE_2D);
  }
  
  generateForCubemap(texture: WebGLTexture): void {
    this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, texture);
    this.gl.generateMipmap(this.gl.TEXTURE_CUBE_MAP);
  }
  
  isPowerOfTwo(width: number, height: number): boolean {
    return this.isPOT(width) && this.isPOT(height);
  }
  
  private isPOT(value: number): boolean {
    return value > 0 && (value & (value - 1)) === 0;
  }
  
  nextPowerOfTwo(value: number): number {
    if (this.isPOT(value)) return value;
    let pot = 1;
    while (pot < value) pot *= 2;
    return pot;
  }
  
  calculateMipLevels(width: number, height: number): number {
    return Math.floor(Math.log2(Math.max(width, height))) + 1;
  }
}
```

---

### 3.1.2.4: 텍스처 압축

**파일**: `frontend/src/webgl/TextureCompressor.ts`

```typescript
interface CompressionInfo {
  supported: boolean;
  formats: string[];
  extensions: string[];
}

class TextureCompressor {
  private gl: WebGL2RenderingContext;
  private s3tcExt: WEBGL_compressed_texture_s3tc | null;
  private etc1Ext: WEBGL_compressed_texture_etc1 | null;
  private astcExt: WEBGL_compressed_texture_astc | null;
  
  constructor(gl: WebGL2RenderingContext) {
    this.gl = gl;
    this.s3tcExt = gl.getExtension('WEBGL_compressed_texture_s3tc');
    this.etc1Ext = gl.getExtension('WEBGL_compressed_texture_etc1');
    this.astcExt = gl.getExtension('WEBGL_compressed_texture_astc');
  }
  
  getCompressionInfo(): CompressionInfo {
    const formats: string[] = [];
    const extensions: string[] = [];
    
    if (this.s3tcExt) {
      extensions.push('WEBGL_compressed_texture_s3tc');
      formats.push('DXT1', 'DXT3', 'DXT5');
    }
    if (this.etc1Ext) {
      extensions.push('WEBGL_compressed_texture_etc1');
      formats.push('ETC1');
    }
    if (this.astcExt) {
      extensions.push('WEBGL_compressed_texture_astc');
      formats.push('ASTC');
    }
    
    return { supported: formats.length > 0, formats, extensions };
  }
  
  isS3TCSupported(): boolean { return this.s3tcExt !== null; }
  isETC1Supported(): boolean { return this.etc1Ext !== null; }
  isASTCSupported(): boolean { return this.astcExt !== null; }
  
  loadCompressed(
    texture: WebGLTexture,
    width: number,
    height: number,
    format: number,
    data: ArrayBufferView
  ): void {
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    this.gl.compressedTexImage2D(
      this.gl.TEXTURE_2D, 0, format, width, height, 0, data
    );
  }
}
```

---

## 3. 완료 기준

- [ ] 비디오 프레임을 텍스처로 변환
- [ ] 필터링 모드 (LINEAR, NEAREST) 동작
- [ ] Mipmap 자동 생성
- [ ] 압축 텍스처 지원 확인

---

## 4. 다음 단계

→ v3.1.3: WebGL 렌더링 파이프라인
