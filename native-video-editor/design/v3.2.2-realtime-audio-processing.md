# 실시간 오디오 프로세싱 설계 일지 (v3.2.2)
> Phase 3.2 - 고성능 오디오 처리

## 1. 문제 정의 & 요구사항

### 1.1 핵심 목표

**v3.2.2 - Real-time Audio Processing**:
- **ScriptProcessor**: 레거시 방식 오디오 처리
- **AudioWorklet**: 고성능 별도 스레드 처리
- **FFT 분석**: 주파수 도메인 분석
- **실시간 필터링**: 이퀄라이저 등

### 1.2 성능 목표

- 128 샘플 버퍼 지원
- 처리 지연 < 10ms
- 메인 스레드 블로킹 없음

---

## 2. 패치별 상세 설계

### 3.2.2.1: ScriptProcessor 노드

**파일**: `frontend/src/audio/RealtimeProcessor.ts`

```typescript
type ProcessCallback = (inputBuffer: AudioBuffer, outputBuffer: AudioBuffer) => void;

class RealtimeProcessor {
  private context: AudioContext;
  private processor: ScriptProcessorNode;
  private callback: ProcessCallback | null = null;
  
  constructor(context: AudioContext, bufferSize: number = 2048) {
    this.context = context;
    // ScriptProcessor is deprecated but widely supported
    this.processor = context.createScriptProcessor(bufferSize, 2, 2);
    
    this.processor.onaudioprocess = (event) => {
      if (this.callback) {
        this.callback(
          event.inputBuffer as unknown as AudioBuffer,
          event.outputBuffer as unknown as AudioBuffer
        );
      }
    };
  }
  
  setCallback(callback: ProcessCallback): void {
    this.callback = callback;
  }
  
  getNode(): ScriptProcessorNode {
    return this.processor;
  }
  
  // Note: ScriptProcessor is deprecated
  // Use AudioWorklet for new implementations
}
```

---

### 3.2.2.2: AudioWorklet 구현

**파일**: `frontend/src/audio/AudioWorkletProcessor.ts`

```typescript
// 메인 스레드 코드
class AudioWorkletManager {
  private context: AudioContext;
  private worklets: Map<string, AudioWorkletNode> = new Map();
  
  async registerProcessor(name: string, url: string): Promise<void> {
    await this.context.audioWorklet.addModule(url);
  }
  
  createNode(name: string, options?: AudioWorkletNodeOptions): AudioWorkletNode {
    const node = new AudioWorkletNode(this.context, name, options);
    this.worklets.set(name, node);
    return node;
  }
}

// Worklet 스레드 코드 (별도 파일로 저장)
// frontend/src/audio/worklets/gain-processor.js
/*
class GainProcessor extends AudioWorkletProcessor {
  static get parameterDescriptors() {
    return [{
      name: 'gain',
      defaultValue: 1,
      minValue: 0,
      maxValue: 2,
      automationRate: 'k-rate'
    }];
  }
  
  process(inputs, outputs, parameters) {
    const input = inputs[0];
    const output = outputs[0];
    const gain = parameters.gain;
    
    for (let channel = 0; channel < input.length; channel++) {
      const inputChannel = input[channel];
      const outputChannel = output[channel];
      
      for (let i = 0; i < inputChannel.length; i++) {
        outputChannel[i] = inputChannel[i] * (gain.length > 1 ? gain[i] : gain[0]);
      }
    }
    
    return true; // Keep processor alive
  }
}

registerProcessor('gain-processor', GainProcessor);
*/
```

---

### 3.2.2.3: FFT 분석

**파일**: `frontend/src/audio/FFTAnalyzer.ts`

```typescript
interface FFTConfig {
  fftSize: number;
  smoothingTimeConstant: number;
  minDecibels: number;
  maxDecibels: number;
}

class FFTAnalyzer {
  private context: AudioContext;
  private analyser: AnalyserNode;
  private frequencyData: Uint8Array;
  private timeDomainData: Uint8Array;
  
  constructor(context: AudioContext, config?: Partial<FFTConfig>) {
    this.context = context;
    this.analyser = context.createAnalyser();
    
    this.analyser.fftSize = config?.fftSize ?? 2048;
    this.analyser.smoothingTimeConstant = config?.smoothingTimeConstant ?? 0.8;
    this.analyser.minDecibels = config?.minDecibels ?? -100;
    this.analyser.maxDecibels = config?.maxDecibels ?? -30;
    
    this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);
    this.timeDomainData = new Uint8Array(this.analyser.fftSize);
  }
  
  getNode(): AnalyserNode {
    return this.analyser;
  }
  
  getFrequencyData(): Uint8Array {
    this.analyser.getByteFrequencyData(this.frequencyData);
    return this.frequencyData;
  }
  
  getTimeDomainData(): Uint8Array {
    this.analyser.getByteTimeDomainData(this.timeDomainData);
    return this.timeDomainData;
  }
  
  getFrequencyBinCount(): number {
    return this.analyser.frequencyBinCount;
  }
  
  // Get frequency at specific bin
  binToFrequency(bin: number): number {
    return bin * this.context.sampleRate / this.analyser.fftSize;
  }
  
  // Get bin for specific frequency
  frequencyToBin(frequency: number): number {
    return Math.round(frequency * this.analyser.fftSize / this.context.sampleRate);
  }
}
```

---

### 3.2.2.4: 실시간 필터링

**파일**: `frontend/src/audio/RealtimeFilter.ts`

```typescript
type FilterType = 'lowpass' | 'highpass' | 'bandpass' | 'peaking' | 'notch' | 'lowshelf' | 'highshelf';

interface FilterBand {
  type: FilterType;
  frequency: number;
  Q: number;
  gain: number;
}

class RealtimeFilter {
  private context: AudioContext;
  private filters: BiquadFilterNode[] = [];
  
  constructor(context: AudioContext) {
    this.context = context;
  }
  
  createFilter(band: FilterBand): BiquadFilterNode {
    const filter = this.context.createBiquadFilter();
    filter.type = band.type;
    filter.frequency.value = band.frequency;
    filter.Q.value = band.Q;
    filter.gain.value = band.gain;
    
    this.filters.push(filter);
    return filter;
  }
  
  createEqualizer(bands: FilterBand[]): AudioNode {
    const nodes = bands.map(band => this.createFilter(band));
    
    // Chain filters
    for (let i = 0; i < nodes.length - 1; i++) {
      nodes[i].connect(nodes[i + 1]);
    }
    
    return nodes[0]; // Return input node
  }
  
  // 10-band parametric EQ preset
  static createStandardEQ(context: AudioContext): RealtimeFilter {
    const filter = new RealtimeFilter(context);
    const bands: FilterBand[] = [
      { type: 'lowshelf', frequency: 60, Q: 0.7, gain: 0 },
      { type: 'peaking', frequency: 170, Q: 1.4, gain: 0 },
      { type: 'peaking', frequency: 310, Q: 1.4, gain: 0 },
      { type: 'peaking', frequency: 600, Q: 1.4, gain: 0 },
      { type: 'peaking', frequency: 1000, Q: 1.4, gain: 0 },
      { type: 'peaking', frequency: 3000, Q: 1.4, gain: 0 },
      { type: 'peaking', frequency: 6000, Q: 1.4, gain: 0 },
      { type: 'peaking', frequency: 12000, Q: 1.4, gain: 0 },
      { type: 'highshelf', frequency: 14000, Q: 0.7, gain: 0 },
    ];
    
    filter.createEqualizer(bands);
    return filter;
  }
}
```

---

## 3. 완료 기준

- [ ] ScriptProcessor 기본 동작
- [ ] AudioWorklet 고성능 처리
- [ ] FFT 분석 < 10ms
- [ ] 실시간 필터 적용

---

## 4. 다음 단계

→ v3.2.3: 오디오 시각화
