# 오디오 노드 시스템 설계 일지 (v3.2.1)
> Phase 3.2 - AudioNode 그래프 관리

## 1. 문제 정의 & 요구사항

### 1.1 핵심 목표

**v3.2.1 - Audio Node System**:
- **노드 그래프 관리**: 동적 노드 연결/해제
- **커스텀 노드**: 재사용 가능한 오디오 처리 단위
- **노드 연결 시스템**: 유연한 라우팅
- **파라미터 오토메이션**: 시간 기반 파라미터 변경

---

## 2. 패치별 상세 설계

### 3.2.1.1: 노드 그래프 관리

**파일**: `frontend/src/audio/AudioNodeGraph.ts`

```typescript
interface NodeConnection {
  source: AudioNode;
  destination: AudioNode;
  outputIndex?: number;
  inputIndex?: number;
}

class AudioNodeGraph {
  private context: AudioContext;
  private nodes: Set<AudioNode> = new Set();
  private connections: NodeConnection[] = [];
  
  addNode(node: AudioNode): void {
    this.nodes.add(node);
  }
  
  removeNode(node: AudioNode): void {
    // Disconnect all connections involving this node
    this.connections = this.connections.filter(conn => {
      if (conn.source === node || conn.destination === node) {
        conn.source.disconnect(conn.destination);
        return false;
      }
      return true;
    });
    this.nodes.delete(node);
  }
  
  connect(source: AudioNode, destination: AudioNode, outputIndex = 0, inputIndex = 0): void {
    source.connect(destination, outputIndex, inputIndex);
    this.connections.push({ source, destination, outputIndex, inputIndex });
  }
  
  disconnect(source: AudioNode, destination?: AudioNode): void {
    if (destination) {
      source.disconnect(destination);
      this.connections = this.connections.filter(
        conn => !(conn.source === source && conn.destination === destination)
      );
    } else {
      source.disconnect();
      this.connections = this.connections.filter(conn => conn.source !== source);
    }
  }
  
  getConnections(): NodeConnection[] {
    return [...this.connections];
  }
}
```

---

### 3.2.1.2: 커스텀 오디오 노드

**파일**: `frontend/src/audio/CustomAudioNode.ts`

```typescript
abstract class CustomAudioNode {
  protected context: AudioContext;
  protected input: GainNode;
  protected output: GainNode;
  
  constructor(context: AudioContext) {
    this.context = context;
    this.input = context.createGain();
    this.output = context.createGain();
    this.setup();
  }
  
  protected abstract setup(): void;
  
  connect(destination: AudioNode | AudioParam): void {
    if (destination instanceof AudioNode) {
      this.output.connect(destination);
    } else {
      this.output.connect(destination);
    }
  }
  
  disconnect(): void {
    this.output.disconnect();
  }
  
  getInput(): AudioNode {
    return this.input;
  }
  
  getOutput(): AudioNode {
    return this.output;
  }
}

// Example: Simple delay effect
class DelayEffect extends CustomAudioNode {
  private delay: DelayNode;
  private feedback: GainNode;
  private mix: GainNode;
  
  protected setup(): void {
    this.delay = this.context.createDelay(5);
    this.feedback = this.context.createGain();
    this.mix = this.context.createGain();
    
    this.delay.delayTime.value = 0.3;
    this.feedback.gain.value = 0.5;
    this.mix.gain.value = 0.5;
    
    // Dry path
    this.input.connect(this.output);
    
    // Wet path
    this.input.connect(this.delay);
    this.delay.connect(this.mix);
    this.delay.connect(this.feedback);
    this.feedback.connect(this.delay);
    this.mix.connect(this.output);
  }
  
  setDelayTime(time: number): void {
    this.delay.delayTime.value = time;
  }
  
  setFeedback(amount: number): void {
    this.feedback.gain.value = Math.min(0.95, amount);
  }
}
```

---

### 3.2.1.3: 노드 연결 시스템

**파일**: `frontend/src/audio/NodeConnector.ts`

```typescript
type ConnectionPoint = AudioNode | AudioParam | CustomAudioNode;

class NodeConnector {
  private context: AudioContext;
  
  connect(source: ConnectionPoint, destination: ConnectionPoint): void {
    const srcNode = source instanceof CustomAudioNode ? source.getOutput() : source;
    const dstNode = destination instanceof CustomAudioNode ? destination.getInput() : destination;
    
    if (srcNode instanceof AudioNode) {
      if (dstNode instanceof AudioNode) {
        srcNode.connect(dstNode);
      } else if (dstNode instanceof AudioParam) {
        srcNode.connect(dstNode);
      }
    }
  }
  
  createChain(...nodes: ConnectionPoint[]): void {
    for (let i = 0; i < nodes.length - 1; i++) {
      this.connect(nodes[i], nodes[i + 1]);
    }
  }
  
  createParallel(source: ConnectionPoint, destinations: ConnectionPoint[], merger?: ChannelMergerNode): void {
    destinations.forEach(dest => this.connect(source, dest));
  }
}
```

---

### 3.2.1.4: 노드 파라미터 바인딩

**파일**: `frontend/src/audio/NodeParameter.ts`

```typescript
interface AutomationEvent {
  time: number;
  value: number;
  type: 'set' | 'linear' | 'exponential';
}

class NodeParameter {
  private param: AudioParam;
  private context: AudioContext;
  
  constructor(param: AudioParam, context: AudioContext) {
    this.param = param;
    this.context = context;
  }
  
  setValue(value: number): void {
    this.param.value = value;
  }
  
  setValueAtTime(value: number, time: number): void {
    this.param.setValueAtTime(value, time);
  }
  
  linearRampTo(value: number, endTime: number): void {
    this.param.linearRampToValueAtTime(value, endTime);
  }
  
  exponentialRampTo(value: number, endTime: number): void {
    if (value <= 0) {
      throw new Error('Exponential ramp requires positive value');
    }
    this.param.exponentialRampToValueAtTime(value, endTime);
  }
  
  scheduleAutomation(events: AutomationEvent[]): void {
    events.forEach(event => {
      const absoluteTime = this.context.currentTime + event.time;
      switch (event.type) {
        case 'set':
          this.param.setValueAtTime(event.value, absoluteTime);
          break;
        case 'linear':
          this.param.linearRampToValueAtTime(event.value, absoluteTime);
          break;
        case 'exponential':
          this.param.exponentialRampToValueAtTime(event.value, absoluteTime);
          break;
      }
    });
  }
  
  cancelScheduled(startTime?: number): void {
    this.param.cancelScheduledValues(startTime ?? this.context.currentTime);
  }
}
```

---

## 3. 완료 기준

- [ ] 노드 그래프 생성/수정/삭제
- [ ] 커스텀 노드 동작
- [ ] 동적 연결/해제
- [ ] 파라미터 오토메이션

---

## 4. 다음 단계

→ v3.2.2: 실시간 오디오 프로세싱
