# 배치, 통계, 캐시, 외부 API 설계 일지 (v1.2.0)
> 운영/성능 패턴(배치 작업, 통계 집계, 캐싱, 외부 API 연동)을 구현한 설계 기록

## 1. 문제 정의 & 요구사항

### 1.1 목표

v1.1.0까지의 CRUD/RBAC 기능 위에 **운영 및 성능 최적화 패턴**을 추가한다:
- 스케줄링 배치 작업으로 일별 통계 집계
- 집계된 통계 데이터 조회 API
- 인기 이슈 캐싱으로 반복 조회 최적화
- 외부 API 호출 (타임아웃, 재시도, Fallback)

작은 범위에서 **배치, 캐싱, 외부 연동** 패턴을 경험한다.

### 1.2 기능 요구사항

#### 1.2.1 일별 통계 배치

**도메인: DailyIssueStats**
- `date`: LocalDate (PK, 집계 날짜)
- `createdCount`: Integer (생성된 이슈 수)
- `resolvedCount`: Integer (해결된 이슈 수)
- `commentCount`: Integer (작성된 댓글 수)
- `createdAt`: LocalDateTime (집계 실행 시각)

**배치 작업:**
- 매일 새벽 3시 자동 실행 (`@Scheduled` cron)
- "어제" 날짜 기준으로 다음 집계:
  - 생성된 이슈 수: `createdAt BETWEEN start AND end`
  - 해결/종료된 이슈 수: `status IN (RESOLVED, CLOSED)` AND `updatedAt BETWEEN ...`
  - 작성된 댓글 수: `createdAt BETWEEN start AND end`
- 동일 날짜 중복 실행 시 Upsert (UPDATE or INSERT)

**API:**
- `GET /api/stats/daily?from=2025-01-01&to=2025-01-31`
  - 날짜 범위 내 통계 목록 반환

#### 1.2.2 인기 이슈 캐싱

**기능:**
- `GET /api/issues/popular`
- 정의: 최근 7일간 `viewCount + commentCount` 기준 상위 10개
- 캐싱:
  - 첫 요청 시 DB 조회 → 계산 → 캐시 저장 (TTL 5분)
  - 이후 요청은 캐시에서 반환
  - TTL 만료 후 다시 DB 조회

**캐시 무효화 전략 (간단 버전):**
- TTL에만 의존 (5분마다 자동 갱신)
- 이슈 수정/삭제 시 캐시 무효화는 선택 사항

#### 1.2.3 외부 API 연동

**기능:**
- `GET /api/external/example`
- 외부 API 호출: JSONPlaceholder (https://jsonplaceholder.typicode.com/posts/1)
- 요구사항:
  - **타임아웃**: 5초 (connect + read/write)
  - **재시도**: 최대 3회, 1초 간격 고정 딜레이
  - **Fallback**: 최종 실패 시 기본 응답 반환
  - **로깅**: 각 재시도 시도 및 최종 실패 로그

### 1.3 비기능 요구사항

#### 1.3.1 배치 안정성
- 예외 발생 시 로그 출력, 다음 실행까지 대기
- 스케줄러 메서드에서 직접 비즈니스 로직 작성 금지 → 서비스 위임

#### 1.3.2 캐싱 성능
- 캐시 히트 시 DB 조회 없이 즉시 응답
- in-memory 캐시 (SimpleCacheManager) 사용
- 프로덕션에서는 Redis 등으로 교체 가능한 구조

#### 1.3.3 외부 API 내결함성
- 네트워크 장애 시에도 애플리케이션 정상 동작
- 타임아웃/재시도 실패 시 Fallback 응답
- 사용자에게 degraded 모드임을 알림

---

## 2. 기술적 배경 & 설계 동기

### 2.1 왜 배치 작업인가?

**실시간 집계의 한계:**
- 대량 데이터에서 GROUP BY/COUNT 쿼리는 비용 높음
- API 요청마다 집계하면 응답 느림
- DB 부하 증가

**배치 집계의 이점:**
- 야간(새벽 3시) 실행 → 트래픽 낮은 시간대 활용
- 집계 결과를 별도 테이블에 저장 → 조회 빠름
- 과거 데이터 추이 분석 용이

**트레이드오프:**
- 실시간성 부족 (최대 1일 지연)
- → 일별 통계는 실시간 필요 없음 (허용 가능)

### 2.2 왜 캐싱인가?

**반복 조회 최적화:**
- 인기 이슈 목록은 자주 요청되지만 자주 변경되지 않음
- 매 요청마다 복잡한 쿼리(viewCount + commentCount 정렬) 실행 비효율

**캐시 적용 효과:**
- 첫 요청: DB 조회 (느림)
- 이후 5분간: 캐시 반환 (빠름)
- DB 부하 감소

**Spring Cache Abstraction:**
- `@Cacheable` 어노테이션으로 선언적 캐싱
- 백엔드 교체 용이 (in-memory → Redis)

### 2.3 왜 외부 API 재시도/Fallback인가?

**네트워크 불안정성:**
- 일시적 장애 (timeout, connection refused)
- 재시도로 복구 가능한 경우 많음

**Fallback의 필요성:**
- 재시도 실패 시 500 에러보다는 degraded 응답이 나음
- 사용자 경험 개선 (완전 실패보다 부분 기능)

**WebClient의 Reactive 패턴:**
- `Retry.fixedDelay()`: 선언적 재시도
- `onErrorResume()`: Fallback 처리
- 비동기/논블로킹 (선택적)

---

## 3. 배치 & 통계 설계

### 3.1 도메인 설계

#### 3.1.1 DailyIssueStats Entity

```java
@Entity
@Table(name = "daily_issue_stats")
public class DailyIssueStats {

    @Id
    private LocalDate date;  // PK

    @Column(nullable = false)
    private Integer createdCount;

    @Column(nullable = false)
    private Integer resolvedCount;

    @Column(nullable = false)
    private Integer commentCount;

    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }

    protected DailyIssueStats() {}

    public DailyIssueStats(LocalDate date, int createdCount, int resolvedCount, int commentCount) {
        this.date = date;
        this.createdCount = createdCount;
        this.resolvedCount = resolvedCount;
        this.commentCount = commentCount;
    }
}
```

**설계 포인트:**
- **date를 PK로**: 하루에 하나의 레코드만 존재
- **createdAt**: 집계 실행 시각 (디버깅/감사용)
- **Immutable 필드**: 생성 후 수정 불가 (Upsert 제외)

#### 3.1.2 DailyIssueStatsRepository

```java
public interface DailyIssueStatsRepository extends JpaRepository<DailyIssueStats, LocalDate> {

    List<DailyIssueStats> findByDateBetweenOrderByDateAsc(LocalDate from, LocalDate to);
}
```

**쿼리 메서드:**
- `findByDateBetween...`: 날짜 범위 조회
- `OrderByDateAsc`: 날짜 오름차순 정렬

### 3.2 배치 스케줄러 설계

#### 3.2.1 StatsScheduler

**파일:** `stats/scheduler/StatsScheduler.java`

```java
@Component
public class StatsScheduler {

    private static final Logger log = LoggerFactory.getLogger(StatsScheduler.class);

    private final StatsService statsService;

    public StatsScheduler(StatsService statsService) {
        this.statsService = statsService;
    }

    // 매일 새벽 3시 실행
    // 테스트용: "0 */5 * * * *" (5분마다)
    @Scheduled(cron = "0 0 3 * * *")
    public void aggregateDailyStats() {
        try {
            LocalDate yesterday = LocalDate.now().minusDays(1);
            log.info("Starting daily stats aggregation for: {}", yesterday);

            statsService.aggregateDailyStats(yesterday);

            log.info("Completed daily stats aggregation for: {}", yesterday);
        } catch (Exception e) {
            log.error("Error during daily stats aggregation", e);
            // 예외 삼킴, 다음 실행까지 대기
        }
    }
}
```

**설계 포인트:**
- **@Scheduled cron**: Spring의 스케줄링 지원
  - `0 0 3 * * *`: 매일 3시 0분 0초
  - 초 분 시 일 월 요일
- **yesterday 계산**: `LocalDate.now().minusDays(1)`
  - 3시에 실행되므로 "어제" 데이터 집계
- **예외 처리**: try-catch로 감싸서 스케줄러 중단 방지
- **로깅**: 시작/완료/실패 로그로 모니터링

#### 3.2.2 스케줄링 활성화

**Application.java:**
```java
@SpringBootApplication
@EnableScheduling  // 스케줄링 활성화
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### 3.3 StatsService 집계 로직

```java
@Service
@Transactional(readOnly = true)
public class StatsService {

    private final DailyIssueStatsRepository statsRepository;
    private final IssueRepository issueRepository;
    private final CommentRepository commentRepository;

    @Transactional
    public void aggregateDailyStats(LocalDate date) {
        LocalDateTime startOfDay = date.atStartOfDay();
        LocalDateTime endOfDay = date.atTime(23, 59, 59);

        // 1. 생성된 이슈 수
        int createdCount = issueRepository.countByCreatedAtBetween(startOfDay, endOfDay);

        // 2. 해결/종료된 이슈 수
        int resolvedCount = issueRepository.countByStatusInAndUpdatedAtBetween(
            List.of(IssueStatus.RESOLVED, IssueStatus.CLOSED),
            startOfDay,
            endOfDay
        );

        // 3. 작성된 댓글 수
        int commentCount = commentRepository.countByCreatedAtBetween(startOfDay, endOfDay);

        // 4. Upsert (존재하면 UPDATE, 없으면 INSERT)
        DailyIssueStats stats = statsRepository.findById(date)
            .orElse(new DailyIssueStats(date, 0, 0, 0));

        stats.setCreatedCount(createdCount);
        stats.setResolvedCount(resolvedCount);
        stats.setCommentCount(commentCount);

        statsRepository.save(stats);
    }

    public List<DailyStatsResponse> getDailyStats(LocalDate from, LocalDate to) {
        return statsRepository.findByDateBetweenOrderByDateAsc(from, to).stream()
            .map(DailyStatsResponse::from)
            .collect(Collectors.toList());
    }
}
```

**설계 포인트:**
- **날짜 범위 계산**: `atStartOfDay()`, `atTime(23, 59, 59)`
- **Repository 카운트 쿼리**:
  - `countByCreatedAtBetween`: 간단한 조건
  - `countByStatusInAndUpdatedAtBetween`: 복합 조건
- **Upsert 패턴**: `findById` → 존재하면 업데이트, 없으면 새로 생성
- **@Transactional**: 집계와 저장을 하나의 트랜잭션으로

#### 3.3.1 Repository 커스텀 쿼리

**IssueRepository에 추가:**
```java
int countByCreatedAtBetween(LocalDateTime start, LocalDateTime end);

int countByStatusInAndUpdatedAtBetween(List<IssueStatus> statuses,
                                        LocalDateTime start,
                                        LocalDateTime end);
```

**CommentRepository에 추가:**
```java
int countByCreatedAtBetween(LocalDateTime start, LocalDateTime end);
```

---

## 4. 캐싱 설계

### 4.1 Spring Cache 설정

**application.yml:**
```yaml
spring:
  cache:
    type: simple  # in-memory SimpleCacheManager
```

**CacheConfig (선택 사항):**
```java
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        SimpleCacheManager cacheManager = new SimpleCacheManager();
        cacheManager.setCaches(Arrays.asList(
            new ConcurrentMapCache("popularIssues")
        ));
        return cacheManager;
    }
}
```

**설계 포인트:**
- **@EnableCaching**: Spring Cache 활성화
- **SimpleCacheManager**: in-memory, TTL 지원 제한
  - 프로덕션: `RedisCacheManager` 사용 권장
- **캐시 이름**: "popularIssues"

### 4.2 인기 이슈 캐싱 로직

**IssueService에 추가:**
```java
@Cacheable(value = "popularIssues", key = "'top10'")
@Transactional(readOnly = true)
public List<IssueResponse> getPopularIssues() {
    LocalDateTime since = LocalDateTime.now().minusDays(7);

    // 복잡한 쿼리: viewCount + commentCount 합산 정렬
    List<Issue> popularIssues = issueRepository.findPopularIssues(since, PageRequest.of(0, 10));

    return popularIssues.stream()
        .map(IssueResponse::from)
        .collect(Collectors.toList());
}
```

**IssueRepository 쿼리:**
```java
@Query("SELECT i FROM Issue i WHERE i.createdAt >= :since " +
       "ORDER BY (i.viewCount + (SELECT COUNT(c) FROM Comment c WHERE c.issueId = i.id)) DESC")
List<Issue> findPopularIssues(@Param("since") LocalDateTime since, Pageable pageable);
```

**설계 포인트:**
- **@Cacheable**: 메서드 결과를 캐시
  - `value`: 캐시 이름
  - `key`: 캐시 키 (SpEL 표현식, 여기서는 고정 문자열)
- **복잡한 쿼리**: 서브쿼리로 댓글 수 합산
- **Pageable**: 상위 10개만 조회

**캐시 동작:**
1. 첫 요청: `findPopularIssues()` 실행 → DB 조회 → 결과 캐시 저장 → 반환
2. 이후 요청 (5분 내): 캐시에서 반환 (DB 조회 안 함)
3. 5분 후: 캐시 만료 → 다시 DB 조회

**캐시 무효화 (선택):**
```java
@CacheEvict(value = "popularIssues", allEntries = true)
public void someUpdateMethod() {
    // 이슈 수정/삭제 시 캐시 무효화
}
```

---

## 5. 외부 API 연동 설계

### 5.1 WebClient 설정

**WebClientConfig:**
```java
@Configuration
public class WebClientConfig {

    @Bean
    public WebClient webClient() {
        return WebClient.builder()
            .codecs(configurer -> configurer
                .defaultCodecs()
                .maxInMemorySize(1 * 1024 * 1024))  // 1MB
            .build();
    }
}
```

**application.yml (타임아웃 설정):**
```yaml
spring:
  webflux:
    webclient:
      connect-timeout: 5000  # ms
      read-timeout: 5000
      write-timeout: 5000
```

**설계 포인트:**
- `WebClient`: Spring WebFlux의 논블로킹 HTTP 클라이언트
  - `RestTemplate`의 후속 (권장)
- **타임아웃**: 5초 (connect, read, write 각각)
- **maxInMemorySize**: 메모리 버퍼 제한

### 5.2 ExternalApiService

**파일:** `common/service/ExternalApiService.java`

```java
@Service
public class ExternalApiService {

    private static final Logger log = LoggerFactory.getLogger(ExternalApiService.class);
    private static final String EXTERNAL_API_URL = "https://jsonplaceholder.typicode.com/posts/1";

    private final WebClient webClient;

    public ExternalApiService(WebClient webClient) {
        this.webClient = webClient;
    }

    public Map<String, Object> fetchExternalData() {
        log.info("Fetching data from external API: {}", EXTERNAL_API_URL);

        try {
            Map<String, Object> response = webClient.get()
                .uri(EXTERNAL_API_URL)
                .retrieve()
                .bodyToMono(Map.class)
                .retryWhen(Retry.fixedDelay(3, Duration.ofSeconds(1))
                    .doBeforeRetry(retrySignal ->
                        log.warn("Retrying request, attempt: {}", retrySignal.totalRetries() + 1)
                    )
                    .onRetryExhaustedThrow((retryBackoffSpec, retrySignal) -> {
                        log.error("Max retry attempts reached");
                        return new RuntimeException("Max retry attempts reached");
                    })
                )
                .onErrorResume(throwable -> {
                    log.error("Error fetching external data, using fallback", throwable);
                    return Mono.just(getFallbackResponse());
                })
                .block();  // 동기 블로킹 (비동기도 가능)

            log.info("Successfully fetched external data");
            return response;

        } catch (Exception e) {
            log.error("Unexpected error while fetching external data, using fallback", e);
            return getFallbackResponse();
        }
    }

    private Map<String, Object> getFallbackResponse() {
        Map<String, Object> fallback = new HashMap<>();
        fallback.put("status", "fallback");
        fallback.put("message", "External API is currently unavailable. Using cached or default data.");
        fallback.put("userId", 1);
        fallback.put("id", 1);
        fallback.put("title", "Fallback Title");
        fallback.put("body", "Fallback body content");
        return fallback;
    }
}
```

**설계 포인트:**
- **retryWhen()**: Reactor의 재시도 전략
  - `Retry.fixedDelay(3, Duration.ofSeconds(1))`: 3회, 1초 간격
  - `doBeforeRetry()`: 재시도 전 로그
  - `onRetryExhaustedThrow()`: 최대 재시도 초과 시 예외
- **onErrorResume()**: 예외 발생 시 Fallback Mono 반환
- **block()**: Reactive → 동기 변환
  - 비동기 처리도 가능 (`Mono<Map>` 반환)
- **Fallback**: 기본 응답으로 degraded 모드 제공

### 5.3 ExternalApiController

```java
@RestController
@RequestMapping("/api/external")
public class ExternalApiController {

    private final ExternalApiService externalApiService;

    @GetMapping("/example")
    public ResponseEntity<Map<String, Object>> getExternalData() {
        Map<String, Object> data = externalApiService.fetchExternalData();
        return ResponseEntity.ok(data);
    }
}
```

---

## 6. 테스트 전략

### 6.1 배치 작업 테스트

**StatsServiceTest:**
```java
@SpringBootTest
@Transactional
class StatsServiceTest {

    @Autowired
    private StatsService statsService;

    @Autowired
    private IssueRepository issueRepository;

    @Autowired
    private CommentRepository commentRepository;

    @Autowired
    private DailyIssueStatsRepository statsRepository;

    @Test
    void aggregateDailyStats_정상집계() {
        // Given: 어제 날짜에 이슈 3개, 댓글 2개 생성
        LocalDate yesterday = LocalDate.now().minusDays(1);
        LocalDateTime yesterdayTime = yesterday.atTime(12, 0);

        // 이슈 생성 (createdAt 조작)
        Issue issue1 = new Issue(1L, 1L, "Issue 1", "Desc");
        issue1.setCreatedAt(yesterdayTime);
        issueRepository.save(issue1);

        // 댓글 생성
        Comment comment1 = new Comment(issue1.getId(), 1L, "Comment 1");
        comment1.setCreatedAt(yesterdayTime);
        commentRepository.save(comment1);

        // When
        statsService.aggregateDailyStats(yesterday);

        // Then
        DailyIssueStats stats = statsRepository.findById(yesterday).orElseThrow();
        assertThat(stats.getCreatedCount()).isEqualTo(3);
        assertThat(stats.getCommentCount()).isEqualTo(2);
    }

    @Test
    void aggregateDailyStats_Upsert_기존데이터업데이트() {
        LocalDate yesterday = LocalDate.now().minusDays(1);

        // 기존 통계 존재
        DailyIssueStats existing = new DailyIssueStats(yesterday, 1, 0, 0);
        statsRepository.save(existing);

        // 재집계
        statsService.aggregateDailyStats(yesterday);

        // 업데이트 확인
        DailyIssueStats updated = statsRepository.findById(yesterday).orElseThrow();
        assertThat(updated.getCreatedCount()).isGreaterThanOrEqualTo(0);  // 실제 데이터 기준
    }
}
```

**StatsScheduler 테스트:**
```java
@SpringBootTest
class StatsSchedulerTest {

    @Autowired
    private StatsScheduler scheduler;

    @Test
    void aggregateDailyStats_예외발생시_스케줄러중단안됨() {
        // When: 스케줄러 메서드 직접 호출
        assertDoesNotThrow(() -> scheduler.aggregateDailyStats());

        // Then: 예외가 스케줄러 밖으로 전파되지 않음
    }
}
```

### 6.2 캐싱 테스트

**IssueServiceCacheTest:**
```java
@SpringBootTest
@Transactional
class IssueServiceCacheTest {

    @Autowired
    private IssueService issueService;

    @Autowired
    private CacheManager cacheManager;

    @Test
    void getPopularIssues_캐시히트() {
        // 캐시 초기화
        cacheManager.getCache("popularIssues").clear();

        // 첫 호출: DB 조회
        List<IssueResponse> first = issueService.getPopularIssues();

        // 두 번째 호출: 캐시 히트
        List<IssueResponse> second = issueService.getPopularIssues();

        // 결과 동일 (캐시에서 반환)
        assertThat(first).isEqualTo(second);

        // 캐시 확인
        Cache cache = cacheManager.getCache("popularIssues");
        assertThat(cache.get("top10")).isNotNull();
    }
}
```

### 6.3 외부 API 테스트

**ExternalApiServiceTest:**
```java
@SpringBootTest
class ExternalApiServiceTest {

    @Autowired
    private ExternalApiService externalApiService;

    @Test
    void fetchExternalData_성공() {
        // When
        Map<String, Object> data = externalApiService.fetchExternalData();

        // Then
        assertThat(data).isNotNull();
        assertThat(data).containsKey("id");
        // Fallback이면 "status"="fallback" 확인
        if (data.containsKey("status")) {
            assertThat(data.get("status")).isEqualTo("fallback");
        }
    }

    // Mock 서버 사용 시:
    @Test
    void fetchExternalData_타임아웃_Fallback() {
        // MockWebServer로 타임아웃 시뮬레이션
        // ... (복잡하므로 선택 사항)
    }
}
```

---

## 7. 완료 기준 및 검증

### 7.1 로컬 검증

**1. 배치 실행 (수동 트리거):**
```bash
# 스케줄러 메서드를 테스트로 실행하거나, cron을 "*/1 * * * * *"로 설정

# 통계 조회
curl "http://localhost:8080/api/stats/daily?from=2025-01-01&to=2025-01-31" \
  -H "Authorization: Bearer <TOKEN>"

# 응답:
# [{"date":"2025-01-30","createdCount":10,"resolvedCount":5,"commentCount":8}, ...]
```

**2. 캐싱 확인:**
```bash
# 첫 요청 (느림)
time curl http://localhost:8080/api/issues/popular \
  -H "Authorization: Bearer <TOKEN>"

# 두 번째 요청 (빠름, 캐시 히트)
time curl http://localhost:8080/api/issues/popular \
  -H "Authorization: Bearer <TOKEN>"
```

**3. 외부 API:**
```bash
curl http://localhost:8080/api/external/example \
  -H "Authorization: Bearer <TOKEN>"

# 정상 응답 또는 Fallback 확인
```

### 7.2 완료 체크리스트

- [x] DailyIssueStats 엔티티 및 Repository
- [x] StatsScheduler @Scheduled 설정
- [x] StatsService 집계 로직 (Upsert 포함)
- [x] 통계 조회 API (`GET /api/stats/daily`)
- [x] @EnableCaching 및 CacheManager 설정
- [x] @Cacheable로 인기 이슈 캐싱
- [x] WebClient 설정 (타임아웃, 재시도)
- [x] ExternalApiService (Retry, Fallback)
- [x] 배치 작업 서비스 테스트
- [x] 캐싱 동작 테스트
- [x] 외부 API 호출 테스트
- [x] CI 파이프라인에서 모든 테스트 통과

---

## 8. 설계 결정 사항 및 트레이드오프

### 8.1 in-memory 캐시 vs Redis

| 방식 | 장점 | 단점 | 선택 이유 |
|------|------|------|-----------|
| SimpleCacheManager | 설정 간단, 의존성 없음 | 다중 인스턴스 공유 불가, TTL 제한 | **선택**: 학습 목적 |
| Redis | 분산 캐싱, TTL 지원, 확장 용이 | 추가 인프라, 설정 복잡 | 프로덕션 권장 |

### 8.2 배치 스케줄링 방식

**선택: @Scheduled (Spring)**
- **장점**: 간단, 코드 기반 설정
- **단점**: 동적 변경 어려움, 분산 실행 제어 없음
- **대안**: Quartz, Spring Batch (더 복잡, 대규모 배치용)

### 8.3 동기 vs 비동기 외부 API 호출

**선택: 동기 (block())**
- **이유**: 단순 요청/응답 패턴, 학습 목적
- **트레이드오프**: 호출 동안 스레드 블로킹
- **개선**: `Mono<Map>` 반환으로 비동기 처리 가능

---

## 9. 알려진 제약 & 향후 개선점

### 9.1 현재 제약

1. **배치 동시 실행 방지 없음**
   - 스케줄러가 여러 인스턴스에서 동시 실행 가능
   - 개선: ShedLock, Quartz Clustering

2. **캐시 TTL 설정 부족**
   - SimpleCacheManager는 TTL 자동 지원 안 함
   - 개선: Caffeine Cache 또는 Redis 사용

3. **외부 API 서킷 브레이커 없음**
   - 외부 API 지속 실패 시에도 계속 재시도
   - 개선: Resilience4j CircuitBreaker 적용

4. **통계 실시간성 부족**
   - 최대 1일 지연 (새벽 3시 집계)
   - 개선: 실시간 카운터 (Redis INCR) + 배치 백업

### 9.2 다음 마일스톤 (v1.3.0)에서 추가될 것

**도메인:**
- Product (상품 카탈로그)

**패턴:**
- Elasticsearch 전문 검색
- 인덱스 동기화 전략
- 다중 필터 쿼리 (카테고리, 브랜드, 가격 범위)

**테스트:**
- Elasticsearch 통합 테스트 (Testcontainers)
- 검색 쿼리 검증

---

## 10. 결론

v1.2.0에서 확립한 것:
- ✅ 스케줄링 배치 작업 (`@Scheduled`)
- ✅ 일별 통계 집계 및 Upsert 패턴
- ✅ Spring Cache Abstraction
- ✅ WebClient 기반 외부 API 연동
- ✅ 타임아웃, 재시도, Fallback 패턴

**핵심 성과:**
- **운영 패턴** (배치, 캐싱, 외부 연동)을 작은 범위에서 학습
- 이후 대규모 시스템에서 **확장 가능한 기반** 마련
- CI에서 배치/캐시 로직 자동 검증

**다음 단계 (v1.3.0):**
- Elasticsearch 검색 인덱스 구축
- 상품 카탈로그 전문 검색
- RDB와 검색 인덱스 동기화
