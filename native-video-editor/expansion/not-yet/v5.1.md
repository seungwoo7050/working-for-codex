# CLAUDE.md - native-video-editor v5.1 스트리밍 플랫폼 (VOD 시스템)

> AI 코딩 에이전트를 위한 프로젝트 컨텍스트 가이드 (시니어 레벨)

## 프로젝트 개요

### 선행 조건
- v5.0.0 라이브 스트리밍 인프라 완료
- RTMP/WebRTC 인제스트 및 트랜스코딩 가능

### 현재 상태 (v5.0.0)
- 라이브 스트리밍 인프라 구축
- ABR 트랜스코딩 및 HLS/DASH 배포
- 기본 Origin/Edge 서버

### 목표 상태 (v5.1.0)
- **대규모 VOD 시스템 구축**
- 분산 트랜스코딩 클러스터
- 메타데이터 관리 및 검색
- 클라우드 스토리지 통합

## 구현할 기능

### Phase 2: 대규모 VOD 시스템 (Month 3-4)

#### 2.1 분산 트랜스코딩 클러스터
```cpp
// TranscodeCluster.hpp
class TranscodeCluster {
public:
    struct TranscodeJob {
        std::string jobId;
        std::string inputPath;      // S3, GCS, etc.
        std::string outputPath;
        ABRLadder ladder;
        Priority priority;
        std::optional<TimeRange> trimRange;
    };

    // 작업 제출
    std::string submitJob(const TranscodeJob& job);
    
    // 작업 상태
    JobStatus getJobStatus(const std::string& jobId);
    
    // 작업 취소
    void cancelJob(const std::string& jobId);

private:
    // 작업 분할 (Chunking)
    std::vector<ChunkJob> splitIntoChunks(const TranscodeJob& job, int chunkDuration = 10);
    
    // 워커 관리
    std::unique_ptr<WorkerPool> workers_;
    std::unique_ptr<JobQueue> queue_;
    
    // 결과 병합
    void mergeChunks(const std::string& jobId, const std::vector<ChunkResult>& chunks);
};

// 청크 기반 병렬 처리
std::vector<ChunkJob> TranscodeCluster::splitIntoChunks(
    const TranscodeJob& job, 
    int chunkDuration
) {
    auto metadata = probeVideo(job.inputPath);
    int totalDuration = metadata.duration;
    
    std::vector<ChunkJob> chunks;
    for (int start = 0; start < totalDuration; start += chunkDuration) {
        ChunkJob chunk;
        chunk.parentJobId = job.jobId;
        chunk.chunkIndex = start / chunkDuration;
        chunk.inputPath = job.inputPath;
        chunk.startTime = start;
        chunk.duration = std::min(chunkDuration, totalDuration - start);
        chunk.ladder = job.ladder;
        
        chunks.push_back(chunk);
    }
    
    return chunks;
}
```

#### 2.2 메타데이터 관리
```cpp
// VODMetadata.hpp
class VODMetadata {
public:
    struct VideoMetadata {
        std::string videoId;
        std::string title;
        std::string description;
        int duration;
        int width, height;
        std::string codec;
        int64_t fileSize;
        std::vector<std::string> tags;
        std::unordered_map<std::string, std::string> qualities; // 해상도 -> URL
        TimePoint uploadTime;
        std::string uploaderId;
    };

    // 메타데이터 CRUD
    void storeMetadata(const VideoMetadata& metadata);
    std::optional<VideoMetadata> getMetadata(const std::string& videoId);
    void updateMetadata(const std::string& videoId, const VideoMetadata& updates);
    void deleteMetadata(const std::string& videoId);

    // 검색
    std::vector<VideoMetadata> searchByTags(const std::vector<std::string>& tags);
    std::vector<VideoMetadata> searchByUploader(const std::string& uploaderId);
    std::vector<VideoMetadata> searchByTitle(const std::string& query);

private:
    // Elasticsearch 기반 검색
    std::unique_ptr<ElasticsearchClient> searchClient_;
    
    // Redis 캐시
    std::unique_ptr<RedisClient> cache_;
};
```

#### 2.3 클라우드 스토리지 통합
```cpp
// CloudStorage.hpp
class CloudStorage {
public:
    enum class Provider { S3, GCS, Azure };

    struct UploadRequest {
        std::string bucket;
        std::string key;
        std::vector<uint8_t> data;
        std::string contentType;
        bool publicRead = false;
    };

    // 파일 업로드
    std::string uploadFile(const UploadRequest& request);
    
    // 파일 다운로드
    std::optional<std::vector<uint8_t>> downloadFile(
        const std::string& bucket, 
        const std::string& key
    );
    
    // 파일 삭제
    void deleteFile(const std::string& bucket, const std::string& key);
    
    // Presigned URL 생성
    std::string generatePresignedUrl(
        const std::string& bucket,
        const std::string& key,
        int expirySeconds = 3600
    );

private:
    Provider provider_;
    std::unique_ptr<S3Client> s3Client_;
    std::unique_ptr<GCSClient> gcsClient_;
};
```

#### 2.4 VOD API 서버
```cpp
// VODApiServer.hpp
class VODApiServer {
public:
    // 비디오 업로드
    std::string uploadVideo(
        const std::string& uploaderId,
        const std::string& title,
        const std::vector<uint8_t>& videoData
    );

    // 비디오 검색
    std::vector<VideoSummary> searchVideos(const SearchQuery& query);
    
    // 비디오 스트리밍 URL
    std::string getStreamUrl(
        const std::string& videoId,
        const std::string& quality = "auto"
    );

    // 비디오 삭제
    void deleteVideo(const std::string& videoId, const std::string& uploaderId);

private:
    std::unique_ptr<TranscodeCluster> transcodeCluster_;
    std::unique_ptr<VODMetadata> metadata_;
    std::unique_ptr<CloudStorage> storage_;
};
```

## 구현 순서

1. **Month 3**: 분산 트랜스코딩 클러스터 구축
2. **Month 4**: 메타데이터 관리 및 클라우드 스토리지 통합

## 호환성 요구사항

- v5.0 라이브 스트리밍과 통합
- 기존 로컬 편집 기능 유지
- VOD 기능은 옵션 모듈

## 성공 지표

- [ ] 1000개 동시 트랜스코딩 작업 처리
- [ ] Elasticsearch 기반 메타데이터 검색
- [ ] S3/GCS/Azure 스토리지 지원
- [ ] Presigned URL 기반 보안 스트리밍

---

*Generated: 2025년 12월 6일*  
*For Claude AI Implementation*