# UDP 넷코드 코어 설계 (v1.4.0)
> UDP 권위 서버 코어 & 스냅샷/델타 동기화 구현 설계

**상태**: ✅ 완료

## 1. 개요

### 1.1 목표
- WebSocket 기반 통신을 UDP로 전환
- 권위 서버 모델 구현
- 스냅샷/델타 동기화로 대역폭 최적화

### 1.2 배경
기존 v1.3.0은 WebSocket(TCP 기반)으로 통신합니다. 실시간 게임에서 TCP의 신뢰성 보장(재전송, 순서 보장)은 오히려 지연을 유발합니다. UDP를 사용하면:
- 패킷 손실 시 재전송 대기 없음
- 순서 보장 없이 최신 상태만 사용
- 지연 시간(latency) 감소

### 1.3 구현된 컴포넌트
- `UdpSocket`: Boost.Asio 기반 UDP 소켓 래퍼
- `UdpGameServer`: UDP 기반 게임 서버
- `SnapshotManager`: 스냅샷/델타 관리
- `PacketTypes`: 패킷 타입 정의

---

## 2. 패치별 설계

### 2.1 패치 1.4.0-p1: UDP 소켓 래퍼

#### 2.1.1 책임
- Boost.Asio 기반 UDP 소켓 추상화
- 비동기 송수신 인터페이스 제공
- 패킷 직렬화/역직렬화 지원

#### 2.1.2 인터페이스
```cpp
// include/pvpserver/network/udp_socket.h
namespace pvpserver::network {

class UdpSocket {
public:
    using Endpoint = boost::asio::ip::udp::endpoint;
    using ReceiveCallback = std::function<void(
        const std::vector<uint8_t>& data,
        const Endpoint& sender
    )>;

    explicit UdpSocket(boost::asio::io_context& io, uint16_t port);
    ~UdpSocket();

    // 비동기 수신 시작
    void startReceive(ReceiveCallback callback);

    // 특정 엔드포인트로 전송
    void sendTo(const std::vector<uint8_t>& data, const Endpoint& target);

    // 브로드캐스트 (연결된 모든 클라이언트)
    void broadcast(const std::vector<uint8_t>& data);

    // 클라이언트 등록/해제
    void registerClient(const Endpoint& client);
    void unregisterClient(const Endpoint& client);

private:
    boost::asio::ip::udp::socket socket_;
    std::set<Endpoint> clients_;
    std::array<uint8_t, 1500> receiveBuffer_;  // MTU 크기
};

}  // namespace pvpserver::network
```

#### 2.1.3 구현 세부사항
- MTU(Maximum Transmission Unit) 고려: 1500 바이트 이하 패킷
- 수신 버퍼: 비동기 수신을 위한 고정 크기 버퍼
- 클라이언트 관리: 등록된 엔드포인트 집합 유지

#### 2.1.4 테스트 포인트
- 단위 테스트: 송수신 기본 동작
- 통합 테스트: 다중 클라이언트 동시 통신

---

### 2.2 패치 1.4.0-p2: UDP 게임 서버 코어

#### 2.2.1 책임
- UDP 기반 게임 서버 메인 루프
- 클라이언트 연결/해제 관리
- 입력 수신 및 게임 상태 업데이트
- 권위 서버 모델 적용

#### 2.2.2 인터페이스
```cpp
// include/pvpserver/network/udp_game_server.h
namespace pvpserver::network {

class UdpGameServer {
public:
    explicit UdpGameServer(
        boost::asio::io_context& io,
        uint16_t port,
        game::GameSession& session
    );

    void start();
    void stop();

    // 클라이언트 입력 처리
    void handleInput(
        const Endpoint& client,
        const InputPacket& input
    );

    // 게임 상태 브로드캐스트
    void broadcastState(const GameState& state);

private:
    UdpSocket socket_;
    game::GameSession& session_;
    
    // 클라이언트 ID 매핑
    std::unordered_map<Endpoint, PlayerId> clientMap_;
    std::unordered_map<PlayerId, Endpoint> endpointMap_;

    // 패킷 파싱
    void onPacketReceived(
        const std::vector<uint8_t>& data,
        const Endpoint& sender
    );
};

}  // namespace pvpserver::network
```

#### 2.2.3 패킷 프로토콜
```
패킷 헤더 (4 바이트):
+--------+--------+--------+--------+
| Type   | SeqNum | SeqNum | Length |
| (1B)   | (2B, BE)        | (1B)   |
+--------+--------+--------+--------+

패킷 타입:
- 0x01: CONNECT (클라이언트 → 서버)
- 0x02: CONNECT_ACK (서버 → 클라이언트)
- 0x03: DISCONNECT
- 0x10: INPUT (클라이언트 → 서버)
- 0x20: STATE (서버 → 클라이언트)
- 0x21: DELTA (서버 → 클라이언트)
```

#### 2.2.4 권위 서버 모델
- 모든 게임 로직은 서버에서만 실행
- 클라이언트는 입력만 전송
- 서버가 최종 게임 상태 결정
- 클라이언트 입력 검증 (속도, 타이밍 등)

---

### 2.3 패치 1.4.0-p3: 스냅샷/델타 동기화

#### 2.3.1 책임
- 게임 상태 스냅샷 생성
- 델타(변경분) 계산 및 압축
- 스냅샷 버퍼링 (지연 보상용)

#### 2.3.2 인터페이스
```cpp
// include/pvpserver/network/snapshot_manager.h
namespace pvpserver::network {

struct Snapshot {
    uint32_t sequence;
    uint64_t timestamp;
    std::vector<PlayerState> players;
    std::vector<ProjectileState> projectiles;
};

struct Delta {
    uint32_t baseSequence;
    uint32_t targetSequence;
    std::vector<uint8_t> changes;  // 압축된 변경분
};

class SnapshotManager {
public:
    static constexpr size_t BUFFER_SIZE = 64;  // 약 1초 (60 TPS)

    // 현재 게임 상태로 스냅샷 생성
    Snapshot createSnapshot(const GameState& state);

    // 스냅샷 저장
    void saveSnapshot(const Snapshot& snapshot);

    // 특정 시퀀스의 스냅샷 조회
    std::optional<Snapshot> getSnapshot(uint32_t sequence) const;

    // 두 스냅샷 간 델타 계산
    Delta calculateDelta(uint32_t baseSeq, uint32_t targetSeq) const;

    // 델타 적용
    Snapshot applyDelta(const Snapshot& base, const Delta& delta) const;

    // 직렬화
    std::vector<uint8_t> serialize(const Snapshot& snapshot) const;
    std::vector<uint8_t> serialize(const Delta& delta) const;

private:
    std::array<Snapshot, BUFFER_SIZE> buffer_;
    uint32_t currentSequence_ = 0;
    size_t head_ = 0;
};

}  // namespace pvpserver::network
```

#### 2.3.3 델타 압축 알고리즘
```
1. 기준 스냅샷과 대상 스냅샷 비교
2. 변경된 필드만 추출
3. 비트 플래그로 변경 필드 표시
4. 변경된 값만 직렬화

예시:
Player 상태 = { x, y, hp, direction }
변경 플래그 = 0b0101 (x, hp 변경)
패킷 = [플래그][new_x][new_hp]
```

#### 2.3.4 테스트 포인트
- 스냅샷 직렬화/역직렬화 정확성
- 델타 계산 정확성
- 버퍼 순환 동작

---

### 2.4 패치 1.4.0-p4: WebSocket 교체

#### 2.4.1 책임
- main.cpp에서 WebSocketServer → UdpGameServer 전환
- 설정 파일 업데이트 (포트 등)
- 기존 WebSocket 제거 또는 선택적 사용

#### 2.4.2 변경 사항
```cpp
// main.cpp 변경 전
WebSocketServer wsServer(io, 8080, session);
wsServer.start();

// main.cpp 변경 후
UdpGameServer udpServer(io, 7777, session);
udpServer.start();

// 선택적: HTTP API는 별도 포트로 유지
MetricsHttpServer httpServer(io, 8080);
```

#### 2.4.3 하위 호환성
- WebSocket 코드는 제거하지 않고 유지 (테스트용)
- 설정으로 UDP/WebSocket 선택 가능
- 향후 WebSocket 폴백 옵션

---

## 3. 기존 코드와의 연관성

### 3.1 영향받는 모듈
| 모듈 | 변경 유형 | 설명 |
|------|----------|------|
| `network/` | 추가 | UDP 관련 새 파일 |
| `game/game_session.h` | 수정 | 입력/상태 인터페이스 변경 |
| `core/config.h` | 수정 | UDP 포트 설정 추가 |
| `main.cpp` | 수정 | 서버 초기화 변경 |

### 3.2 의존성
```
UdpGameServer
    ├── UdpSocket
    ├── SnapshotManager
    └── GameSession (기존)
```

---

## 4. 파일 구조

```
server/
├── include/pvpserver/
│   └── network/
│       ├── udp_socket.h          # 신규
│       ├── udp_game_server.h     # 신규
│       ├── snapshot_manager.h    # 신규
│       └── packet_types.h        # 신규
├── src/
│   └── network/
│       ├── udp_socket.cpp        # 신규
│       ├── udp_game_server.cpp   # 신규
│       └── snapshot_manager.cpp  # 신규
└── tests/
    └── unit/
        ├── test_udp_socket.cpp       # 신규
        └── test_snapshot_manager.cpp # 신규
```

---

## 5. 성능 요구사항

| 메트릭 | 목표 |
|--------|------|
| 스냅샷 직렬화 | < 0.1ms |
| 델타 계산 | < 0.2ms |
| 패킷 크기 (전체 상태) | < 500 bytes |
| 패킷 크기 (델타) | < 100 bytes |

---

## 6. 리스크 및 고려사항

### 6.1 패킷 손실 처리
- UDP는 패킷 손실을 보장하지 않음
- 중요 이벤트(연결, 킬)는 재전송 로직 필요
- 상태 동기화는 최신 스냅샷으로 복구

### 6.2 NAT 통과
- 클라이언트가 먼저 서버에 패킷 전송 필요
- 주기적 하트비트로 NAT 매핑 유지
- 향후 STUN/TURN 고려

### 6.3 보안
- 패킷 조작 방지: 서버 권위 모델로 검증
- DDoS: Rate limiting 적용
- 암호화: 향후 DTLS 고려

---

## 7. 다음 버전과의 연결

**v1.4.0에서 확립된 것:**
- UDP 소켓 래퍼 (Boost.Asio)
- UDP 게임 서버 코어
- 스냅샷/델타 동기화
- 패킷 타입 시스템

**v1.4.1 (클라이언트 예측)에서 추가될 것:**
- 클라이언트 예측 시스템
- 리컨실리에이션 (상태 보정)
- 입력 버퍼링
- 지연 보상 시스템

**v1.4.2 (관측성)에서 추가될 것:**
- UDP 메트릭 (RTT, 지터, 패킷 손실)
- 패킷 시뮬레이터
- 성능 벤치마크
