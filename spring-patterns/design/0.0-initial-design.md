# spring-patterns - 초기 설계 문서 (0.0)

> **"Spring의 모든 패턴을 단련하는 대장간"**  
> 프레임워크의 본질을 이해한 자가 진정한 패턴을 익히다

---

## 1. 프로젝트 비전

### 1.1 왜 이 프로젝트인가?

**문제 인식**:
```
"Spring Boot 사용해보셨나요?"
"네, @RestController 붙이면 되잖아요."

"트랜잭션 전파 전략 설명해주세요."
"... REQUIRED랑 REQUIRES_NEW 있는 건 아는데요."

"JPA N+1 문제 경험해보셨나요?"
"... 들어보긴 했는데요."
```

Phase 1(raw-http-server)에서 프레임워크의 **내부 원리**를 배웠다면,
이제는 그 위에서 **올바른 패턴**을 익혀야 한다.

Spring Boot를 "사용"하는 것과 "마스터"하는 것은 다르다:
- 레이어드 아키텍처의 각 층이 왜 필요한지 모른다
- 트랜잭션 경계를 어디에 둬야 하는지 감이 없다
- RBAC(역할 기반 접근 제어)를 직접 설계해본 적 없다
- Kafka/Elasticsearch 연동을 해본 적 없다

**해결책**: 작은 도메인에서 **모든 핵심 패턴**을 반복 적용한다.

### 1.2 프로젝트 정체성

**이름**: spring-patterns  
**어원**: Spring + Forge(대장간) = "Spring 패턴을 단련하는 곳"  
**철학**: "원리를 아는 자가 패턴을 익히면 무기가 된다"  
**핵심 가치**: 패턴 반복, 점진적 확장, 실전 준비

**비유**:
```
검을 만드는 대장장이가 되려면,

1. 먼저 금속의 성질을 이해해야 한다 (raw-http-server)
2. 그 다음 다양한 검법을 익혀야 한다 (spring-patterns)
3. 마지막으로 실전에서 싸워야 한다 (spring-commerce)

spring-patterns는 두 번째 단계다.
검법(패턴)을 수백 번 반복하여 몸에 익히는 곳.
```

### 1.3 목표와 비목표

**목표**:
- ✅ Spring Boot 핵심 패턴 완벽 숙달
- ✅ 레이어드 아키텍처 체화
- ✅ 트랜잭션 관리 마스터
- ✅ 인증/인가(RBAC) 직접 구현
- ✅ 캐싱, 배치, 검색, 이벤트 처리 경험
- ✅ 프로덕션 인프라(Docker, PostgreSQL, Redis) 이해

**비목표**:
- ❌ 복잡한 비즈니스 로직 (패턴에 집중)
- ❌ 마이크로서비스 분리 (모놀리스로 충분)
- ❌ 프론트엔드 연동 (API만)

---

## 2. 설계 철학

### 2.1 핵심 원칙

```
┌─────────────────────────────────────────────────────────┐
│             spring-patterns 설계 원칙                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 작은 도메인, 깊은 패턴 (Small Domain, Deep Pattern)  │
│     - Issue, Team, Order 등 간단한 도메인               │
│     - 하지만 각 도메인에서 패턴을 완벽히 적용            │
│                                                         │
│  2. 점진적 확장 (Progressive Enhancement)               │
│     - 2.0: 부트스트랩 + CI                              │
│     - 2.1: CRUD + 트랜잭션                              │
│     - 2.2: RBAC                                         │
│     - ...                                               │
│                                                         │
│  3. CI 우선 (CI First)                                  │
│     - 2.0에서 CI 완성                                   │
│     - 이후 테스트만 추가                                 │
│                                                         │
│  4. Phase 1 연계 (Build on Foundation)                  │
│     - raw-http-server에서 배운 원리를                       │
│     - Spring이 어떻게 구현했는지 확인                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 2.2 Phase 1 → Phase 1.5 연결고리

| raw-http-server (Phase 1) | spring-patterns (Phase 1.5) | 확인 포인트 |
|----------------------|-------------------------|------------|
| ThreadPool 직접 구현 | Tomcat 쓰레드 풀 | server.tomcat.threads.max |
| HttpParser 직접 구현 | DispatcherServlet | 요청 처리 흐름 디버깅 |
| @route 데코레이터 | @RequestMapping | 어노테이션 프로세싱 |
| DIContainer 직접 구현 | ApplicationContext | Bean 라이프사이클 |
| ConnectionPool 직접 구현 | HikariCP | 풀 모니터링 메트릭 |
| Middleware 직접 구현 | Filter/Interceptor | 체인 패턴 |

### 2.3 기술 스택

**프레임워크**: Spring Boot 3.x

**언어**: Java 21 (Virtual Threads 지원)

**빌드**: Gradle

**데이터베이스**:
```
┌─────────────────┬────────────────────┐
│ H2 (In-Memory)  │ 개발/테스트용        │
├─────────────────┼────────────────────┤
│ PostgreSQL 15+  │ 프로덕션 (2.6)      │
├─────────────────┼────────────────────┤
│ Redis 7+        │ 캐시 (2.3)          │
├─────────────────┼────────────────────┤
│ Elasticsearch   │ 검색 (2.4)          │
├─────────────────┼────────────────────┤
│ Kafka           │ 이벤트 (2.5)        │
└─────────────────┴────────────────────┘
```

### 2.4 프로젝트 구조

```
springforge/
├── src/
│   ├── main/
│   │   ├── java/com/example/training/
│   │   │   ├── Application.java         # 부트스트랩
│   │   │   │
│   │   │   ├── common/                  # 공통 모듈
│   │   │   │   ├── config/              # 설정
│   │   │   │   ├── exception/           # 예외 처리
│   │   │   │   ├── health/              # 헬스 체크
│   │   │   │   └── security/            # 보안 (2.2)
│   │   │   │
│   │   │   ├── issue/                   # 이슈 도메인 (2.1)
│   │   │   │   ├── domain/              # 엔티티
│   │   │   │   ├── repository/          # JPA
│   │   │   │   ├── service/             # 비즈니스
│   │   │   │   └── controller/          # API
│   │   │   │
│   │   │   ├── team/                    # 팀 도메인 (2.2)
│   │   │   │   ├── domain/
│   │   │   │   ├── repository/
│   │   │   │   ├── service/
│   │   │   │   └── controller/
│   │   │   │
│   │   │   ├── stats/                   # 통계 도메인 (2.3)
│   │   │   │   ├── batch/               # 배치 처리
│   │   │   │   ├── cache/               # 캐싱
│   │   │   │   └── external/            # 외부 API
│   │   │   │
│   │   │   ├── search/                  # 검색 도메인 (2.4)
│   │   │   │   ├── document/            # ES 문서
│   │   │   │   ├── index/               # 인덱싱
│   │   │   │   └── query/               # 검색 쿼리
│   │   │   │
│   │   │   └── order/                   # 주문 도메인 (2.5)
│   │   │       ├── event/               # Kafka 이벤트
│   │   │       ├── producer/            # 발행
│   │   │       └── consumer/            # 구독
│   │   │
│   │   └── resources/
│   │       ├── application.yml
│   │       ├── application-local.yml
│   │       └── application-test.yml
│   │
│   └── test/
│       └── java/com/example/training/
│
├── design/
│   ├── 0.0-initial-design.md           # 이 문서
│   ├── v0.1.0-bootstrap-ci.md
│   ├── v1.0.0-layered-crud.md
│   ├── ...
│   └── v1.5.0-production-infra.md
│
├── docker/
│   ├── docker-compose.yml
│   ├── postgres/
│   └── redis/
│
├── build.gradle
└── README.md
```

---

## 3. 로드맵

### 3.1 전체 여정

```
┌───────────────────────────────────────────────────────────────────┐
│                      spring-patterns 로드맵                            │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│  선행 조건: raw-http-server (Phase 1) 완료                             │
│                                                                   │
│  ┌─────────────────────────────────────────────────┐              │
│  │ v0.1.0: 부트스트랩 & CI                         │              │
│  │ • Spring Boot 3.x 초기화                         │              │
│  │ • GitHub Actions CI 구축                        │              │
│  │ • 헬스 체크 엔드포인트                           │              │
│  │ • 테스트 기준선 (컨텍스트 로딩)                   │              │
│  └─────────────────────────────────────────────────┘              │
│         │                                                         │
│         ▼                                                         │
│  ┌─────────────────────────────────────────────────┐              │
│  │ v1.0.0: 레이어드 CRUD & 트랜잭션               │              │
│  │ • Issue 도메인 CRUD                             │              │
│  │ • Controller → Service → Repository 계층       │              │
│  │ • @Transactional 전파 전략                      │              │
│  │ • JPA N+1 문제 해결                             │              │
│  └─────────────────────────────────────────────────┘              │
│         │                                                         │
│         ▼                                                         │
│  ┌─────────────────────────────────────────────────┐              │
│  │ v1.1.0: Team & RBAC                            │              │
│  │ • Team 도메인                                   │              │
│  │ • 사용자-팀-역할 관계                            │              │
│  │ • Spring Security 통합                          │              │
│  │ • 역할 기반 접근 제어                            │              │
│  └─────────────────────────────────────────────────┘              │
│         │                                                         │
│         ▼                                                         │
│  ┌─────────────────────────────────────────────────┐              │
│  │ v1.2.0: 배치, 통계, 캐시, 외부 API              │              │
│  │ • Spring Batch 통계 집계                        │              │
│  │ • Redis 캐싱 전략                               │              │
│  │ • 외부 API 호출 (RestTemplate/WebClient)        │              │
│  │ • 스케줄링 (@Scheduled)                         │              │
│  └─────────────────────────────────────────────────┘              │
│         │                                                         │
│         ▼                                                         │
│  ┌─────────────────────────────────────────────────┐              │
│  │ v1.3.0: Elasticsearch 검색                     │              │
│  │ • 검색 인덱스 설계                              │              │
│  │ • 자동 인덱싱 (이벤트 기반)                      │              │
│  │ • 풀텍스트 검색                                 │              │
│  │ • 자동완성 구현                                 │              │
│  └─────────────────────────────────────────────────┘              │
│         │                                                         │
│         ▼                                                         │
│  ┌─────────────────────────────────────────────────┐              │
│  │ v1.4.0: Kafka 비동기 이벤트                    │              │
│  │ • Order 도메인                                  │              │
│  │ • 이벤트 발행 (Producer)                        │              │
│  │ • 이벤트 구독 (Consumer)                        │              │
│  │ • 멱등성 처리                                   │              │
│  └─────────────────────────────────────────────────┘              │
│         │                                                         │
│         ▼                                                         │
│  ┌─────────────────────────────────────────────────┐              │
│  │ v1.5.0: Docker, PostgreSQL, Redis              │              │
│  │ • Docker Compose 통합                           │              │
│  │ • H2 → PostgreSQL 전환                         │              │
│  │ • Redis 세션/캐시 통합                          │              │
│  │ • 프로덕션 준비 완료                            │              │
│  └─────────────────────────────────────────────────┘              │
│         │                                                         │
│         ▼                                                         │
│  ┌─────────────────────────────────────────────────┐              │
│  │ → spring-commerce (Phase 2) 이동                       │              │
│  └─────────────────────────────────────────────────┘              │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

### 3.2 마일스톤별 핵심 패턴

| 버전 | 핵심 패턴 | 숙달 목표 |
|---------|---------|----------|
| v0.1.0 | CI/CD | GitHub Actions로 자동 검증 |
| v1.0.0 | 레이어드 아키텍처, 트랜잭션 | 전파 전략, 롤백 규칙 |
| v1.1.0 | RBAC, Spring Security | 인증/인가 분리 |
| v1.2.0 | 캐싱, 배치, 외부 API | Redis TTL, Batch Job |
| v1.3.0 | 검색 엔진 | Elasticsearch Query DSL |
| v1.4.0 | 이벤트 드리븐 | Kafka Producer/Consumer |
| v1.5.0 | 컨테이너화 | Docker Compose |

---

## 4. 아키텍처 스케치

### 4.1 레이어드 아키텍처 (2.1)

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Presentation Layer                             │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    @RestController                           │   │
│  │                                                              │   │
│  │  • HTTP 요청 수신                                            │   │
│  │  • 요청 유효성 검증 (@Valid)                                 │   │
│  │  • DTO ↔ 도메인 변환 호출                                    │   │
│  │  • HTTP 응답 반환                                            │   │
│  │                                                              │   │
│  │  [금지] 비즈니스 로직, DB 직접 접근                           │   │
│  └─────────────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────────────┤
│                       Business Layer                                │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                     @Service                                 │   │
│  │                                                              │   │
│  │  • 비즈니스 로직 구현                                        │   │
│  │  • 트랜잭션 경계 (@Transactional)                            │   │
│  │  • 도메인 규칙 적용                                          │   │
│  │  • 여러 Repository 조합                                      │   │
│  │                                                              │   │
│  │  [금지] HTTP 관련 코드, 직접 SQL                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────────────┤
│                       Persistence Layer                             │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    @Repository                               │   │
│  │                                                              │   │
│  │  • 데이터 접근 추상화                                        │   │
│  │  • JPA/JPQL/Native Query                                    │   │
│  │  • 캐시 적용 가능                                            │   │
│  │                                                              │   │
│  │  [금지] 비즈니스 로직                                        │   │
│  └─────────────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────────────┤
│                        Domain Layer                                 │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                     @Entity                                  │   │
│  │                                                              │   │
│  │  • 도메인 모델                                               │   │
│  │  • 비즈니스 불변식                                           │   │
│  │  • 값 객체 (VO)                                              │   │
│  │                                                              │   │
│  │  [금지] 프레임워크 의존성 (가능한 한)                         │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 RBAC 구조 (2.2)

```
┌─────────────────────────────────────────────────────────────────────┐
│                          RBAC Model                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────┐      ┌─────────┐      ┌─────────┐                     │
│  │  User   │ N:M  │  Team   │ 1:N  │  Role   │                     │
│  │         │──────│         │──────│         │                     │
│  │ - id    │      │ - id    │      │ - name  │                     │
│  │ - email │      │ - name  │      │ - perms │                     │
│  │ - pwd   │      │         │      │         │                     │
│  └─────────┘      └─────────┘      └─────────┘                     │
│       │                                  │                         │
│       │                                  │                         │
│       │                                  ▼                         │
│       │              ┌─────────────────────────────────┐           │
│       │              │          Permission             │           │
│       │              │                                 │           │
│       │              │  TEAM_CREATE, TEAM_READ,        │           │
│       │              │  ISSUE_CREATE, ISSUE_UPDATE,    │           │
│       │              │  ADMIN_MANAGE                   │           │
│       │              └─────────────────────────────────┘           │
│       │                                                            │
│       ▼                                                            │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │                 Spring Security Filter Chain                 │  │
│  │                                                              │  │
│  │  AuthenticationFilter → AuthorizationFilter → Controller     │  │
│  │                                                              │  │
│  │  @PreAuthorize("hasPermission('ISSUE_CREATE')")             │  │
│  └─────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.3 이벤트 드리븐 아키텍처 (2.5)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Event-Driven Architecture                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   Order Service                           Inventory Service         │
│  ┌─────────────┐                        ┌─────────────┐            │
│  │             │                        │             │            │
│  │  주문 생성   │                        │  재고 차감   │            │
│  │             │                        │             │            │
│  └──────┬──────┘                        └──────▲──────┘            │
│         │                                      │                    │
│         │ produce                              │ consume            │
│         ▼                                      │                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                       Apache Kafka                           │   │
│  │                                                              │   │
│  │  Topic: order-events                                         │   │
│  │  ┌─────────┬─────────┬─────────┬─────────┐                  │   │
│  │  │ Msg 1   │ Msg 2   │ Msg 3   │ ...     │                  │   │
│  │  │ OrderId │ OrderId │ OrderId │         │                  │   │
│  │  │ Created │ Paid    │ Shipped │         │                  │   │
│  │  └─────────┴─────────┴─────────┴─────────┘                  │   │
│  │                                                              │   │
│  │  Partition 0 ──────────────────────────────                  │   │
│  │  Partition 1 ──────────────────────────────                  │   │
│  │  Partition 2 ──────────────────────────────                  │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│   Notification Service              Statistics Service              │
│  ┌─────────────┐                  ┌─────────────┐                  │
│  │             │ consume          │             │ consume          │
│  │  알림 발송   │◄─────────────    │  통계 집계   │◄─────────────    │
│  │             │                  │             │                  │
│  └─────────────┘                  └─────────────┘                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 5. 핵심 설계

### 5.1 트랜잭션 전파 전략 (2.1)

```java
// REQUIRED (기본값): 부모 트랜잭션 있으면 참여, 없으면 새로 생성
@Transactional
public void createIssue(IssueRequest request) {
    Issue issue = issueRepository.save(toEntity(request));
    notificationService.notify(issue);  // 같은 트랜잭션
}

// REQUIRES_NEW: 항상 새 트랜잭션 (부모와 독립)
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void logAction(String action) {
    // 부모 롤백되어도 이 로그는 커밋됨
    actionLogRepository.save(new ActionLog(action));
}

// MANDATORY: 부모 트랜잭션 필수 (없으면 예외)
@Transactional(propagation = Propagation.MANDATORY)
public void updateStock(Long productId, int delta) {
    // 반드시 상위 트랜잭션 안에서 호출되어야 함
}
```

### 5.2 N+1 문제 해결 (2.1)

```java
// ❌ N+1 문제 발생
@Entity
public class Team {
    @OneToMany(mappedBy = "team", fetch = FetchType.LAZY)
    private List<Member> members;
}

// 팀 N개 조회 → 각 팀의 멤버 조회 → 총 N+1 쿼리

// ✅ 해결 방법 1: Fetch Join
@Query("SELECT t FROM Team t JOIN FETCH t.members WHERE t.id = :id")
Optional<Team> findByIdWithMembers(@Param("id") Long id);

// ✅ 해결 방법 2: EntityGraph
@EntityGraph(attributePaths = {"members"})
Optional<Team> findWithMembersById(Long id);

// ✅ 해결 방법 3: Batch Size
@OneToMany(mappedBy = "team")
@BatchSize(size = 100)  // 100개씩 IN 쿼리로 조회
private List<Member> members;
```

### 5.3 캐싱 전략 (2.3)

```java
// Spring Cache Abstraction + Redis
@Service
public class ProductService {
    
    @Cacheable(value = "products", key = "#id")
    public ProductDTO findById(Long id) {
        // 캐시 미스 시에만 DB 조회
        return productRepository.findById(id)
            .map(this::toDTO)
            .orElseThrow();
    }
    
    @CacheEvict(value = "products", key = "#id")
    public void update(Long id, ProductRequest request) {
        // 업데이트 후 캐시 무효화
        Product product = productRepository.findById(id).orElseThrow();
        product.update(request);
    }
    
    @Caching(evict = {
        @CacheEvict(value = "products", allEntries = true),
        @CacheEvict(value = "categories", allEntries = true)
    })
    public void clearAllCaches() {
        // 전체 캐시 초기화
    }
}
```

### 5.4 Kafka 이벤트 발행/구독 (2.5)

```java
// Producer
@Service
public class OrderEventProducer {
    private final KafkaTemplate<String, OrderEvent> kafkaTemplate;
    
    public void publishOrderCreated(Order order) {
        OrderEvent event = OrderEvent.builder()
            .eventId(UUID.randomUUID().toString())
            .eventType("ORDER_CREATED")
            .orderId(order.getId())
            .timestamp(Instant.now())
            .build();
        
        kafkaTemplate.send("order-events", order.getId().toString(), event);
    }
}

// Consumer
@Service
public class InventoryEventConsumer {
    
    @KafkaListener(topics = "order-events", groupId = "inventory-service")
    public void handleOrderEvent(OrderEvent event) {
        // 멱등성 보장: 이벤트 ID로 중복 체크
        if (processedEventRepository.existsByEventId(event.getEventId())) {
            log.info("Duplicate event ignored: {}", event.getEventId());
            return;
        }
        
        // 비즈니스 로직
        if ("ORDER_CREATED".equals(event.getEventType())) {
            inventoryService.decreaseStock(event.getOrderId());
        }
        
        // 처리 완료 기록
        processedEventRepository.save(new ProcessedEvent(event.getEventId()));
    }
}
```

---

## 6. 테스트 전략

### 6.1 계층별 테스트

```
┌─────────────────────────────────────────┐
│          Integration Tests              │
│   @SpringBootTest                       │
│   전체 컨텍스트 로딩, E2E 시나리오         │
├─────────────────────────────────────────┤
│         Slice Tests                     │
│   @WebMvcTest: Controller 계층          │
│   @DataJpaTest: Repository 계층         │
│   @MockBean으로 의존성 모킹              │
├─────────────────────────────────────────┤
│          Unit Tests                     │
│   순수 Java, Mockito                    │
│   Service 로직, 도메인 로직              │
└─────────────────────────────────────────┘
```

### 6.2 각 마일스톤별 테스트 요구사항

| 마일스톤 | 필수 테스트 | 커버리지 |
|---------|----------|---------|
| 2.0 | 컨텍스트 로딩, 헬스 체크 | 기준선 |
| 2.1 | CRUD, 트랜잭션 롤백 | 70%+ |
| 2.2 | 인증/인가 시나리오 | 70%+ |
| 2.3 | 캐시 hit/miss, 배치 | 70%+ |
| 2.4 | 검색 쿼리 정확도 | 70%+ |
| 2.5 | 이벤트 발행/구독 | 70%+ |
| 2.6 | 통합 테스트 (Testcontainers) | 80%+ |

---

## 7. 성능 목표

### 7.1 벤치마크

| 메트릭 | 목표 | 측정 |
|-------|------|------|
| API 응답 (p99) | < 100ms | 간단 CRUD |
| 캐시 hit ratio | > 80% | Redis 통계 |
| 검색 응답 | < 200ms | Elasticsearch |
| 이벤트 처리 지연 | < 1s | Kafka lag |

### 7.2 최적화 포인트

```
1. JPA 최적화
   - N+1 방지
   - 적절한 인덱스
   - 페이징 처리

2. 캐싱
   - Hot data Redis 캐싱
   - 적절한 TTL

3. 비동기 처리
   - 무거운 작업 Kafka로 분리
   - @Async 활용
```

---

## 8. 리스크와 완화 전략

| 리스크 | 확률 | 영향 | 완화 전략 |
|-------|------|------|----------|
| 트랜잭션 경계 혼란 | 높음 | 중간 | 명확한 규칙 문서화 |
| 캐시 일관성 문제 | 중간 | 중간 | 캐시 무효화 전략 수립 |
| Kafka 메시지 유실 | 낮음 | 높음 | acks=all, 멱등성 |
| 학습 곡선 | 중간 | 낮음 | 마일스톤 순서 준수 |

---

## 9. 성공 지표

### 9.1 기술적 성공

- [ ] 모든 마일스톤 CI 통과
- [ ] 테스트 커버리지 80% 이상
- [ ] 성능 목표 달성
- [ ] Docker Compose로 원클릭 실행

### 9.2 학습 성공

면접에서 대답할 수 있어야 하는 질문들:

1. **"트랜잭션 전파 전략 설명해주세요"**
   > "REQUIRED는 부모 트랜잭션에 참여하고, REQUIRES_NEW는 독립적인 
   > 새 트랜잭션을 만듭니다. 로그 기록처럼 부모 롤백과 무관하게 
   > 커밋되어야 하는 경우 REQUIRES_NEW를 씁니다."

2. **"N+1 문제가 뭔가요?"**
   > "N개의 엔티티를 조회할 때 연관 엔티티를 각각 조회해서 
   > N+1개의 쿼리가 발생하는 문제입니다. Fetch Join이나 
   > EntityGraph, BatchSize로 해결합니다."

3. **"RBAC를 어떻게 구현하셨나요?"**
   > "User-Team-Role 관계를 JPA로 모델링하고, Spring Security의 
   > @PreAuthorize와 커스텀 Permission Evaluator로 구현했습니다."

4. **"Kafka 메시지 유실을 어떻게 방지하나요?"**
   > "Producer에서 acks=all 설정하고, Consumer에서 수동 커밋합니다. 
   > 멱등성 키로 중복 처리도 막습니다."

---

## 10. 다음 단계

이 초기 설계가 완료되면:

1. **[v0.1.0 Bootstrap & CI](v0.1.0-bootstrap-ci.md)**: 부트스트랩 & CI로 이동
2. 각 마일스톤을 순차적으로 완료
3. 2.6 완료 후 **spring-commerce (Phase 2)**으로 진입

---

## 부록: 학습 경로 연결

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   raw-http-server   │ ──→ │   spring-patterns   │ ──→ │    spring-commerce     │
│   (Phase 1)     │     │   (Phase 1.5)   │     │    (Phase 2)    │
│                 │     │                 │     │                 │
│  프레임워크 원리  │     │  Spring 패턴   │     │   프로덕션 경험  │
│  직접 구현       │     │  반복 훈련      │     │   실전 적용     │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

---

*"원리를 아는 자가 패턴을 익히면, 그것이 실력이 된다."*
