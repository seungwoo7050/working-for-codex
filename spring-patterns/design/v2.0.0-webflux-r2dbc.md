# v2.0.0 WebFlux & R2DBC 전환 설계

> 블로킹 → 리액티브 전환을 통한 고성능 API 구현

## 개요

### 목표
- Spring MVC → Spring WebFlux 전환
- JPA → R2DBC 전환
- SSE(Server-Sent Events) 스트리밍 지원
- 논블로킹 I/O 기반 고성능 API

### 성능 목표
| 메트릭 | 목표 |
|--------|------|
| API 응답 시간 | < 50ms (p99) |
| 처리량 | 10,000 req/s |
| 메모리 | < 1GB per instance |

---

## 패치별 상세 설계

### 2.0.1: WebFlux & R2DBC 의존성 추가

#### 변경 파일
- `build.gradle`

#### 변경 내용
```gradle
// 제거
implementation 'org.springframework.boot:spring-boot-starter-web'
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

// 추가 (이미 webflux 있음, r2dbc 추가)
implementation 'org.springframework.boot:spring-boot-starter-data-r2dbc'
runtimeOnly 'io.r2dbc:r2dbc-h2'
runtimeOnly 'io.r2dbc:r2dbc-postgresql'
```

#### 주의사항
- 기존 JPA 코드와 병행 운영 (점진적 마이그레이션)
- WebFlux와 MVC 혼용 시 WebFlux 우선

---

### 2.0.2: R2DBC Repository 전환

#### 새로운 파일
- `src/main/java/com/example/training/product/domain/ProductEntity.java`
- `src/main/java/com/example/training/product/repository/ProductR2dbcRepository.java`

#### 데이터 구조
```java
@Table("products")
public class ProductEntity {
    @Id
    private Long id;
    private String name;
    private String description;
    private BigDecimal price;
    private Integer stock;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

#### Repository 인터페이스
```java
public interface ProductR2dbcRepository 
    extends ReactiveCrudRepository<ProductEntity, Long> {
    
    Flux<ProductEntity> findByNameContaining(String keyword);
    
    @Query("SELECT * FROM products WHERE price BETWEEN :min AND :max")
    Flux<ProductEntity> findByPriceRange(BigDecimal min, BigDecimal max);
}
```

#### 기존 코드 연관성
- 기존 `ProductRepository` (JPA)는 유지
- 새로운 리액티브 API는 `ProductR2dbcRepository` 사용

---

### 2.0.3: 리액티브 컨트롤러 구현

#### 새로운 파일
- `src/main/java/com/example/training/product/controller/ReactiveProductController.java`

#### API 엔드포인트
| Method | Path | 설명 | 반환 타입 |
|--------|------|------|----------|
| GET | `/api/v2/products` | 상품 목록 | `Flux<ProductResponse>` |
| GET | `/api/v2/products/{id}` | 상품 상세 | `Mono<ProductResponse>` |
| POST | `/api/v2/products` | 상품 생성 | `Mono<ProductResponse>` |
| PUT | `/api/v2/products/{id}` | 상품 수정 | `Mono<ProductResponse>` |
| DELETE | `/api/v2/products/{id}` | 상품 삭제 | `Mono<Void>` |

#### 핵심 구현
```java
@RestController
@RequestMapping("/api/v2/products")
@RequiredArgsConstructor
public class ReactiveProductController {
    
    private final ReactiveProductService productService;
    
    @GetMapping
    public Flux<ProductResponse> getAllProducts() {
        return productService.findAll();
    }
    
    @GetMapping("/{id}")
    public Mono<ProductResponse> getProduct(@PathVariable Long id) {
        return productService.findById(id);
    }
}
```

---

### 2.0.4: 리액티브 서비스 구현

#### 새로운 파일
- `src/main/java/com/example/training/product/service/ReactiveProductService.java`
- `src/main/java/com/example/training/product/dto/ProductRequest.java`
- `src/main/java/com/example/training/product/dto/ProductResponse.java`

#### 서비스 책임
- CRUD 비즈니스 로직
- 에러 핸들링 (Mono.error, onErrorResume)
- Backpressure 처리

#### 핵심 구현
```java
@Service
@RequiredArgsConstructor
public class ReactiveProductService {
    
    private final ProductR2dbcRepository repository;
    
    public Flux<ProductResponse> findAll() {
        return repository.findAll()
            .map(this::toResponse);
    }
    
    public Mono<ProductResponse> findById(Long id) {
        return repository.findById(id)
            .map(this::toResponse)
            .switchIfEmpty(Mono.error(
                new ResourceNotFoundException("Product not found: " + id)));
    }
    
    public Mono<ProductResponse> create(ProductRequest request) {
        return repository.save(toEntity(request))
            .map(this::toResponse);
    }
}
```

---

### 2.0.5: SSE 스트리밍 구현

#### 변경 파일
- `src/main/java/com/example/training/product/controller/ReactiveProductController.java`

#### 새로운 파일
- `src/main/java/com/example/training/product/event/ProductEventPublisher.java`

#### API 엔드포인트
| Method | Path | 설명 | Content-Type |
|--------|------|------|--------------|
| GET | `/api/v2/products/stream` | 실시간 상품 업데이트 | `text/event-stream` |

#### 핵심 구현
```java
@GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<ServerSentEvent<ProductResponse>> streamProducts() {
    return productEventPublisher.getEventStream()
        .map(product -> ServerSentEvent.<ProductResponse>builder()
            .id(String.valueOf(product.getId()))
            .event("product-update")
            .data(product)
            .build());
}
```

#### 이벤트 발행
```java
@Component
public class ProductEventPublisher {
    private final Sinks.Many<ProductResponse> sink = 
        Sinks.many().multicast().onBackpressureBuffer();
    
    public void publish(ProductResponse product) {
        sink.tryEmitNext(product);
    }
    
    public Flux<ProductResponse> getEventStream() {
        return sink.asFlux();
    }
}
```

---

## 테스트 관점

### 단위 테스트
- `ReactiveProductServiceTest`: StepVerifier 사용
- Mono/Flux 검증

### 통합 테스트
- `ReactiveProductControllerTest`: WebTestClient 사용
- SSE 스트리밍 테스트

### 테스트 예시
```java
@Test
void findById_whenExists_returnsProduct() {
    StepVerifier.create(productService.findById(1L))
        .expectNextMatches(p -> p.getName().equals("Test Product"))
        .verifyComplete();
}

@Test
void findById_whenNotExists_returnsError() {
    StepVerifier.create(productService.findById(999L))
        .expectError(ResourceNotFoundException.class)
        .verify();
}
```

---

## 데이터베이스 스키마

### products 테이블
```sql
CREATE TABLE IF NOT EXISTS products (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    price DECIMAL(19, 2) NOT NULL,
    stock INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 설정 파일

### application.yml 추가 설정
```yaml
spring:
  r2dbc:
    url: r2dbc:h2:mem:///testdb
    username: sa
    password:
    
  # 스키마 초기화
  sql:
    init:
      mode: always
      schema-locations: classpath:schema-r2dbc.sql
```

---

## 아키텍처 다이어그램

```
┌─────────────────────────────────────────────────────────┐
│                    Client Request                        │
└─────────────────────────┬───────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│              ReactiveProductController                   │
│         (Mono<T> / Flux<T> / ServerSentEvent)           │
└─────────────────────────┬───────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│               ReactiveProductService                     │
│            (Backpressure, Error Handling)               │
└─────────────────────────┬───────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│              ProductR2dbcRepository                      │
│         (ReactiveCrudRepository<Product, Long>)         │
└─────────────────────────┬───────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                  R2DBC Driver                            │
│              (H2 / PostgreSQL)                          │
└─────────────────────────────────────────────────────────┘
```
