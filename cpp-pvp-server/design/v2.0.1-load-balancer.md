# v2.0.1 설계 문서: 로드 밸런서 및 Consistent Hashing

## 개요

플레이어를 여러 게임 서버에 균등하게 분배하고, 세션 어피니티를 유지하기 위한 로드 밸런싱 시스템을 구현합니다.

## 아키텍처

```
                     ┌─────────────────┐
                     │   클라이언트    │
                     └────────┬────────┘
                              │
                     ┌────────▼────────┐
                     │  로드 밸런서    │
                     │ (Consistent     │
                     │     Hash)       │
                     └────────┬────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────▼───────┐    ┌───────▼───────┐    ┌───────▼───────┐
│  게임 서버 1   │    │  게임 서버 2   │    │  게임 서버 3   │
└───────────────┘    └───────────────┘    └───────────────┘
```

## 컴포넌트 설계

### 1. ConsistentHashRing

Consistent Hashing으로 플레이어를 서버에 균등 분배합니다.

```cpp
// distributed/consistent_hash.h
#pragma once

#include <map>
#include <set>
#include <string>
#include <vector>

namespace pvpserver {
namespace distributed {

class ConsistentHashRing {
public:
    explicit ConsistentHashRing(int virtual_nodes = 150);

    void AddNode(const std::string& node_id);
    void RemoveNode(const std::string& node_id);

    std::string GetNode(const std::string& key) const;
    std::vector<std::string> GetNodes(const std::string& key, int n) const;

    size_t GetNodeCount() const;
    bool HasNode(const std::string& node_id) const;

    // 디버깅/모니터링
    std::map<std::string, int> GetDistribution(
        const std::vector<std::string>& keys) const;

private:
    int virtual_nodes_;
    std::map<size_t, std::string> ring_;
    std::set<std::string> nodes_;

    size_t Hash(const std::string& key) const;
    std::string MakeVirtualNodeKey(const std::string& node_id, int index) const;
};

}  // namespace distributed
}  // namespace pvpserver
```

### 알고리즘 설명

#### 가상 노드
실제 서버 1개를 여러 가상 노드로 표현하여 분배 균일성을 높입니다.

```
실제 노드: server1
가상 노드: server1#0, server1#1, ... server1#149
```

#### 해시 링
```
    0
    │
    ├── server1#47 (hash: 100)
    │
    ├── server2#23 (hash: 350)
    │
    ├── server1#89 (hash: 500)
    │
    ├── server3#12 (hash: 720)
    │
    └── (wrap to 0)
```

#### 노드 조회
```cpp
std::string GetNode(const std::string& key) {
    size_t hash = Hash(key);
    auto it = ring_.lower_bound(hash);
    if (it == ring_.end()) {
        it = ring_.begin();
    }
    return it->second;
}
```

### 2. LoadBalancer

여러 분배 전략을 지원하는 로드 밸런서입니다.

```cpp
// distributed/load_balancer.h
#pragma once

#include "consistent_hash.h"
#include <atomic>
#include <optional>
#include <unordered_map>

namespace pvpserver {
namespace distributed {

struct ServerInfo {
    std::string server_id;
    std::string host;
    int udp_port;
    int grpc_port;
    int current_connections;
    int max_connections;
    int64_t last_heartbeat;
    bool healthy = true;
};

enum class LoadBalanceStrategy {
    CONSISTENT_HASH,
    ROUND_ROBIN,
    LEAST_CONNECTIONS
};

class LoadBalancer {
public:
    explicit LoadBalancer(
        LoadBalanceStrategy strategy = LoadBalanceStrategy::CONSISTENT_HASH);

    void RegisterServer(const ServerInfo& server);
    void UnregisterServer(const std::string& server_id);

    std::optional<ServerInfo> SelectServer(const std::string& player_id);

    void UpdateServerLoad(const std::string& server_id, int connections);
    void MarkServerHealthy(const std::string& server_id, bool healthy);

    std::vector<ServerInfo> GetAllServers() const;
    std::vector<ServerInfo> GetHealthyServers() const;

private:
    LoadBalanceStrategy strategy_;
    ConsistentHashRing hash_ring_;
    mutable std::mutex mutex_;
    std::unordered_map<std::string, ServerInfo> servers_;
    std::atomic<size_t> round_robin_index_{0};

    std::optional<ServerInfo> SelectByConsistentHash(
        const std::string& player_id);
    std::optional<ServerInfo> SelectByRoundRobin();
    std::optional<ServerInfo> SelectByLeastConnections();
};

}  // namespace distributed
}  // namespace pvpserver
```

### 3. ServiceDiscovery

Redis를 사용한 서비스 등록/발견 시스템입니다.

```cpp
// distributed/service_discovery.h
#pragma once

#include "load_balancer.h"
#include <functional>
#include <memory>
#include <thread>

namespace pvpserver {
namespace distributed {

class RedisClient;  // forward declaration

class ServiceDiscovery {
public:
    explicit ServiceDiscovery(std::shared_ptr<RedisClient> redis);
    ~ServiceDiscovery();

    // 서버 등록/해제
    void Register(const ServerInfo& self);
    void Unregister();

    // 서버 목록 조회
    std::vector<ServerInfo> GetAvailableServers();
    std::optional<ServerInfo> GetServer(const std::string& server_id);

    // 콜백
    void OnServerAdded(std::function<void(const ServerInfo&)> callback);
    void OnServerRemoved(std::function<void(const std::string&)> callback);

    // 하트비트 제어
    void StartHeartbeat();
    void StopHeartbeat();

private:
    std::shared_ptr<RedisClient> redis_;
    ServerInfo self_;
    std::atomic<bool> running_{false};
    std::thread heartbeat_thread_;
    std::thread subscription_thread_;

    std::function<void(const ServerInfo&)> on_server_added_;
    std::function<void(const std::string&)> on_server_removed_;

    static constexpr int HEARTBEAT_INTERVAL_SEC = 5;
    static constexpr int SERVER_TTL_SEC = 15;

    void HeartbeatLoop();
    void SubscriptionLoop();
    void PublishServerInfo();
};

}  // namespace distributed
}  // namespace pvpserver
```

### 4. HealthChecker

서버 상태를 모니터링하고 비정상 서버를 탐지합니다.

```cpp
// distributed/health_check.h
#pragma once

#include "service_discovery.h"
#include <chrono>

namespace pvpserver {
namespace distributed {

class HealthChecker {
public:
    HealthChecker(
        std::shared_ptr<ServiceDiscovery> discovery,
        std::shared_ptr<LoadBalancer> balancer,
        std::chrono::seconds check_interval = std::chrono::seconds(5));
    ~HealthChecker();

    void Start();
    void Stop();

    bool IsServerHealthy(const std::string& server_id) const;

    void OnServerUnhealthy(
        std::function<void(const std::string&)> callback);
    void OnServerRecovered(
        std::function<void(const std::string&)> callback);

private:
    std::shared_ptr<ServiceDiscovery> discovery_;
    std::shared_ptr<LoadBalancer> balancer_;
    std::chrono::seconds check_interval_;

    std::atomic<bool> running_{false};
    std::thread check_thread_;
    std::unordered_map<std::string, int> failure_counts_;
    mutable std::mutex mutex_;

    std::function<void(const std::string&)> on_unhealthy_;
    std::function<void(const std::string&)> on_recovered_;

    static constexpr int FAILURE_THRESHOLD = 3;

    void CheckLoop();
    bool CheckServer(const ServerInfo& server);
};

}  // namespace distributed
}  // namespace pvpserver
```

## Redis 데이터 구조

### 서버 정보 저장
```
Key: pvp:server:{server_id}
Value: {serialized ServerInfo}
TTL: 15 seconds (하트비트로 갱신)
```

### 서버 목록 (Set)
```
Key: pvp:servers
Members: server_id1, server_id2, ...
```

### 서버 이벤트 (Pub/Sub)
```
Channel: pvp:server:events
Messages:
  - {"event": "added", "server_id": "..."}
  - {"event": "removed", "server_id": "..."}
```

## 노드 추가/제거 시 동작

### 노드 추가
1. ServiceDiscovery.Register() 호출
2. Redis에 서버 정보 저장
3. pvp:server:events에 added 이벤트 발행
4. 다른 서버들이 LoadBalancer.RegisterServer() 호출
5. ConsistentHashRing에 가상 노드 추가

### 노드 제거 (정상)
1. ServiceDiscovery.Unregister() 호출
2. Redis에서 서버 정보 삭제
3. pvp:server:events에 removed 이벤트 발행
4. 다른 서버들이 LoadBalancer.UnregisterServer() 호출

### 노드 제거 (비정상)
1. 하트비트 중단 → Redis TTL 만료
2. HealthChecker가 failure count 증가
3. threshold 초과 시 OnServerUnhealthy 콜백
4. LoadBalancer.MarkServerHealthy(false)

## 테스트 전략

### 단위 테스트
- ConsistentHashRing 분배 균일성 (표준편차 < 10%)
- 노드 추가/제거 시 최소 재할당 (< 1/N)
- LoadBalancer 전략별 동작

### 통합 테스트
- ServiceDiscovery 등록/발견
- 하트비트 정상 동작
- 서버 장애 시 페일오버

## 성능 목표

| 메트릭 | 목표 |
|--------|------|
| GetNode 조회 | < 1μs |
| 노드 추가 | < 1ms |
| 노드 제거 | < 1ms |
| 하트비트 주기 | 5초 |
| 장애 탐지 | < 20초 |
