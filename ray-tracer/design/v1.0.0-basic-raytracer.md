# 기본 레이 트레이서 설계 일지 (v1.0)
> "Ray Tracing in One Weekend" 기반의 물리 기반 렌더링 엔진 구현 기록

## 1. 문제 정의 & 요구사항

### 1.1 목표

물리 기반 렌더링(PBR)의 기초가 되는 레이 트레이싱 엔진을 C++17로 구현한다:
- 광선의 경로를 역추적(backward tracing)하여 사실적인 이미지 생성
- 다양한 재질(확산, 금속, 유전체)의 광학적 특성 시뮬레이션
- 카메라 시스템 및 안티앨리어싱을 통한 고품질 렌더링

동시에 **테스트 프레임워크와 CI/CD 파이프라인을 확립**하여 이후 모든 Phase의 기준으로 삼는다.

### 1.2 기능 요구사항

#### 1.2.1 핵심 수학 라이브러리 (`Vec3`)
1. **데이터 구조**
   - `double e[3]`: 3차원 좌표/색상을 배열로 저장
   - `Point3`, `Color`: Vec3의 type alias로 의미 명확화

2. **벡터 연산**
   - 기본 연산: `+`, `-`, `*`, `/`, 단항 `-`
   - 내적: `dot(u, v)` → $\vec{u} \cdot \vec{v} = u_x v_x + u_y v_y + u_z v_z$
   - 외적: `cross(u, v)` → $\vec{u} \times \vec{v}$
   - 정규화: `unitVector(v)` → $\hat{v} = \frac{\vec{v}}{|\vec{v}|}$

3. **유틸리티**
   - `nearZero()`: 임계값 `1e-8` 이하인지 판별 (부동소수점 안전)
   - `random()`, `random(min, max)`: 랜덤 벡터 생성

#### 1.2.2 광선 (`Ray`)
광선의 파라메트릭 표현:
$$P(t) = \text{origin} + t \cdot \text{direction}$$

```cpp
class Ray {
    Point3 orig;
    Vec3 dir;
    double tm;  // 시간 (Motion blur용, Phase 2에서 사용)
    
    Point3 at(double t) const { return orig + t * dir; }
};
```

#### 1.2.3 객체 시스템 (`Hittable`)
모든 렌더링 가능 객체의 인터페이스:
```cpp
struct HitRecord {
    Point3 p;           // 충돌 지점
    Vec3 normal;        // 법선 벡터 (항상 광선 반대 방향)
    shared_ptr<Material> mat;
    double t;           // 광선 파라미터
    double u, v;        // 텍스처 좌표 (Phase 2에서 사용)
    bool frontFace;     // 앞면 충돌 여부
};

class Hittable {
    virtual bool hit(const Ray& r, double tMin, double tMax, HitRecord& rec) const = 0;
    virtual bool boundingBox(double time0, double time1, AABB& outputBox) const = 0;
};
```

#### 1.2.4 재질(Material) 시스템
모든 재질이 구현해야 할 인터페이스:
```cpp
class Material {
    virtual bool scatter(
        const Ray& rIn, const HitRecord& rec, 
        Color& attenuation, Ray& scattered
    ) const;
    
    virtual Color emitted(double u, double v, const Point3& p) const;
};
```

**재질 종류:**
- `Lambertian`: 난반사 표면
- `Metal`: 정반사 표면 (fuzz 파라미터로 거칠기 조절)
- `Dielectric`: 굴절 표면 (유리, 물 등)

#### 1.2.5 카메라 (`Camera`)
설정 가능한 파라미터:
| 파라미터 | 타입 | 기본값 | 설명 |
|---------|------|--------|------|
| `aspectRatio` | double | 16/9 | 이미지 종횡비 |
| `imageWidth` | int | 400 | 가로 픽셀 수 |
| `samplesPerPixel` | int | 10 | 안티앨리어싱 샘플 수 |
| `maxDepth` | int | 10 | 최대 광선 반사 깊이 |
| `vfov` | double | 90 | 수직 시야각 (도) |
| `lookfrom` | Point3 | (0,0,0) | 카메라 위치 |
| `lookat` | Point3 | (0,0,-1) | 시선 목표점 |
| `vup` | Vec3 | (0,1,0) | 상향 벡터 |
| `defocusAngle` | double | 0 | 피사계 심도용 렌즈 크기 |
| `focusDist` | double | 10 | 초점 거리 |

### 1.3 비기능 요구사항

#### 1.3.1 성능
- 400×225 이미지, 10 SPP: < 10초 (단일 스레드)
- 메모리: 이미지당 ~3MB (double precision RGB)

#### 1.3.2 코드 품질
- Google Test 기반 단위 테스트
- clang-format 스타일 일관성
- GitHub Actions CI/CD 파이프라인

#### 1.3.3 확장성
- Phase 2/3에서 BVH, 텍스처, PDF 시스템 추가 가능한 구조
- `shared_ptr`를 통한 유연한 객체 관리

---

## 2. 기술적 배경 & 설계 동기

### 2.1 왜 역방향 레이 트레이싱인가?

**순방향 (Forward) 레이 트레이싱의 한계:**
- 광원에서 광선을 쏘면 대부분 카메라에 도달하지 않음
- 계산 효율이 매우 낮음

**역방향 (Backward) 레이 트레이싱의 장점:**
- 카메라에서 광선을 쏘아 반드시 이미지에 기여
- 픽셀당 필요한 광선 수만 추적
- 실제 빛의 가역성(reciprocity) 원리 활용

### 2.2 왜 재귀적 구조인가?

```
Camera → Object A (반사) → Object B (반사) → Object C (산란) → 배경
```

광선이 물체에 부딪힐 때마다:
1. 해당 재질에 따라 산란(scatter) 또는 흡수
2. 산란된 새 광선에 대해 재귀 호출
3. 결과 색상에 감쇠율(attenuation) 적용

**깊이 제한 필요:**
- 무한 반사 방지 (`maxDepth`)
- 거울 사이에 갇힌 광선 등

### 2.3 법선 벡터와 면 방향

```cpp
void setFaceNormal(const Ray& r, const Vec3& outwardNormal) {
    frontFace = dot(r.direction(), outwardNormal) < 0;
    normal = frontFace ? outwardNormal : -outwardNormal;
}
```

**설계 결정:**
- 법선 벡터는 항상 광선의 반대 방향을 향함
- `frontFace` 플래그로 앞면/뒷면 구분
- 굴절 계산 시 필수 (유리 내부 vs 외부)

---

## 3. 구체 교차 판정 알고리즘

### 3.1 수학적 유도

구의 방정식: $(P - C) \cdot (P - C) = r^2$

광선을 대입: $P(t) = O + td$

전개:
$$t^2 d \cdot d + 2t d \cdot (O - C) + (O - C) \cdot (O - C) - r^2 = 0$$

이차 방정식 $at^2 + bt + c = 0$ 형태로:
- $a = d \cdot d = |d|^2$
- $b = 2d \cdot (O - C)$
- $c = (O - C) \cdot (O - C) - r^2$

### 3.2 최적화된 구현

```cpp
bool Sphere::hit(const Ray& r, double tMin, double tMax, HitRecord& rec) const {
    Vec3 oc = center - r.origin();  // 방향 반전으로 부호 단순화
    auto a = r.direction().lengthSquared();
    auto h = dot(r.direction(), oc);  // b = 2h로 치환
    auto c = oc.lengthSquared() - radius * radius;
    auto discriminant = h * h - a * c;  // b²-4ac = 4(h²-ac)

    if (discriminant < 0) return false;

    auto sqrtd = std::sqrt(discriminant);
    auto root = (h - sqrtd) / a;  // 가까운 근 먼저
    if (root <= tMin || tMax <= root) {
        root = (h + sqrtd) / a;  // 먼 근 시도
        if (root <= tMin || tMax <= root)
            return false;
    }
    // ... HitRecord 채우기
}
```

**최적화 포인트:**
- $b = 2h$ 치환으로 2 곱셈 제거
- `lengthSquared()` 사용으로 sqrt 호출 최소화
- 가까운 근 먼저 검사하여 조기 반환

---

## 4. 재질별 산란 로직

### 4.1 Lambertian (확산)

```cpp
bool Lambertian::scatter(...) const {
    auto scatterDirection = rec.normal + randomUnitVector();
    
    // 퇴화 케이스: 랜덤 벡터가 법선과 정반대
    if (scatterDirection.nearZero())
        scatterDirection = rec.normal;
    
    scattered = Ray(rec.p, scatterDirection);
    attenuation = albedo->value(rec.u, rec.v, rec.p);
    return true;
}
```

**원리:**
- 반구 내 코사인 분포를 따르는 산란
- `normal + randomUnitVector()`가 이를 근사
- 에너지 보존: `attenuation`으로 감쇠

### 4.2 Metal (정반사)

```cpp
bool Metal::scatter(...) const {
    Vec3 reflected = reflect(unitVector(rIn.direction()), rec.normal);
    scattered = Ray(rec.p, reflected + fuzz * randomInUnitSphere());
    attenuation = albedo;
    return (dot(scattered.direction(), rec.normal) > 0);
}
```

**반사 공식:**
$$\vec{r} = \vec{d} - 2(\vec{d} \cdot \vec{n})\vec{n}$$

**Fuzz 파라미터:**
- `fuzz = 0`: 완벽한 거울
- `fuzz = 1`: 거의 확산에 가까움
- 반사 벡터에 랜덤 섭동 추가

### 4.3 Dielectric (굴절)

```cpp
bool Dielectric::scatter(...) const {
    double ri = rec.frontFace ? (1.0 / refractionIndex) : refractionIndex;
    
    Vec3 unitDirection = unitVector(rIn.direction());
    double cosTheta = fmin(dot(-unitDirection, rec.normal), 1.0);
    double sinTheta = sqrt(1.0 - cosTheta * cosTheta);

    bool cannotRefract = ri * sinTheta > 1.0;  // 전반사 조건
    Vec3 direction;

    if (cannotRefract || reflectance(cosTheta, ri) > randomDouble())
        direction = reflect(unitDirection, rec.normal);
    else
        direction = refract(unitDirection, rec.normal, ri);

    scattered = Ray(rec.p, direction);
    return true;
}
```

**Snell의 법칙:**
$$\eta \sin\theta = \eta' \sin\theta'$$

**Schlick 근사 (반사율):**
$$R(\theta) = R_0 + (1 - R_0)(1 - \cos\theta)^5$$
$$R_0 = \left(\frac{\eta - \eta'}{\eta + \eta'}\right)^2$$

---

## 5. 카메라 시스템 설계

### 5.1 좌표계 구성

```cpp
void Camera::initialize() {
    // 카메라 좌표계 (u, v, w)
    w = unitVector(lookfrom - lookat);  // 뒤쪽
    u = unitVector(cross(vup, w));       // 오른쪽
    v = cross(w, u);                     // 위쪽

    // 뷰포트 크기
    auto theta = degreesToRadians(vfov);
    auto h = tan(theta / 2);
    auto viewportHeight = 2 * h * focusDist;
    auto viewportWidth = viewportHeight * aspectRatio;

    // 픽셀 델타
    pixelDeltaU = viewportWidth * u / imageWidth;
    pixelDeltaV = viewportHeight * -v / imageHeight;
}
```

### 5.2 Defocus Blur (피사계 심도)

```cpp
Point3 Camera::defocusDiskSample() const {
    auto p = randomInUnitDisk();
    return center + (p[0] * defocusDiskU) + (p[1] * defocusDiskV);
}

Ray Camera::getRay(int i, int j) const {
    auto offset = sampleSquare();  // 안티앨리어싱용 서브픽셀 오프셋
    auto pixelSample = pixel00Loc + ((i + offset.x()) * pixelDeltaU)
                                   + ((j + offset.y()) * pixelDeltaV);
    
    auto rayOrigin = (defocusAngle <= 0) ? center : defocusDiskSample();
    auto rayDirection = pixelSample - rayOrigin;
    
    return Ray(rayOrigin, rayDirection, randomDouble());  // 시간 랜덤
}
```

**원리:**
- 핀홀 카메라 대신 원판(disk) 렌즈 사용
- 초점 평면에서만 선명, 나머지는 흐림
- `defocusAngle`로 렌즈 크기 조절

---

## 6. 렌더링 파이프라인

### 6.1 메인 루프

```cpp
void Camera::render(const Hittable& world) {
    initialize();
    
    std::cout << "P3\n" << imageWidth << ' ' << imageHeight << "\n255\n";

    for (int j = 0; j < imageHeight; j++) {
        std::clog << "\rScanlines remaining: " << (imageHeight - j) << ' ' << std::flush;
        for (int i = 0; i < imageWidth; i++) {
            Color pixelColor(0, 0, 0);
            for (int sample = 0; sample < samplesPerPixel; sample++) {
                Ray r = getRay(i, j);
                pixelColor += rayColor(r, maxDepth, world);
            }
            writeColor(std::cout, pixelSamplesScale * pixelColor);
        }
    }
}
```

### 6.2 재귀적 광선 추적 (`rayColor`)

```cpp
Color Camera::rayColor(const Ray& r, int depth, const Hittable& world) const {
    if (depth <= 0)
        return Color(0, 0, 0);  // 반사 한도 초과

    HitRecord rec;
    if (!world.hit(r, 0.001, INFINITY_VAL, rec))
        return background;  // 배경색

    Ray scattered;
    Color attenuation;
    Color colorFromEmission = rec.mat->emitted(rec.u, rec.v, rec.p);

    if (!rec.mat->scatter(r, rec, attenuation, scattered))
        return colorFromEmission;  // 발광만 (광원)

    Color colorFromScatter = attenuation * rayColor(scattered, depth - 1, world);
    return colorFromEmission + colorFromScatter;
}
```

**Shadow Acne 방지:**
- `tMin = 0.001` 사용
- 부동소수점 오차로 인한 자기 충돌 방지

---

## 7. 검증 전략

### 7.1 유닛 테스트

**대상**: Google Test 기반

1. **벡터 연산**
   ```cpp
   TEST(Vec3Test, DotProduct) {
       Vec3 a(1, 2, 3), b(4, 5, 6);
       EXPECT_DOUBLE_EQ(dot(a, b), 32.0);  // 1*4 + 2*5 + 3*6
   }
   ```

2. **광선-구 교차**
   ```cpp
   TEST(SphereTest, RayHitsSphere) {
       Sphere s(Point3(0, 0, -1), 0.5, nullptr);
       Ray r(Point3(0, 0, 0), Vec3(0, 0, -1));
       HitRecord rec;
       EXPECT_TRUE(s.hit(r, 0.001, INFINITY_VAL, rec));
       EXPECT_NEAR(rec.t, 0.5, 1e-6);
   }
   ```

3. **재질 산란**
   ```cpp
   TEST(LambertianTest, AlwaysScatters) {
       Lambertian mat(Color(0.5, 0.5, 0.5));
       // scatter()가 항상 true 반환 확인
   }
   ```

### 7.2 시각적 검증

| 테스트 씬 | 검증 항목 |
|----------|----------|
| Three Spheres | Lambertian, Metal, Dielectric 각각 동작 |
| Random Spheres | 대규모 씬 렌더링 안정성 |
| Defocus Blur | 피사계 심도 효과 |

---

## 8. 성능 예산

**400×225 이미지, 10 SPP 기준:**

| 단계 | 예상 시간 | 비고 |
|------|----------|------|
| 픽셀당 광선 생성 | ~0.1µs | getRay() 호출 |
| 광선-구 교차 (N개) | ~N × 0.5µs | 선형 탐색 |
| 재질 산란 계산 | ~0.3µs | 랜덤 벡터 생성 포함 |
| 재귀 호출 (깊이 D) | ~D × 위 | maxDepth까지 |

**총 예상**: ~5-10초 (단일 스레드, O(N) 교차 판정)

Phase 2에서 BVH 도입 시 O(log N)으로 개선 예정.

---

## 9. 이후 버전과의 연결

### v1.0에서 확립된 것
- Vec3, Ray, Camera 핵심 클래스
- Hittable/Material 인터페이스
- 기본 재질 3종 (Lambertian, Metal, Dielectric)
- PPM 이미지 출력

### v2.0에서 추가될 것
- BVH (Bounding Volume Hierarchy)로 교차 판정 최적화
- 텍스처 시스템 (Solid, Checker, Perlin Noise)
- Motion Blur, Quad, Volume 렌더링

### v3.0에서 추가될 것
- 몬테카를로 적분 프레임워크
- PDF 기반 중요도 샘플링
- MixturePDF로 노이즈 감소

---

## 10. 알려진 제약 & 향후 개선점

### 10.1 현재 제약

1. **단일 스레드**: 멀티코어 활용 없음
   - 개선: 스캔라인별 또는 타일별 병렬화

2. **선형 교차 판정**: O(N) 복잡도
   - 개선: Phase 2에서 BVH 도입

3. **고정 샘플 수**: 적응형 샘플링 없음
   - 개선: 노이즈 기반 적응형 SPP

4. **감마 보정 단순화**: 고정 감마 2.0 사용
   - 개선: sRGB 정확한 변환

### 10.2 확장 가능성

- **삼각형 메시**: 3D 모델 렌더링 지원
- **환경 맵**: HDR 배경 조명
- **서브서피스 스캐터링**: 피부, 대리석 등

---

## 11. 체크리스트 (v1.0 완료 기준)

- [x] `Vec3` 클래스 및 유틸리티 함수 구현
- [x] `Ray` 클래스 구현
- [x] `Sphere::hit()` 최적화된 교차 판정 구현
- [x] `HitRecord`, `Hittable` 인터페이스 정의
- [x] `Lambertian`, `Metal`, `Dielectric` 재질 구현
- [x] `Camera` 클래스 (vfov, defocus blur 포함)
- [x] 안티앨리어싱 (다중 샘플링)
- [x] PPM 이미지 출력
- [x] Google Test 기반 유닛 테스트
- [x] GitHub Actions CI/CD 설정
- [x] Three Spheres / Random Spheres 씬 렌더링 확인
