# 몬테카를로 적분 & 중요도 샘플링 설계 일지 (v3.0)
> "Ray Tracing: The Rest of Your Life" 기반의 물리 정확 렌더링 및 분산 감소 구현 기록

## 1. 문제 정의 & 요구사항

### 1.1 v2.0의 한계

v2.0에서는 **균일 샘플링 (Uniform Sampling)**:
```cpp
// v2.0 Lambertian scatter
auto scatterDirection = rec.normal + randomUnitVector();
```

**문제점:**
- 광원이 작거나 멀리 있으면 대부분의 광선이 광원을 맞히지 못함
- 결과: **높은 분산(Variance) = 노이즈**
- 동일 품질을 위해 SPP(Samples Per Pixel)를 크게 늘려야 함

**Cornell Box 예시:**
```
광원 면적: 130×105 = 13,650 단위²
전체 반구: 2π × 278² ≈ 485,466 단위²
광원 히트 확률: ~2.8%
```

97%의 샘플이 광원에 기여하지 못하고 낭비됨.

### 1.2 목표

#### 1.2.1 몬테카를로 적분 프레임워크
- 확률 밀도 함수(PDF) 기반의 엄밀한 렌더링 방정식 적분
- 분산 감소를 위한 중요도 샘플링(Importance Sampling)

#### 1.2.2 성능 목표
- 동일 SPP 대비 **분산 4~5배 감소**
- 또는 동일 품질 대비 **SPP 1/4~1/5로 단축**

#### 1.2.3 구현 범위
- PDF 인터페이스 및 다양한 구현체
- ONB (정규 직교 기저) 시스템
- 재질 시스템 확장 (`ScatterRecord`, `scatteringPdf`)
- 광원 직접 샘플링

### 1.3 비기능 요구사항

#### 1.3.1 성능
- PDF 계산 오버헤드: 광선당 < 1µs
- MixturePDF 샘플링: 50:50 분배

#### 1.3.2 정확성
- PDF 정규화: 반구 적분 = 1
- 에너지 보존: 산란 후 색상 ≤ 입사 색상

---

## 2. 기술적 배경 & 설계 동기

### 2.1 렌더링 방정식 (Rendering Equation)

카메라 방향 $\omega_o$로 나가는 빛의 양:
$$L_o(p, \omega_o) = L_e(p, \omega_o) + \int_{\Omega} f_r(p, \omega_i, \omega_o) L_i(p, \omega_i) |\omega_i \cdot n| d\omega_i$$

**항목 설명:**
- $L_e$: 자체 발광 (광원)
- $f_r$: BRDF (양방향 반사 분포 함수)
- $L_i$: 입사광
- $|\omega_i \cdot n| = \cos\theta$: 기하 항

### 2.2 몬테카를로 적분

적분을 확률적으로 추정:
$$\int f(x) dx \approx \frac{1}{N} \sum_{i=1}^{N} \frac{f(x_i)}{p(x_i)}$$

**렌더링에 적용:**
$$L_o \approx L_e + \frac{1}{N} \sum \frac{f_r \cdot L_i \cdot \cos\theta}{p(\omega_i)}$$

### 2.3 중요도 샘플링 (Importance Sampling)

**핵심 아이디어:**
- $p(\omega)$가 피적분 함수와 비슷하면 분산이 줄어듦
- 이상적: $p(\omega) \propto f_r \cdot L_i \cdot \cos\theta$

**실용적 전략:**
1. **BRDF 샘플링**: $p(\omega) \propto f_r \cdot \cos\theta$
   - Lambertian: $p(\omega) = \cos\theta / \pi$ (CosinePDF)
2. **광원 샘플링**: $p(\omega) \propto$ 광원 방향으로 집중
   - 광원을 향하는 방향만 샘플 (HittablePDF)
3. **혼합 전략**: 두 PDF를 결합 (MixturePDF)
   - 50% BRDF + 50% 광원

---

## 3. PDF 시스템 설계

### 3.1 인터페이스

```cpp
class PDF {
public:
    virtual ~PDF() = default;
    
    // 주어진 방향의 PDF 값 계산
    virtual double value(const Vec3& direction) const = 0;
    
    // PDF에 따라 랜덤 방향 생성
    virtual Vec3 generate() const = 0;
};
```

### 3.2 CosinePDF (BRDF 샘플링)

Lambertian 표면에 적합한 코사인 분포:
$$p(\omega) = \frac{\cos\theta}{\pi}$$

```cpp
class CosinePDF : public PDF {
    ONB uvw;
    
public:
    CosinePDF(const Vec3& w) {
        uvw.buildFromW(w);
    }
    
    double value(const Vec3& direction) const override {
        auto cosineTheta = dot(unitVector(direction), uvw.w());
        return fmax(0, cosineTheta / PI);
    }
    
    Vec3 generate() const override {
        return uvw.local(randomCosineDirection());
    }
};
```

**`randomCosineDirection()` 구현:**
```cpp
Vec3 randomCosineDirection() {
    auto r1 = randomDouble();
    auto r2 = randomDouble();
    
    auto phi = 2 * PI * r1;
    auto x = cos(phi) * sqrt(r2);
    auto y = sin(phi) * sqrt(r2);
    auto z = sqrt(1 - r2);
    
    return Vec3(x, y, z);
}
```

### 3.3 HittablePDF (광원 샘플링)

특정 객체(광원)를 향하는 방향 샘플링:

```cpp
class HittablePDF : public PDF {
    const Hittable& objects;
    Point3 origin;
    
public:
    HittablePDF(const Hittable& objects, const Point3& origin)
        : objects(objects), origin(origin) {}
    
    double value(const Vec3& direction) const override {
        return objects.pdfValue(origin, direction);
    }
    
    Vec3 generate() const override {
        return objects.random(origin);
    }
};
```

**Sphere의 PDF 구현:**
```cpp
double Sphere::pdfValue(const Point3& origin, const Vec3& direction) const {
    HitRecord rec;
    if (!this->hit(Ray(origin, direction), 0.001, INFINITY, rec))
        return 0;
    
    // 구가 보이는 입체각 계산
    auto cosThetaMax = sqrt(1 - radius*radius / (center - origin).lengthSquared());
    auto solidAngle = 2 * PI * (1 - cosThetaMax);
    
    return 1 / solidAngle;
}

Vec3 Sphere::random(const Point3& origin) const {
    Vec3 direction = center - origin;
    auto distanceSquared = direction.lengthSquared();
    ONB uvw;
    uvw.buildFromW(direction);
    return uvw.local(randomToSphere(radius, distanceSquared));
}
```

### 3.4 MixturePDF (혼합 전략)

두 PDF를 50:50으로 혼합:

```cpp
class MixturePDF : public PDF {
    shared_ptr<PDF> p[2];
    
public:
    MixturePDF(shared_ptr<PDF> p0, shared_ptr<PDF> p1)
        : p{p0, p1} {}
    
    double value(const Vec3& direction) const override {
        return 0.5 * p[0]->value(direction) + 0.5 * p[1]->value(direction);
    }
    
    Vec3 generate() const override {
        if (randomDouble() < 0.5)
            return p[0]->generate();
        else
            return p[1]->generate();
    }
};
```

---

## 4. ONB (정규 직교 기저) 시스템

### 4.1 구현

```cpp
class ONB {
    Vec3 axis[3];  // u, v, w
    
public:
    void buildFromW(const Vec3& w) {
        axis[2] = unitVector(w);
        Vec3 a = (fabs(axis[2].x()) > 0.9) ? Vec3(0, 1, 0) : Vec3(1, 0, 0);
        axis[1] = unitVector(cross(axis[2], a));
        axis[0] = cross(axis[2], axis[1]);
    }
    
    Vec3 local(double a, double b, double c) const {
        return a * u() + b * v() + c * w();
    }
    
    Vec3 local(const Vec3& a) const {
        return a.x() * u() + a.y() * v() + a.z() * w();
    }
};
```

**설계 포인트:**
- `w`가 (0, 1, 0)에 가까우면 `a = (1, 0, 0)` 사용 (수치 안정성)
- 로컬 좌표 → 월드 좌표 변환

---

## 5. 재질 시스템 확장

### 5.1 ScatterRecord

```cpp
struct ScatterRecord {
    Color attenuation;           // 감쇠율 (Albedo)
    shared_ptr<PDF> pdfPtr;      // 산란 PDF (Diffuse용)
    bool skipPdf;                // PDF 생략 여부 (Specular용)
    Ray skipPdfRay;              // PDF 생략 시 사용할 광선
};
```

### 5.2 Material 확장

```cpp
class Material {
public:
    // 기존 scatter (호환성)
    virtual bool scatter(const Ray& rIn, const HitRecord& rec,
                         Color& attenuation, Ray& scattered) const;
    
    // 새로운 scatter (PDF 기반)
    virtual bool scatter(const Ray& rIn, const HitRecord& rec,
                         ScatterRecord& srec) const;
    
    // 산란 PDF 값 계산
    virtual double scatteringPdf(const Ray& rIn, const HitRecord& rec,
                                  const Ray& scattered) const;
    
    // 발광 색상
    virtual Color emitted(double u, double v, const Point3& p) const;
};
```

### 5.3 Lambertian (PDF 버전)

```cpp
bool Lambertian::scatter(const Ray& rIn, const HitRecord& rec,
                         ScatterRecord& srec) const {
    srec.attenuation = albedo->value(rec.u, rec.v, rec.p);
    srec.pdfPtr = make_shared<CosinePDF>(rec.normal);
    srec.skipPdf = false;
    return true;
}

double Lambertian::scatteringPdf(const Ray& rIn, const HitRecord& rec,
                                  const Ray& scattered) const {
    auto cosine = dot(rec.normal, unitVector(scattered.direction()));
    return cosine < 0 ? 0 : cosine / PI;
}
```

### 5.4 Metal/Dielectric (Specular)

```cpp
bool Dielectric::scatter(const Ray& rIn, const HitRecord& rec,
                         ScatterRecord& srec) const {
    srec.attenuation = Color(1, 1, 1);
    srec.pdfPtr = nullptr;
    srec.skipPdf = true;  // Delta 분포, PDF 샘플링 불필요
    
    // 굴절 또는 반사 계산
    srec.skipPdfRay = Ray(rec.p, direction);
    return true;
}
```

---

## 6. 수정된 렌더링 파이프라인

### 6.1 rayColor (중요도 샘플링 버전)

```cpp
Color Camera::rayColor(const Ray& r, int depth, 
                       const Hittable& world, const Hittable& lights) const {
    if (depth <= 0)
        return Color(0, 0, 0);

    HitRecord rec;
    if (!world.hit(r, 0.001, INFINITY, rec))
        return background;

    ScatterRecord srec;
    Color colorFromEmission = rec.mat->emitted(rec.u, rec.v, rec.p);

    if (!rec.mat->scatter(r, rec, srec))
        return colorFromEmission;

    // Specular 재질: PDF 없이 직접 추적
    if (srec.skipPdf) {
        return srec.attenuation * rayColor(srec.skipPdfRay, depth - 1, world, lights);
    }

    // Diffuse 재질: MixturePDF 사용
    auto lightPtr = make_shared<HittablePDF>(lights, rec.p);
    MixturePDF mixedPdf(lightPtr, srec.pdfPtr);

    Ray scattered = Ray(rec.p, mixedPdf.generate(), r.time());
    auto pdfValue = mixedPdf.value(scattered.direction());
    double scatteringPdf = rec.mat->scatteringPdf(r, rec, scattered);

    Color colorFromScatter = (srec.attenuation * scatteringPdf 
                              * rayColor(scattered, depth - 1, world, lights)) 
                              / pdfValue;

    return colorFromEmission + colorFromScatter;
}
```

### 6.2 Camera::render (광원 전달)

```cpp
void Camera::render(const Hittable& world, const Hittable& lights) {
    initialize();
    
    for (int j = 0; j < imageHeight; j++) {
        for (int i = 0; i < imageWidth; i++) {
            Color pixelColor(0, 0, 0);
            for (int sample = 0; sample < samplesPerPixel; sample++) {
                Ray r = getRay(i, j);
                pixelColor += rayColor(r, maxDepth, world, lights);
            }
            writeColor(std::cout, pixelSamplesScale * pixelColor);
        }
    }
}
```

---

## 7. 검증 전략

### 7.1 유닛 테스트

1. **PDF 정규화**
   ```cpp
   TEST(CosinePDFTest, IntegratesTo1) {
       CosinePDF pdf(Vec3(0, 0, 1));
       double integral = 0;
       for (int i = 0; i < 10000; i++) {
           auto dir = pdf.generate();
           integral += 1.0 / pdf.value(dir);
       }
       EXPECT_NEAR(integral / 10000.0, 2 * PI, 0.1);  // 반구
   }
   ```

2. **ONB 직교성**
   ```cpp
   TEST(ONBTest, IsOrthonormal) {
       ONB uvw;
       uvw.buildFromW(Vec3(1, 2, 3));
       EXPECT_NEAR(dot(uvw.u(), uvw.v()), 0, 1e-6);
       EXPECT_NEAR(dot(uvw.v(), uvw.w()), 0, 1e-6);
       EXPECT_NEAR(uvw.u().length(), 1, 1e-6);
   }
   ```

3. **분산 감소 확인**
   ```cpp
   TEST(ImportanceSamplingTest, ReducesVariance) {
       auto variance_uniform = measureVariance(renderWithUniform);
       auto variance_importance = measureVariance(renderWithImportance);
       EXPECT_LT(variance_importance, variance_uniform / 3);
   }
   ```

### 7.2 시각적 비교

| 씬 | v2.0 (400 SPP) | v3.0 (100 SPP) |
|----|----------------|----------------|
| Cornell Box | 노이즈 많음 | 동등한 품질 |
| Simple Light | 광원 노이즈 | 깨끗 |

---

## 8. 성능 예산

### 8.1 PDF 계산 오버헤드

| 연산 | 예상 시간 |
|------|----------|
| CosinePDF::generate | ~0.2µs |
| CosinePDF::value | ~0.1µs |
| HittablePDF::generate | ~0.3µs |
| HittablePDF::value | ~0.5µs (hit test 포함) |
| MixturePDF 전체 | ~0.8µs |

**결론:** 광선당 ~1µs 추가. BVH 탐색 시간에 비해 무시 가능.

### 8.2 분산 감소 효과

**Cornell Box (600×600, 200 SPP):**

| 버전 | 렌더 시간 | 노이즈 레벨 |
|------|----------|------------|
| v2.0 | ~120s | 높음 |
| v3.0 | ~130s (+8%) | **4~5배 낮음** |

**동일 노이즈 레벨 달성 시:**
- v2.0: 800 SPP 필요
- v3.0: 200 SPP 충분
- **4배 속도 향상**

---

## 9. 이후 버전과의 연결 (확장 가능성)

### v3.0에서 확립된 것
- PDF 인터페이스 및 구현체들
- ONB 시스템
- ScatterRecord 구조체
- MixturePDF 혼합 전략

### 추가 확장 가능성
- **MIS (Multiple Importance Sampling)**: 가중치 최적화
- **환경 맵 샘플링**: HDR 배경을 광원으로 취급
- **Russian Roulette**: 깊이 무한 재귀 대신 확률적 종료
- **BSSRDF**: 서브서피스 스캐터링 PDF

---

## 10. 알려진 제약 & 향후 개선점

### 10.1 현재 제약

1. **고정 혼합 비율**: 50:50 하드코딩
   - 개선: 장면 특성에 따른 적응형 비율

2. **단일 광원**: 하나의 lights 객체만 전달
   - 개선: 다중 광원 가중 샘플링

3. **Quad PDF 단순**: 균일 분포만
   - 개선: 거리/각도 기반 가중치

4. **Specular MIS 미적용**: Delta 분포 특수 처리
   - 개선: 거친 Specular에 대한 MIS

### 10.2 이론적 한계

- 인과율 위반 불가: 빛은 항상 광원에서 시작
- 에너지 보존: 산란 후 에너지 증가 불가
- PDF > 0 필수: 0으로 나눔 방지

---

## 11. 체크리스트 (v3.0 완료 기준)

- [x] `PDF` 인터페이스 정의
- [x] `CosinePDF` 구현 및 정규화 검증
- [x] `SpherePDF` (균일 구 샘플링) 구현
- [x] `HittablePDF` 구현
- [x] `Sphere::pdfValue()`, `Sphere::random()` 구현
- [x] `Quad::pdfValue()`, `Quad::random()` 구현
- [x] `MixturePDF` 구현
- [x] `ONB` 클래스 구현 및 직교성 테스트
- [x] `ScatterRecord` 구조체 정의
- [x] `Material::scatter(srec)` 확장
- [x] `Material::scatteringPdf()` 구현
- [x] `Lambertian`, `Metal`, `Dielectric` PDF 버전 구현
- [x] `Camera::rayColor` 중요도 샘플링 버전 구현
- [x] `Camera::render(world, lights)` 오버로드 추가
- [x] Cornell Box 분산 감소 시각적 확인
- [x] PDF 유닛 테스트 (69개 테스트 통과)
