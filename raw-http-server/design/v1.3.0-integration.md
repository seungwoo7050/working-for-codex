# Complete Integration & Sample Application (Milestone 1.4)

> Bringing HTTP Server, Framework, and Connection Pool together into a production-ready application

## 1. Problem Definition & Requirements

### 1.1 Project Goal

**Objective**: Integrate all previous milestones into a complete, working application

**What We're Integrating**:
- âœ… Milestone 1.1: HTTP Server (sockets + thread pool)
- âœ… Milestone 1.2: Framework (routing + middleware + DI)
- âœ… Milestone 1.3: Connection Pool (resource management)

**Deliverable**: Production-ready mini-spring framework with sample REST API

### 1.2 Functional Requirements

1. **Complete Framework**
   - Declarative routing (`@app.route()`)
   - Middleware pipeline (logging, auth)
   - Dependency injection
   - Connection pooling

2. **Sample Application**
   - RESTful API (GET, POST endpoints)
   - In-memory database
   - Authentication middleware
   - CRUD operations

3. **Operational Readiness**
   - Graceful shutdown (signal handlers)
   - Health check endpoint
   - Logging configuration
   - Error handling

4. **Documentation**
   - README with quick start
   - API documentation
   - Architecture diagram
   - Comparison with Spring Boot

### 1.3 Success Criteria

- [ ] Sample app runs out of the box
- [ ] All REST endpoints functional
- [ ] Connection pool integrated with handlers
- [ ] Middleware executes correctly
- [ ] Graceful shutdown works (Ctrl+C)
- [ ] Code is portfolio-ready

---

## 2. System Architecture

### 2.1 Complete Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                mini-spring Framework v1.4                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

HTTP Request from Client
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 1: HTTP Server (Milestone 1.1)                         â”‚
â”‚   - Socket accept()                                          â”‚
â”‚   - ThreadPoolExecutor                                       â”‚
â”‚   - HTTP parsing                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 2: Framework Core (Milestone 1.2)                      â”‚
â”‚   - Route matching                                           â”‚
â”‚   - Middleware pipeline                                      â”‚
â”‚   â”‚   â”œâ”€ logging_middleware                                  â”‚
â”‚   â”‚   â””â”€ auth_middleware (route-specific)                    â”‚
â”‚   - DI container                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 3: Application Layer (Milestone 1.4)                   â”‚
â”‚   - Controllers (route handlers)                             â”‚
â”‚   â”‚   â”œâ”€ health_check()                                      â”‚
â”‚   â”‚   â”œâ”€ get_users()                                         â”‚
â”‚   â”‚   â”œâ”€ get_user(id)                                        â”‚
â”‚   â”‚   â””â”€ create_user()                                       â”‚
â”‚   - Middleware                                               â”‚
â”‚   â”‚   â””â”€ logging_middleware, auth_middleware                 â”‚
â”‚   - Database abstraction                                     â”‚
â”‚       â””â”€ InMemoryDatabase                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 4: Data Access (Milestone 1.3)                         â”‚
â”‚   - ConnectionPool                                           â”‚
â”‚   â”‚   â”œâ”€ Available Queue                                     â”‚
â”‚   â”‚   â”œâ”€ In-Use Set                                          â”‚
â”‚   â”‚   â””â”€ Leak Detector                                       â”‚
â”‚   - InMemoryDatabase                                         â”‚
â”‚       â””â”€ Connection factory                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
HTTP Response to Client
```

### 2.2 Module Structure

```
milestone-1.4/
â”œâ”€â”€ application.py          # App factory, DI setup
â”œâ”€â”€ controllers.py          # Route handlers
â”œâ”€â”€ database.py             # InMemoryDatabase + Connection
â”œâ”€â”€ middleware.py           # Custom middleware
â”œâ”€â”€ main.py                 # Entry point
â”œâ”€â”€ smoke_tests.py          # Basic sanity tests
â”‚
â””â”€â”€ _compat.py              # Path setup for importing milestone-1.2 and 1.3
```

---

## 3. Detailed Implementation

### 3.1 Application Factory

**File**: `application.py`

**Purpose**: Compose HTTP server, framework, and connection pool

```python
from framework.app import App
from pool.config import PoolConfig
from pool.connection_pool import ConnectionPool
from database import InMemoryDatabase
from middleware import logging_middleware
from controllers import register

def create_connection_pool(database: InMemoryDatabase) -> ConnectionPool:
    """Create configured connection pool."""
    config = PoolConfig(
        min_connections=2,
        max_connections=8,
        acquisition_timeout=2.0,
        leak_detection_threshold=30.0,
        connection_factory=database.create_connection
    )
    pool = ConnectionPool(config)
    LOGGER.info(
        "Initialized connection pool (min=%s, max=%s)",
        config.min_connections,
        config.max_connections
    )
    return pool

def create_app(*, host: str = "0.0.0.0", port: int = 8080) -> App:
    """Compose the complete mini-spring application."""
    # 1. Create framework instance
    app = App(host=host, port=port)

    # 2. Create dependencies
    database = InMemoryDatabase()
    pool = create_connection_pool(database)

    # 3. Register dependencies in DI container
    app.register_instance("database", database)
    app.register_instance("connection_pool", pool)

    # 4. Register global middleware
    app.use(logging_middleware)

    # 5. Register routes
    register(app)

    return app

def graceful_shutdown(app: App) -> Callable[[int, object], None]:
    """Return signal handler for graceful shutdown."""
    def _handler(_signum: int, _frame: object) -> None:
        LOGGER.info("Received shutdown signal")
        app.stop()

    return _handler
```

**Design Pattern**: Factory Pattern (Application Factory)

**Benefits**:
- Single responsibility (composition logic in one place)
- Testable (can create app with mock dependencies)
- Configurable (pass different port, database)

### 3.2 Controllers (Route Handlers)

**File**: `controllers.py`

```python
def register(app: App):
    """Register all route handlers."""

    @app.route("/health")
    def health(request):
        """Health check endpoint."""
        pool = request.app.resolve("connection_pool")
        return {
            "status": "up",
            "pool": {
                "total": pool.total_connections(),
                "in_use": pool.in_use(),
                "available": pool.available()
            }
        }

    @app.route("/users")
    def get_users(request):
        """List all users."""
        pool = request.app.resolve("connection_pool")
        with pool.acquire() as conn:
            users = conn.get_users()
        return {"users": [u.to_dict() for u in users]}

    @app.route("/users/{id}")
    def get_user(request, id):
        """Get user by ID."""
        pool = request.app.resolve("connection_pool")
        with pool.acquire() as conn:
            user = conn.get_user(id)

        if user is None:
            return Response.error("user_not_found", status=404)

        return {"user": user.to_dict()}

    @app.route("/users", methods=["POST"])
    def create_user(request):
        """Create new user."""
        data = request.json()

        if "name" not in data or "email" not in data:
            return Response.error("missing_fields", status=400)

        pool = request.app.resolve("connection_pool")
        with pool.acquire() as conn:
            user_id = conn.create_user(data["name"], data["email"])

        return Response(
            status=201,
            payload=json.dumps({"user_id": user_id}).encode(),
            headers={"Content-Type": "application/json"}
        )

    @app.route("/admin", middleware=[auth_middleware])
    def admin_panel(request):
        """Protected admin endpoint."""
        return {"message": "Welcome, admin!"}
```

**RESTful API Design**:

| Method | Path | Description | Auth |
|--------|------|-------------|------|
| GET | `/health` | Health check | No |
| GET | `/users` | List all users | No |
| GET | `/users/{id}` | Get user by ID | No |
| POST | `/users` | Create user | No |
| GET | `/admin` | Admin panel | Yes |

### 3.3 Database Abstraction

**File**: `database.py`

```python
@dataclass
class User:
    id: str
    name: str
    email: str

    def to_dict(self) -> Dict[str, str]:
        return {"id": self.id, "name": self.name, "email": self.email}

class Connection:
    """Database connection (supports close and is_valid)."""
    def __init__(self, database: "InMemoryDatabase"):
        self._database = database
        self._closed = False

    def get_users(self) -> List[User]:
        """Fetch all users."""
        if self._closed:
            raise RuntimeError("Connection closed")
        return list(self._database._users.values())

    def get_user(self, user_id: str) -> Optional[User]:
        """Fetch user by ID."""
        if self._closed:
            raise RuntimeError("Connection closed")
        return self._database._users.get(user_id)

    def create_user(self, name: str, email: str) -> str:
        """Create new user, return ID."""
        if self._closed:
            raise RuntimeError("Connection closed")
        user_id = str(uuid.uuid4())
        user = User(id=user_id, name=name, email=email)
        self._database._users[user_id] = user
        return user_id

    def is_valid(self, timeout: float) -> bool:
        """Health check (required by ConnectionPool)."""
        return not self._closed

    def close(self) -> None:
        """Close connection."""
        self._closed = True

class InMemoryDatabase:
    """In-memory database for demo purposes."""
    def __init__(self):
        self._users: Dict[str, User] = {}
        self._seed_data()

    def _seed_data(self):
        """Pre-populate with sample data."""
        self._users["1"] = User(id="1", name="Alice", email="alice@example.com")
        self._users["2"] = User(id="2", name="Bob", email="bob@example.com")

    def create_connection(self) -> Connection:
        """Factory for creating connections."""
        return Connection(self)
```

**Design Choices**:

1. **Connection Protocol**: Implements `close()` and `is_valid()`
   - Required by `ConnectionPool`
   - `is_valid()` checks if connection is still usable

2. **In-Memory Storage**: Dict-based for simplicity
   - Production would use PostgreSQL/MySQL
   - Same API (connection abstraction)

3. **UUID for IDs**: Auto-generated unique IDs
   - Prevents ID collision
   - Realistic for demos

### 3.4 Middleware

**File**: `middleware.py`

```python
def logging_middleware(request: Request, next_fn: Callable) -> Any:
    """Log HTTP requests and responses."""
    LOGGER.info("%s %s", request.method, request.path)
    start = time.time()

    response = next_fn(request)

    elapsed = time.time() - start
    status = response.status if isinstance(response, Response) else 200
    LOGGER.info("â†’ %s (%.2fms)", status, elapsed * 1000)

    return response

def auth_middleware(request: Request, next_fn: Callable) -> Any:
    """Require Bearer token authentication."""
    auth_header = request.headers.get("authorization")

    if not auth_header:
        return Response.error("unauthorized", status=401)

    if auth_header != "Bearer secrettoken":
        return Response.error("forbidden", status=403)

    return next_fn(request)
```

**Middleware Patterns**:

1. **Logging**: Records request/response
   - Useful for debugging
   - Performance monitoring

2. **Authentication**: Validates credentials
   - Returns 401/403 if unauthorized
   - Proceeds to handler if valid

### 3.5 Entry Point

**File**: `main.py`

```python
import signal
import logging
from application import create_app, graceful_shutdown

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
)

LOGGER = logging.getLogger(__name__)

def main():
    """Start mini-spring server."""
    app = create_app(host="0.0.0.0", port=8080)

    # Register signal handlers
    signal.signal(signal.SIGINT, graceful_shutdown(app))
    signal.signal(signal.SIGTERM, graceful_shutdown(app))

    LOGGER.info("Starting mini-spring on port 8080")
    LOGGER.info("Press Ctrl+C to stop")

    try:
        app.listen()
    except KeyboardInterrupt:
        LOGGER.info("Shutting down...")
    finally:
        LOGGER.info("Goodbye!")

if __name__ == "__main__":
    main()
```

**Features**:
- Signal handling (Ctrl+C graceful shutdown)
- Logging configuration
- Exception handling

---

## 4. Validation Strategy

### 4.1 Smoke Tests

**File**: `smoke_tests.py`

```python
def smoke_test():
    """Basic sanity checks."""
    base_url = "http://localhost:8080"

    # Test 1: Health check
    response = requests.get(f"{base_url}/health")
    assert response.status_code == 200
    assert response.json()["status"] == "up"
    print("âœ“ Health check passed")

    # Test 2: Get all users
    response = requests.get(f"{base_url}/users")
    assert response.status_code == 200
    users = response.json()["users"]
    assert len(users) >= 2
    print(f"âœ“ Found {len(users)} users")

    # Test 3: Get user by ID
    user_id = users[0]["id"]
    response = requests.get(f"{base_url}/users/{user_id}")
    assert response.status_code == 200
    assert response.json()["user"]["id"] == user_id
    print("âœ“ Get user by ID passed")

    # Test 4: Create user
    response = requests.post(
        f"{base_url}/users",
        json={"name": "Charlie", "email": "charlie@example.com"}
    )
    assert response.status_code == 201
    new_user_id = response.json()["user_id"]
    print(f"âœ“ Created user {new_user_id}")

    # Test 5: Auth required
    response = requests.get(f"{base_url}/admin")
    assert response.status_code == 401
    print("âœ“ Auth rejection works")

    # Test 6: Auth success
    response = requests.get(
        f"{base_url}/admin",
        headers={"Authorization": "Bearer secrettoken"}
    )
    assert response.status_code == 200
    print("âœ“ Auth success works")

    print("\nAll smoke tests passed! âœ“")
```

### 4.2 Manual Testing

**Step 1: Start Server**
```bash
$ python -m milestone-1.4.main

2025-11-27 10:00:00 [INFO] application: Initialized connection pool (min=2, max=8)
2025-11-27 10:00:00 [INFO] main: Starting mini-spring on port 8080
2025-11-27 10:00:00 [INFO] main: Press Ctrl+C to stop
2025-11-27 10:00:00 [INFO] framework.app: mini-spring listening on 0.0.0.0:8080
```

**Step 2: Test Endpoints**
```bash
# Health check
$ curl http://localhost:8080/health
{"status":"up","pool":{"total":2,"in_use":0,"available":2}}

# List users
$ curl http://localhost:8080/users
{"users":[{"id":"1","name":"Alice","email":"alice@example.com"},{"id":"2","name":"Bob","email":"bob@example.com"}]}

# Get user by ID
$ curl http://localhost:8080/users/1
{"user":{"id":"1","name":"Alice","email":"alice@example.com"}}

# Create user
$ curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name":"Charlie","email":"charlie@example.com"}'
{"user_id":"a1b2c3d4-..."}

# Test auth failure
$ curl http://localhost:8080/admin
{"error":"unauthorized"}

# Test auth success
$ curl -H "Authorization: Bearer secrettoken" http://localhost:8080/admin
{"message":"Welcome, admin!"}
```

**Step 3: Graceful Shutdown**
```bash
# Press Ctrl+C in server terminal

^C2025-11-27 10:05:00 [INFO] main: Received shutdown signal
2025-11-27 10:05:00 [INFO] main: Shutting down...
2025-11-27 10:05:00 [INFO] main: Goodbye!
```

### 4.3 Validation Checklist

- [x] Server starts on port 8080
- [x] Health endpoint returns pool stats
- [x] GET /users returns user list
- [x] GET /users/{id} returns specific user
- [x] POST /users creates new user (201)
- [x] Auth middleware blocks unauthorized requests
- [x] Auth middleware allows valid tokens
- [x] Connection pool reuses connections
- [x] Graceful shutdown works (Ctrl+C)
- [x] No resource leaks (connections closed)

---

## 5. Portfolio Documentation

### 5.1 README.md

```markdown
# mini-spring â€“ Web Framework from Scratch

Educational project demonstrating web framework internals.

## Quick Start

```bash
# Clone and run
git clone https://github.com/your-username/mini-spring.git
cd mini-spring
python -m milestone-1.4.main
```

## Features

- HTTP/1.1 server from raw sockets
- Decorator-based routing (`@app.route()`)
- Middleware pipeline
- Dependency injection
- Connection pooling

## API Documentation

| Method | Path | Description |
|--------|------|-------------|
| GET | `/health` | Health check |
| GET | `/users` | List users |
| GET | `/users/{id}` | Get user |
| POST | `/users` | Create user |

## Architecture

See [docs/architecture.md](docs/architecture.md)

## Comparison

See [docs/comparison.md](docs/comparison.md) for mini-spring vs Spring Boot
```

### 5.2 Evidence Documentation

**File**: `docs/evidence/m1.4/sample-app-walkthrough.md`

**Contents**:
1. Architecture diagram
2. Code snippets (key components)
3. API examples (curl commands)
4. Performance metrics
5. Screenshots (optional)

**File**: `docs/evidence/m1.4/integration-report.md`

**Contents**:
1. Integration points (framework + pool)
2. DI container usage
3. Middleware execution order
4. Connection pool metrics

---

## 6. Key Learnings

### 6.1 Integration Challenges

1. **Import Path Management**
   - Milestones 1.2 and 1.3 are separate packages
   - Solution: `_compat.py` for path setup

2. **DI Container Lifecycle**
   - Pool needs database reference
   - Solution: Factory pattern in `create_app()`

3. **Middleware Ordering**
   - Logging should run first
   - Auth runs per-route
   - Solution: Global vs route middleware

### 6.2 Production Readiness Lessons

1. **Health Checks are Critical**
   - Monitor pool status
   - Detect resource exhaustion early

2. **Graceful Shutdown Matters**
   - Close connections properly
   - Wait for in-flight requests

3. **Logging is Essential**
   - Debug request flow
   - Performance monitoring

---

## 7. Connection to Milestone 1.4.5

### Milestone 1.4 â†’ 1.4.5 Transition

**What We Have**:
- âœ… Complete mini-spring framework
- âœ… Working sample application
- âœ… All features integrated

**What's Next** (Milestone 1.4.5):
- ðŸ”² Re-implement same app in Spring Boot
- ðŸ”² 1:1 mapping table
- ðŸ”² Performance comparison
- ðŸ”² LOC reduction analysis

**Goal**: Demonstrate what Spring Boot abstracts away

**Example Comparison**:

| mini-spring (1.4) | Spring Boot (1.4.5) |
|-------------------|---------------------|
| ~950 lines total | ~150 lines total |
| Manual HTTP server | Embedded Tomcat (auto-config) |
| Manual DI container | `@Autowired` (auto-config) |
| Manual connection pool | HikariCP (auto-config) |
| Manual routing | `@RestController` (auto-config) |

**Key Insight**: Spring Boot = mini-spring + 500 lines of auto-configuration

---

## References

- **Design Documents**:
  - [1.1: HTTP Server](./1.1-http-server.md)
  - [1.2: Mini-Framework](./1.2-mini-framework.md)
  - [1.3: Connection Pool](./1.3-connection-pool.md)
  - [1.4.5: Spring Bridge](./1.4.5-spring-bridge.md)

- **Evidence**:
  - `docs/evidence/m1.4/sample-app-walkthrough.md`
  - `docs/evidence/m1.4/integration-report.md`
