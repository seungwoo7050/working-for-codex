# 오디오 노드 시스템 설계 일지 (v3.2.1)
> Phase 3.2 - AudioNode 그래프 관리

## 1. 문제 정의 & 요구사항

### 1.1 핵심 목표

**v3.2.1 - Audio Node System**:
- **노드 그래프 관리**: 동적 노드 연결/해제
- **커스텀 노드**: 재사용 가능한 오디오 처리 단위
- **노드 연결 시스템**: 유연한 라우팅
- **파라미터 오토메이션**: 시간 기반 파라미터 변경

---

## 2. 패치별 상세 설계

### 3.2.1.1: 노드 그래프 관리

**파일**: `frontend/src/webaudio/AudioNodeGraph.ts`

```typescript
interface AudioNodeInfo {
  id: string;
  node: AudioNode;
  type: string;
  inputs: string[];
  outputs: string[];
}

class AudioNodeGraph {
  private context: AudioContext;
  private nodes: Map<string, AudioNodeInfo> = new Map();
  private connections: Map<string, Set<string>> = new Map();
  
  constructor(context: AudioContext) {
    this.context = context;
  }
  
  addNode(id: string, node: AudioNode, type: string): void {
    if (this.nodes.has(id)) {
      throw new Error(`Node with id "${id}" already exists`);
    }
    this.nodes.set(id, { id, node, type, inputs: [], outputs: [] });
    this.connections.set(id, new Set());
  }
  
  removeNode(id: string): void {
    const info = this.nodes.get(id);
    if (!info) return;
    
    info.node.disconnect();
    this.connections.delete(id);
    
    for (const node of this.nodes.values()) {
      node.inputs = node.inputs.filter(i => i !== id);
      node.outputs = node.outputs.filter(o => o !== id);
    }
    
    this.nodes.delete(id);
  }
  
  getNode(id: string): AudioNode | null {
    return this.nodes.get(id)?.node ?? null;
  }
  
  getNodeInfo(id: string): AudioNodeInfo | null {
    return this.nodes.get(id) ?? null;
  }
  
  connect(sourceId: string, destId: string, outputIndex?: number, inputIndex?: number): void {
    const source = this.nodes.get(sourceId);
    const dest = this.nodes.get(destId);
    
    if (!source || !dest) {
      throw new Error(`Node not found: ${!source ? sourceId : destId}`);
    }
    
    source.node.connect(dest.node, outputIndex, inputIndex);
    source.outputs.push(destId);
    dest.inputs.push(sourceId);
    this.connections.get(sourceId)?.add(destId);
  }
  
  disconnect(sourceId: string, destId?: string): void {
    const source = this.nodes.get(sourceId);
    if (!source) return;
    
    if (destId) {
      const dest = this.nodes.get(destId);
      if (dest) {
        source.node.disconnect(dest.node);
        source.outputs = source.outputs.filter(o => o !== destId);
        dest.inputs = dest.inputs.filter(i => i !== sourceId);
      }
    } else {
      source.node.disconnect();
    }
  }
}
```

---

### 3.2.1.2: 커스텀 오디오 노드

**파일**: `frontend/src/webaudio/CustomAudioNodes.ts`

```typescript
interface GainNodeOptions {
  gain?: number;
}

interface DelayNodeOptions {
  delayTime?: number;
  maxDelayTime?: number;
}

interface FilterNodeOptions {
  type?: BiquadFilterType;
  frequency?: number;
  Q?: number;
  gain?: number;
}

interface CompressorNodeOptions {
  threshold?: number;
  knee?: number;
  ratio?: number;
  attack?: number;
  release?: number;
}

class CustomAudioNodes {
  private context: AudioContext;
  
  constructor(context: AudioContext) {
    this.context = context;
  }
  
  createGain(options: GainNodeOptions = {}): GainNode {
    const node = this.context.createGain();
    if (options.gain !== undefined) {
      node.gain.value = options.gain;
    }
    return node;
  }
  
  createDelay(options: DelayNodeOptions = {}): DelayNode {
    const node = this.context.createDelay(options.maxDelayTime ?? 5);
    if (options.delayTime !== undefined) {
      node.delayTime.value = options.delayTime;
    }
    return node;
  }
  
  createFilter(options: FilterNodeOptions = {}): BiquadFilterNode {
    const node = this.context.createBiquadFilter();
    node.type = options.type ?? 'lowpass';
    if (options.frequency !== undefined) node.frequency.value = options.frequency;
    if (options.Q !== undefined) node.Q.value = options.Q;
    if (options.gain !== undefined) node.gain.value = options.gain;
    return node;
  }
  
  createCompressor(options: CompressorNodeOptions = {}): DynamicsCompressorNode {
    const node = this.context.createDynamicsCompressor();
    if (options.threshold !== undefined) node.threshold.value = options.threshold;
    if (options.knee !== undefined) node.knee.value = options.knee;
    if (options.ratio !== undefined) node.ratio.value = options.ratio;
    if (options.attack !== undefined) node.attack.value = options.attack;
    if (options.release !== undefined) node.release.value = options.release;
    return node;
  }
  
  createStereoPanner(pan: number = 0): StereoPannerNode {
    const node = this.context.createStereoPanner();
    node.pan.value = pan;
    return node;
  }
}
```

---

### 3.2.1.3: 노드 연결 시스템

**파일**: `frontend/src/webaudio/AudioConnector.ts`

```typescript
type ConnectionTarget = AudioNode | AudioParam;

class AudioConnector {
  /**
   * 시리얼 체인 연결 (A -> B -> C)
   */
  static chain(...nodes: AudioNode[]): void {
    for (let i = 0; i < nodes.length - 1; i++) {
      nodes[i].connect(nodes[i + 1]);
    }
  }
  
  /**
   * 병렬 연결 (source -> [A, B, C] -> destination)
   */
  static parallel(
    source: AudioNode,
    parallels: AudioNode[],
    destination: AudioNode
  ): void {
    for (const node of parallels) {
      source.connect(node);
      node.connect(destination);
    }
  }
  
  /**
   * 믹스 연결 (multiple sources -> gain -> destination)
   */
  static mix(
    sources: AudioNode[],
    mixer: GainNode,
    destination: AudioNode
  ): void {
    for (const source of sources) {
      source.connect(mixer);
    }
    mixer.connect(destination);
  }
  
  /**
   * 센드/리턴 효과
   */
  static sendReturn(
    source: AudioNode,
    effectChain: AudioNode[],
    dryGain: GainNode,
    wetGain: GainNode,
    destination: AudioNode
  ): void {
    // Dry path
    source.connect(dryGain);
    dryGain.connect(destination);
    
    // Wet path
    source.connect(effectChain[0]);
    this.chain(...effectChain);
    effectChain[effectChain.length - 1].connect(wetGain);
    wetGain.connect(destination);
  }
  
  /**
   * AudioParam 모듈레이션
   */
  static modulate(
    source: AudioNode,
    target: AudioParam,
    amount?: GainNode
  ): void {
    if (amount) {
      source.connect(amount);
      amount.connect(target);
    } else {
      source.connect(target);
    }
  }
}
```

---

### 3.2.1.4: 노드 파라미터 바인딩

**파일**: `frontend/src/webaudio/AudioParameters.ts`

```typescript
type AutomationCurve = 'linear' | 'exponential' | 'instant' | 'target';

interface AutomationPoint {
  time: number;
  value: number;
  curve?: AutomationCurve;
  timeConstant?: number;
}

class AudioParameters {
  private context: AudioContext;
  
  constructor(context: AudioContext) {
    this.context = context;
  }
  
  setValue(param: AudioParam, value: number): void {
    param.value = value;
  }
  
  setValueAtTime(param: AudioParam, value: number, time: number): void {
    param.setValueAtTime(value, time);
  }
  
  linearRampTo(param: AudioParam, value: number, endTime: number): void {
    param.linearRampToValueAtTime(value, endTime);
  }
  
  exponentialRampTo(param: AudioParam, value: number, endTime: number): void {
    // Exponential can't reach 0
    const safeValue = Math.max(value, 0.0001);
    param.exponentialRampToValueAtTime(safeValue, endTime);
  }
  
  setTargetAtTime(
    param: AudioParam,
    target: number,
    startTime: number,
    timeConstant: number
  ): void {
    param.setTargetAtTime(target, startTime, timeConstant);
  }
  
  setValueCurve(
    param: AudioParam,
    values: Float32Array | number[],
    startTime: number,
    duration: number
  ): void {
    const curve = values instanceof Float32Array ? values : new Float32Array(values);
    param.setValueCurveAtTime(curve, startTime, duration);
  }
  
  cancelScheduled(param: AudioParam, startTime?: number): void {
    param.cancelScheduledValues(startTime ?? 0);
  }
  
  cancelAndHold(param: AudioParam, holdTime: number): void {
    type ExtendedAudioParam = AudioParam & { cancelAndHoldAtTime?: (time: number) => void };
    const extParam = param as ExtendedAudioParam;
    if (extParam.cancelAndHoldAtTime) {
      extParam.cancelAndHoldAtTime(holdTime);
    } else {
      param.cancelScheduledValues(holdTime);
      param.setValueAtTime(param.value, holdTime);
    }
  }
}
```

---

## 3. 완료 기준

- [ ] 노드 그래프 생성/수정/삭제
- [ ] 커스텀 노드 동작
- [ ] 동적 연결/해제
- [ ] 파라미터 오토메이션

---

## 4. 다음 단계

→ v3.2.2: 실시간 오디오 프로세싱
