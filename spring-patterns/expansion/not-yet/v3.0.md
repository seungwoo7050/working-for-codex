# CLAUDE.md - spring-patterns v3.x 대규모 분산 시스템

> AI 코딩 에이전트를 위한 프로젝트 컨텍스트 가이드 (시니어 레벨)

## 프로젝트 개요

### 현재 상태 (v2.4.0)
- **위치**: `/backend/spring-patterns/`
- **기술 스택**: Spring WebFlux, R2DBC, Virtual Threads
- **완성된 기능**:
  - 리액티브 API
  - Rate Limiting
  - Redis 캐싱
  - 10K req/s

### 목표 상태 (v3.x)
- **목표**: 대규모 분산 시스템 (100K+ req/s)
- **핵심 변경**: 마이크로서비스 분리, 서비스 메시, 분산 추적

## 버전 로드맵 (v3.x 세부화)

| 버전 | 기간 | 설명 |
|------|------|------|
| v3.0.0 | 2주 | 마이크로서비스 분리 & API Gateway |
| v3.1.0 | 1.5주 | gRPC 서비스 간 통신 |
| v3.2.0 | 2주 | Saga 분산 트랜잭션 |
| v3.3.0 | 1주 | OpenTelemetry 분산 추적 |
| v3.4.0 | 1주 | 커스텀 메트릭 & 로깅 |
| v3.5.0 | 1.5주 | 읽기/쓰기 분리 & 로드밸런싱 |

---

## v3.0.0: 마이크로서비스 분리 & API Gateway

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.0.1 | Product Service 분리 | `product-service/` |
| 3.0.2 | Order Service 분리 | `order-service/` |
| 3.0.3 | User Service 분리 | `user-service/` |
| 3.0.4 | Spring Cloud Gateway | `gateway/GatewayConfig.java` |
| 3.0.5 | Circuit Breaker 적용 | `GatewayConfig.java` |
| 3.0.6 | Service Discovery (Consul) | `docker-compose.yml` |

### 커밋 포인트
```bash
git commit -m "feat(product): extract Product Service as standalone module"
git commit -m "feat(order): extract Order Service as standalone module"
git commit -m "feat(user): extract User Service as standalone module"
git commit -m "feat(gateway): implement Spring Cloud Gateway with routing"
git commit -m "feat(gateway): add Circuit Breaker with fallback"
git commit -m "infra(consul): add Consul for service discovery"
git tag -a v3.0.0 -m "v3.0.0: Microservices Architecture"
```

---

## v3.1.0: gRPC 서비스 간 통신

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.1.1 | Protobuf 스키마 정의 | `proto/product.proto` |
| 3.1.2 | gRPC Server 구현 | `ProductGrpcService.java` |
| 3.1.3 | gRPC Client 구현 | `ProductGrpcClient.java` |
| 3.1.4 | 스트리밍 API | `ProductGrpcService.java` |

### 커밋 포인트
```bash
git commit -m "feat(proto): define Protobuf schema for product service"
git commit -m "feat(grpc): implement gRPC server for product operations"
git commit -m "feat(grpc): add gRPC client for inter-service calls"
git commit -m "feat(grpc): add server-side streaming for product list"
git tag -a v3.1.0 -m "v3.1.0: gRPC Inter-Service Communication"
```

---

## v3.2.0: Saga 분산 트랜잭션

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.2.1 | CreateOrderSaga 구현 | `saga/CreateOrderSaga.java` |
| 3.2.2 | 보상 트랜잭션 | `saga/CreateOrderSaga.java` |
| 3.2.3 | Saga Orchestrator | `saga/SagaOrchestrator.java` |
| 3.2.4 | Saga State 저장소 | `saga/SagaStateRepository.java` |
| 3.2.5 | Kafka 이벤트 발행 | `saga/CreateOrderSaga.java` |

### 커밋 포인트
```bash
git commit -m "feat(saga): implement CreateOrderSaga with step execution"
git commit -m "feat(saga): add compensation logic for rollback"
git commit -m "feat(saga): implement Saga Orchestrator with state machine"
git commit -m "feat(saga): add Saga state persistence"
git commit -m "feat(kafka): integrate Kafka for saga events"
git tag -a v3.2.0 -m "v3.2.0: Saga Pattern for Distributed Transactions"
```

---

## v3.3.0: OpenTelemetry 분산 추적

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.3.1 | OpenTelemetry SDK 설정 | `TracingConfig.java` |
| 3.3.2 | 스팬 전파 설정 | `TracingConfig.java` |
| 3.3.3 | Jaeger 연동 | `docker-compose.yml` |
| 3.3.4 | 커스텀 스팬 | `LoggingAspect.java` |

### 커밋 포인트
```bash
git commit -m "feat(tracing): configure OpenTelemetry SDK"
git commit -m "feat(tracing): add W3C trace context propagation"
git commit -m "infra(jaeger): add Jaeger for trace visualization"
git commit -m "feat(tracing): add custom spans with AOP"
git tag -a v3.3.0 -m "v3.3.0: Distributed Tracing with OpenTelemetry"
```

---

## v3.4.0: 커스텀 메트릭 & 로깅

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.4.1 | 비즈니스 메트릭 | `metrics/BusinessMetrics.java` |
| 3.4.2 | 주문 처리 타이머 | `BusinessMetrics.java` |
| 3.4.3 | 분산 로깅 (MDC) | `LoggingAspect.java` |
| 3.4.4 | Grafana 대시보드 | `monitoring/grafana/` |

### 커밋 포인트
```bash
git commit -m "feat(metrics): implement business metrics with Micrometer"
git commit -m "feat(metrics): add order processing timer and counters"
git commit -m "feat(logging): add distributed logging with trace correlation"
git commit -m "infra(grafana): add Grafana dashboards for monitoring"
git tag -a v3.4.0 -m "v3.4.0: Custom Metrics & Distributed Logging"
```

---

## v3.5.0: 읽기/쓰기 분리 & 로드밸런싱

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.5.1 | 라우팅 DataSource | `DataSourceConfig.java` |
| 3.5.2 | 읽기 전용 라우팅 | `RoutingDataSource.java` |
| 3.5.3 | 트랜잭션 AOP | `ReadOnlyTransactionAspect.java` |
| 3.5.4 | 레플리카 로드밸런싱 | `application.yml` |
| 3.5.5 | 성능 벤치마크 | `docs/BENCHMARK.md` |

### 커밋 포인트
```bash
git commit -m "feat(db): implement routing DataSource for read/write split"
git commit -m "feat(db): add automatic read-only routing"
git commit -m "feat(db): add transaction-based routing AOP"
git commit -m "feat(db): configure multiple replica load balancing"
git commit -m "docs: add 100K+ req/s benchmark results"
git tag -a v3.5.0 -m "v3.5.0: Read/Write Split & Scale Complete"
```

---

## 구현 상세

### Phase 1: 마이크로서비스 분리 (v3.0.0 ~ v3.1.0)

#### 1.1 도메인별 서비스 분리
```
┌─────────────────────────────────────────────────────────────┐
│                      API Gateway                              │
│                 (Spring Cloud Gateway)                        │
└─────────────────────────┬───────────────────────────────────┘
                          │
    ┌─────────────────────┼─────────────────────┐
    │                     │                     │
    ▼                     ▼                     ▼
┌─────────┐         ┌─────────┐         ┌─────────┐
│ Product │         │  Order  │         │  User   │
│ Service │         │ Service │         │ Service │
└────┬────┘         └────┬────┘         └────┬────┘
     │                   │                   │
     ▼                   ▼                   ▼
┌─────────┐         ┌─────────┐         ┌─────────┐
│PostgreSQL│        │PostgreSQL│        │PostgreSQL│
└─────────┘         └─────────┘         └─────────┘
```

#### 1.2 API Gateway
```java
// GatewayConfig.java
@Configuration
public class GatewayConfig {
    
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
                .route("product-service", r -> r
                        .path("/api/products/**")
                        .filters(f -> f
                                .circuitBreaker(c -> c
                                        .setName("productCircuitBreaker")
                                        .setFallbackUri("forward:/fallback/products"))
                                .retry(config -> config
                                        .setRetries(3)
                                        .setStatuses(HttpStatus.SERVICE_UNAVAILABLE))
                                .requestRateLimiter(config -> config
                                        .setRateLimiter(redisRateLimiter())))
                        .uri("lb://product-service"))
                
                .route("order-service", r -> r
                        .path("/api/orders/**")
                        .filters(f -> f
                                .circuitBreaker(c -> c
                                        .setName("orderCircuitBreaker"))
                                .addRequestHeader("X-Request-Source", "gateway"))
                        .uri("lb://order-service"))
                
                .route("user-service", r -> r
                        .path("/api/users/**")
                        .uri("lb://user-service"))
                .build();
    }
    
    @Bean
    public RedisRateLimiter redisRateLimiter() {
        return new RedisRateLimiter(100, 200, 1);
    }
}
```

#### 1.3 서비스 간 통신 (gRPC)
```protobuf
// product.proto
syntax = "proto3";
package product;

service ProductService {
    rpc GetProduct (GetProductRequest) returns (ProductResponse);
    rpc GetProducts (GetProductsRequest) returns (stream ProductResponse);
    rpc CheckStock (CheckStockRequest) returns (StockResponse);
    rpc ReserveStock (ReserveStockRequest) returns (ReservationResponse);
}

message GetProductRequest {
    int64 product_id = 1;
}

message ProductResponse {
    int64 id = 1;
    string name = 2;
    string description = 3;
    int32 price = 4;
    int32 stock = 5;
    string category = 6;
}

message ReserveStockRequest {
    int64 product_id = 1;
    int32 quantity = 2;
    string order_id = 3;
}

message ReservationResponse {
    bool success = 1;
    string reservation_id = 2;
    string message = 3;
}
```

```java
// ProductGrpcService.java
@GrpcService
@RequiredArgsConstructor
public class ProductGrpcService extends ProductServiceGrpc.ProductServiceImplBase {
    
    private final ProductService productService;
    private final StockService stockService;
    
    @Override
    public void getProduct(GetProductRequest request, 
                          StreamObserver<ProductResponse> responseObserver) {
        
        productService.findById(request.getProductId())
                .map(this::toProto)
                .subscribe(
                        response -> {
                            responseObserver.onNext(response);
                            responseObserver.onCompleted();
                        },
                        responseObserver::onError
                );
    }
    
    @Override
    public void reserveStock(ReserveStockRequest request,
                            StreamObserver<ReservationResponse> responseObserver) {
        
        stockService.reserve(
                request.getProductId(),
                request.getQuantity(),
                request.getOrderId()
        )
        .map(reservation -> ReservationResponse.newBuilder()
                .setSuccess(true)
                .setReservationId(reservation.getId())
                .build())
        .onErrorResume(e -> Mono.just(ReservationResponse.newBuilder()
                .setSuccess(false)
                .setMessage(e.getMessage())
                .build()))
        .subscribe(
                response -> {
                    responseObserver.onNext(response);
                    responseObserver.onCompleted();
                }
        );
    }
}
```

### Phase 2: 분산 트랜잭션 (v3.2.0)

#### 2.1 Saga 패턴
```java
// CreateOrderSaga.java
@Component
@RequiredArgsConstructor
public class CreateOrderSaga {
    
    private final OrderRepository orderRepository;
    private final ProductGrpcClient productClient;
    private final PaymentGrpcClient paymentClient;
    private final KafkaTemplate<String, SagaEvent> kafkaTemplate;
    
    @Transactional
    public Mono<Order> execute(CreateOrderCommand command) {
        return Mono.just(command)
                // Step 1: Create order (pending)
                .flatMap(cmd -> createPendingOrder(cmd))
                
                // Step 2: Reserve stock
                .flatMap(order -> reserveStock(order)
                        .thenReturn(order)
                        .onErrorResume(e -> compensateOrder(order, e)))
                
                // Step 3: Process payment
                .flatMap(order -> processPayment(order)
                        .thenReturn(order)
                        .onErrorResume(e -> compensateStockAndOrder(order, e)))
                
                // Step 4: Confirm order
                .flatMap(this::confirmOrder);
    }
    
    private Mono<Order> createPendingOrder(CreateOrderCommand command) {
        Order order = Order.builder()
                .userId(command.getUserId())
                .items(command.getItems())
                .status(OrderStatus.PENDING)
                .build();
        
        return orderRepository.save(order)
                .doOnSuccess(o -> publishEvent(new OrderCreatedEvent(o)));
    }
    
    private Mono<Void> reserveStock(Order order) {
        return Flux.fromIterable(order.getItems())
                .flatMap(item -> productClient.reserveStock(
                        item.getProductId(),
                        item.getQuantity(),
                        order.getId()))
                .collectList()
                .doOnSuccess(reservations -> 
                    order.setStockReservations(reservations))
                .then();
    }
    
    private Mono<Void> processPayment(Order order) {
        return paymentClient.charge(
                order.getUserId(),
                order.getTotalAmount(),
                order.getId()
        )
        .doOnSuccess(payment -> order.setPaymentId(payment.getId()))
        .then();
    }
    
    private Mono<Order> confirmOrder(Order order) {
        order.setStatus(OrderStatus.CONFIRMED);
        return orderRepository.save(order)
                .doOnSuccess(o -> publishEvent(new OrderConfirmedEvent(o)));
    }
    
    // Compensation
    private <T> Mono<T> compensateOrder(Order order, Throwable error) {
        order.setStatus(OrderStatus.CANCELLED);
        order.setFailureReason(error.getMessage());
        
        return orderRepository.save(order)
                .doOnSuccess(o -> publishEvent(new OrderCancelledEvent(o, error)))
                .then(Mono.error(error));
    }
    
    private <T> Mono<T> compensateStockAndOrder(Order order, Throwable error) {
        // Release stock reservations
        return Flux.fromIterable(order.getStockReservations())
                .flatMap(res -> productClient.releaseReservation(res.getId()))
                .then(compensateOrder(order, error));
    }
    
    private void publishEvent(SagaEvent event) {
        kafkaTemplate.send("order-saga-events", event.getOrderId(), event);
    }
}
```

#### 2.2 Saga Orchestrator
```java
// SagaOrchestrator.java
@Component
@RequiredArgsConstructor
public class SagaOrchestrator {
    
    private final SagaStateRepository stateRepository;
    private final SagaStepExecutor stepExecutor;
    
    @KafkaListener(topics = "saga-commands")
    public void handleSagaCommand(SagaCommand command) {
        SagaState state = stateRepository.findById(command.getSagaId())
                .orElseGet(() -> createNewSaga(command));
        
        try {
            SagaStep currentStep = state.getCurrentStep();
            StepResult result = stepExecutor.execute(currentStep, command.getPayload());
            
            if (result.isSuccess()) {
                state.moveToNextStep();
                
                if (state.isCompleted()) {
                    publishEvent(new SagaCompletedEvent(state));
                } else {
                    publishCommand(new SagaCommand(
                            state.getSagaId(),
                            state.getCurrentStep(),
                            result.getOutput()
                    ));
                }
            } else {
                state.setStatus(SagaStatus.COMPENSATING);
                startCompensation(state);
            }
            
            stateRepository.save(state);
            
        } catch (Exception e) {
            state.setStatus(SagaStatus.FAILED);
            state.setError(e.getMessage());
            stateRepository.save(state);
            startCompensation(state);
        }
    }
    
    private void startCompensation(SagaState state) {
        List<SagaStep> completedSteps = state.getCompletedSteps();
        Collections.reverse(completedSteps);
        
        for (SagaStep step : completedSteps) {
            try {
                stepExecutor.compensate(step, state.getStepData(step));
            } catch (Exception e) {
                // Log and continue compensation
                log.error("Compensation failed for step: {}", step, e);
            }
        }
        
        state.setStatus(SagaStatus.COMPENSATED);
        stateRepository.save(state);
        publishEvent(new SagaCompensatedEvent(state));
    }
}
```

### Phase 3: 분산 추적 & 모니터링 (v3.3.0 ~ v3.4.0)

#### 3.1 OpenTelemetry 설정
```java
// TracingConfig.java
@Configuration
public class TracingConfig {
    
    @Bean
    public OpenTelemetry openTelemetry() {
        Resource resource = Resource.getDefault()
                .merge(Resource.create(Attributes.of(
                        ResourceAttributes.SERVICE_NAME, "spring-patterns",
                        ResourceAttributes.SERVICE_VERSION, "3.0.0"
                )));
        
        SdkTracerProvider tracerProvider = SdkTracerProvider.builder()
                .addSpanProcessor(BatchSpanProcessor.builder(
                        OtlpGrpcSpanExporter.builder()
                                .setEndpoint("http://jaeger:4317")
                                .build())
                        .build())
                .setResource(resource)
                .build();
        
        SdkMeterProvider meterProvider = SdkMeterProvider.builder()
                .registerMetricReader(PeriodicMetricReader.builder(
                        OtlpGrpcMetricExporter.builder()
                                .setEndpoint("http://prometheus:4317")
                                .build())
                        .setInterval(Duration.ofSeconds(10))
                        .build())
                .setResource(resource)
                .build();
        
        return OpenTelemetrySdk.builder()
                .setTracerProvider(tracerProvider)
                .setMeterProvider(meterProvider)
                .setPropagators(ContextPropagators.create(
                        W3CTraceContextPropagator.getInstance()))
                .buildAndRegisterGlobal();
    }
}
```

#### 3.2 커스텀 메트릭
```java
// BusinessMetrics.java
@Component
public class BusinessMetrics {
    
    private final MeterRegistry meterRegistry;
    private final Counter orderCreatedCounter;
    private final Counter orderFailedCounter;
    private final Timer orderProcessingTimer;
    private final AtomicInteger activeOrdersGauge;
    
    public BusinessMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        this.orderCreatedCounter = Counter.builder("orders.created.total")
                .description("Total orders created")
                .register(meterRegistry);
        
        this.orderFailedCounter = Counter.builder("orders.failed.total")
                .description("Total orders failed")
                .tag("reason", "")
                .register(meterRegistry);
        
        this.orderProcessingTimer = Timer.builder("orders.processing.duration")
                .description("Order processing duration")
                .publishPercentiles(0.5, 0.95, 0.99)
                .register(meterRegistry);
        
        this.activeOrdersGauge = meterRegistry.gauge(
                "orders.active.count",
                new AtomicInteger(0)
        );
    }
    
    public void recordOrderCreated() {
        orderCreatedCounter.increment();
        activeOrdersGauge.incrementAndGet();
    }
    
    public void recordOrderCompleted(long durationMs) {
        orderProcessingTimer.record(durationMs, TimeUnit.MILLISECONDS);
        activeOrdersGauge.decrementAndGet();
    }
    
    public void recordOrderFailed(String reason) {
        Counter.builder("orders.failed.total")
                .tag("reason", reason)
                .register(meterRegistry)
                .increment();
        activeOrdersGauge.decrementAndGet();
    }
}
```

#### 3.3 분산 로깅
```java
// LoggingAspect.java
@Aspect
@Component
@RequiredArgsConstructor
public class LoggingAspect {
    
    private final Tracer tracer;
    
    @Around("@annotation(Logged)")
    public Object logMethod(ProceedingJoinPoint joinPoint) throws Throwable {
        Span currentSpan = Span.current();
        String traceId = currentSpan.getSpanContext().getTraceId();
        String spanId = currentSpan.getSpanContext().getSpanId();
        
        MDC.put("traceId", traceId);
        MDC.put("spanId", spanId);
        
        String methodName = joinPoint.getSignature().toShortString();
        long startTime = System.currentTimeMillis();
        
        log.info("[START] {} - args: {}", methodName, 
                 sanitizeArgs(joinPoint.getArgs()));
        
        try {
            Object result = joinPoint.proceed();
            
            long duration = System.currentTimeMillis() - startTime;
            log.info("[END] {} - duration: {}ms", methodName, duration);
            
            currentSpan.setAttribute("method.duration_ms", duration);
            
            return result;
        } catch (Exception e) {
            log.error("[ERROR] {} - exception: {}", methodName, e.getMessage());
            currentSpan.recordException(e);
            throw e;
        } finally {
            MDC.clear();
        }
    }
}
```

### Phase 4: 대규모 트래픽 처리 (v3.5.0)

#### 4.1 읽기/쓰기 분리
```java
// DataSourceConfig.java
@Configuration
public class DataSourceConfig {
    
    @Bean
    @Primary
    public DataSource routingDataSource(
            @Qualifier("writerDataSource") DataSource writerDataSource,
            @Qualifier("readerDataSource") DataSource readerDataSource) {
        
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put(DataSourceType.WRITER, writerDataSource);
        targetDataSources.put(DataSourceType.READER, readerDataSource);
        
        RoutingDataSource routingDataSource = new RoutingDataSource();
        routingDataSource.setTargetDataSources(targetDataSources);
        routingDataSource.setDefaultTargetDataSource(writerDataSource);
        
        return routingDataSource;
    }
}

// RoutingDataSource.java
public class RoutingDataSource extends AbstractRoutingDataSource {
    
    private static final ThreadLocal<DataSourceType> contextHolder = 
            ThreadLocal.withInitial(() -> DataSourceType.WRITER);
    
    @Override
    protected Object determineCurrentLookupKey() {
        return contextHolder.get();
    }
    
    public static void setDataSourceType(DataSourceType type) {
        contextHolder.set(type);
    }
    
    public static void clear() {
        contextHolder.remove();
    }
}

// ReadOnlyTransactionAspect.java
@Aspect
@Component
public class ReadOnlyTransactionAspect {
    
    @Before("@annotation(org.springframework.transaction.annotation.Transactional) " +
            "&& @annotation(transactional)")
    public void setReadOnlyDataSource(Transactional transactional) {
        if (transactional.readOnly()) {
            RoutingDataSource.setDataSourceType(DataSourceType.READER);
        }
    }
    
    @After("@annotation(org.springframework.transaction.annotation.Transactional)")
    public void clearDataSource() {
        RoutingDataSource.clear();
    }
}
```

#### 4.2 다중 레플리카 로드밸런싱
```yaml
# application.yml
spring:
  datasource:
    writer:
      url: jdbc:postgresql://primary:5432/db
      hikari:
        maximum-pool-size: 20
    
    readers:
      - url: jdbc:postgresql://replica1:5432/db
        weight: 50
      - url: jdbc:postgresql://replica2:5432/db
        weight: 50
    
    hikari:
      maximum-pool-size: 50
      minimum-idle: 10
      connection-timeout: 5000
```

## 파일 구조

```
backend/spring-patterns/
├── gateway/
│   ├── src/
│   │   └── main/java/
│   │       └── config/
│   │           └── GatewayConfig.java
│   └── build.gradle
├── product-service/
│   ├── src/
│   │   └── main/
│   │       ├── java/
│   │       │   ├── grpc/
│   │       │   └── service/
│   │       └── proto/
│   │           └── product.proto
│   └── build.gradle
├── order-service/
│   ├── src/
│   │   └── main/java/
│   │       ├── saga/
│   │       └── service/
│   └── build.gradle
├── common/
│   ├── tracing/
│   └── metrics/
└── design/
    └── v3.0.0-distributed.md
```

## 인프라 구성

```yaml
# docker-compose.yml
version: '3.8'
services:
  gateway:
    build: ./gateway
    ports:
      - "8080:8080"
    depends_on:
      - consul
      
  product-service:
    build: ./product-service
    deploy:
      replicas: 3
    
  order-service:
    build: ./order-service
    deploy:
      replicas: 2
      
  consul:
    image: consul:latest
    
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"
      
  prometheus:
    image: prom/prometheus:latest
    
  grafana:
    image: grafana/grafana:latest
```

## 성능 요구사항

- 전체 처리량: 100,000+ req/s
- API 응답 (p99): < 100ms
- Saga 완료: < 5초
- 추적 오버헤드: < 5%

## 학습 자료

- [Microservices Patterns](https://microservices.io/patterns/index.html)
- [Spring Cloud](https://spring.io/projects/spring-cloud)
- [gRPC in Spring](https://github.com/grpc-ecosystem/grpc-spring)
- [OpenTelemetry](https://opentelemetry.io/docs/instrumentation/java/)