# v2.1.0: Virtual Threads 통합

## 개요

Java 21의 Virtual Threads(Project Loom)를 Spring Boot 애플리케이션에 통합하여 블로킹 코드를 효율적으로 처리하고, 리액티브 스택과 하이브리드 아키텍처를 구현합니다.

## 목표

1. **Tomcat Virtual Threads 활성화** - 웹 요청 처리 최적화
2. **블로킹 코드 래핑** - 레거시 코드와의 통합
3. **외부 API 병렬 호출** - 동시성 향상
4. **하이브리드 아키텍처** - WebFlux + Virtual Threads 공존

---

## §1 Virtual Threads 개요

### 1.1 Platform Threads vs Virtual Threads

| 항목 | Platform Threads | Virtual Threads |
|------|------------------|-----------------|
| 생성 비용 | 높음 (~1MB 스택) | 낮음 (~KB 스택) |
| 컨텍스트 스위칭 | OS 레벨 | JVM 레벨 |
| 동시성 한계 | 수천 개 | 수백만 개 |
| 블로킹 I/O | 스레드 점유 | 자동 언마운트 |
| 스케줄링 | OS 스케줄러 | JVM ForkJoinPool |

### 1.2 언제 Virtual Threads를 사용하나?

- **적합한 경우**:
  - 블로킹 I/O가 많은 애플리케이션
  - 레거시 JDBC/JPA 코드
  - 외부 HTTP API 호출
  - 파일 I/O 작업

- **부적합한 경우**:
  - CPU 집약적 작업
  - 이미 리액티브 스택 사용 중
  - synchronized 블록이 많은 코드

---

## §2 Tomcat Virtual Threads 설정

### 2.1 application.yml 설정

```yaml
spring:
  threads:
    virtual:
      enabled: true  # Tomcat Virtual Threads 활성화

server:
  tomcat:
    threads:
      max: 200      # Platform Threads 풀 크기 (VT 사용 시 무시됨)
```

### 2.2 Java 21 요구사항

```groovy
// build.gradle
java {
    sourceCompatibility = '21'
}
```

---

## §3 VirtualThreadConfig 구현

### 3.1 설정 클래스

```java
package com.example.training.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Virtual Threads 실행기 설정
 */
@Configuration
public class VirtualThreadConfig {

    /**
     * Virtual Thread Executor
     * 모든 작업에 Virtual Threads 사용
     */
    @Bean
    public ExecutorService virtualThreadExecutor() {
        return Executors.newVirtualThreadPerTaskExecutor();
    }

    /**
     * 블로킹 작업용 스케줄러
     * Reactor에서 블로킹 코드 래핑 시 사용
     */
    @Bean
    public reactor.core.scheduler.Scheduler blockingScheduler() {
        return reactor.core.scheduler.Schedulers.fromExecutor(
            Executors.newVirtualThreadPerTaskExecutor()
        );
    }
}
```

### 3.2 @Async 통합

```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Override
    public Executor getAsyncExecutor() {
        return Executors.newVirtualThreadPerTaskExecutor();
    }
}
```

---

## §4 블로킹 코드 래핑

### 4.1 HybridProductService

```java
package com.example.training.hybrid.service;

import com.example.training.reactive.dto.ProductResponse;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Scheduler;

/**
 * 하이브리드 상품 서비스
 * 블로킹 레거시 코드를 리액티브 스트림으로 래핑
 */
@Service
public class HybridProductService {

    private final LegacyProductDao legacyDao;
    private final Scheduler blockingScheduler;

    public HybridProductService(LegacyProductDao legacyDao, 
                                 Scheduler blockingScheduler) {
        this.legacyDao = legacyDao;
        this.blockingScheduler = blockingScheduler;
    }

    /**
     * 블로킹 DB 호출을 Virtual Thread로 래핑
     */
    public Mono<ProductResponse> findByIdFromLegacy(Long id) {
        return Mono.fromCallable(() -> legacyDao.findById(id))
                .subscribeOn(blockingScheduler)
                .map(ProductResponse::from);
    }

    /**
     * 여러 블로킹 호출 병렬 실행
     */
    public Mono<AggregatedData> getAggregatedData(Long productId) {
        return Mono.zip(
            Mono.fromCallable(() -> legacyDao.getInventory(productId))
                .subscribeOn(blockingScheduler),
            Mono.fromCallable(() -> legacyDao.getPricing(productId))
                .subscribeOn(blockingScheduler),
            Mono.fromCallable(() -> legacyDao.getReviews(productId))
                .subscribeOn(blockingScheduler)
        ).map(tuple -> new AggregatedData(tuple.getT1(), tuple.getT2(), tuple.getT3()));
    }
}
```

---

## §5 레거시 시스템 어댑터

### 5.1 LegacySystemAdapter

```java
package com.example.training.hybrid.adapter;

import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Scheduler;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;

/**
 * 레거시 시스템 어댑터
 * 블로킹 레거시 API를 리액티브로 변환
 */
@Component
public class LegacySystemAdapter {

    private final ExecutorService virtualThreadExecutor;
    private final Scheduler blockingScheduler;

    public LegacySystemAdapter(ExecutorService virtualThreadExecutor,
                                Scheduler blockingScheduler) {
        this.virtualThreadExecutor = virtualThreadExecutor;
        this.blockingScheduler = blockingScheduler;
    }

    /**
     * CompletableFuture 방식 (Virtual Threads)
     */
    public <T> CompletableFuture<T> executeBlocking(java.util.concurrent.Callable<T> task) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return task.call();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }, virtualThreadExecutor);
    }

    /**
     * Mono 방식 (Reactor + Virtual Threads)
     */
    public <T> Mono<T> executeBlockingReactive(java.util.concurrent.Callable<T> task) {
        return Mono.fromCallable(task)
                .subscribeOn(blockingScheduler);
    }
}
```

---

## §6 외부 API 병렬 호출

### 6.1 ExternalApiClient

```java
package com.example.training.hybrid.client;

import org.springframework.stereotype.Component;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Scheduler;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.List;
import java.util.concurrent.Semaphore;

/**
 * 외부 API 클라이언트
 * Virtual Threads를 사용한 병렬 HTTP 호출
 */
@Component
public class ExternalApiClient {

    private final HttpClient httpClient;
    private final Scheduler blockingScheduler;
    private final Semaphore rateLimiter;

    public ExternalApiClient(Scheduler blockingScheduler) {
        this.blockingScheduler = blockingScheduler;
        this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(10))
                .build();
        // 동시 요청 제한 (10개)
        this.rateLimiter = new Semaphore(10);
    }

    /**
     * 단일 API 호출
     */
    public Mono<String> fetchData(String url) {
        return Mono.fromCallable(() -> {
            rateLimiter.acquire();
            try {
                HttpRequest request = HttpRequest.newBuilder()
                        .uri(URI.create(url))
                        .GET()
                        .build();
                return httpClient.send(request, HttpResponse.BodyHandlers.ofString())
                        .body();
            } finally {
                rateLimiter.release();
            }
        }).subscribeOn(blockingScheduler);
    }

    /**
     * 여러 API 병렬 호출
     */
    public Flux<String> fetchAllParallel(List<String> urls) {
        return Flux.fromIterable(urls)
                .flatMap(this::fetchData, 10);  // 동시성 10
    }

    /**
     * 여러 API 결과 집계
     */
    public Mono<List<String>> fetchAllAndCollect(List<String> urls) {
        return fetchAllParallel(urls).collectList();
    }
}
```

---

## §7 테스트 전략

### 7.1 Virtual Threads 테스트

```java
package com.example.training.hybrid;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import reactor.test.StepVerifier;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
class VirtualThreadsIntegrationTest {

    @Autowired
    private ExecutorService virtualThreadExecutor;

    @Autowired
    private LegacySystemAdapter adapter;

    @Test
    void virtualThreadExecutor_shouldHandleManyTasks() throws InterruptedException {
        int taskCount = 10000;
        CountDownLatch latch = new CountDownLatch(taskCount);

        for (int i = 0; i < taskCount; i++) {
            virtualThreadExecutor.submit(() -> {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown();
                }
            });
        }

        boolean completed = latch.await(30, TimeUnit.SECONDS);
        assertThat(completed).isTrue();
    }

    @Test
    void blockingReactive_shouldCompleteSuccessfully() {
        StepVerifier.create(
            adapter.executeBlockingReactive(() -> {
                Thread.sleep(100);
                return "result";
            })
        )
        .expectNext("result")
        .verifyComplete();
    }
}
```

---

## §8 성능 고려사항

### 8.1 모니터링

```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,threaddump
  metrics:
    tags:
      application: ${spring.application.name}
```

### 8.2 JVM 플래그

```bash
# Virtual Threads 디버깅
java -Djdk.virtualThreadScheduler.parallelism=4 \
     -Djdk.virtualThreadScheduler.maxPoolSize=256 \
     -jar app.jar
```

### 8.3 주의사항

1. **synchronized 블록 최소화** - Virtual Threads 핀닝 방지
2. **ThreadLocal 사용 주의** - 메모리 누수 가능성
3. **CPU 집약적 작업 분리** - Platform Threads 사용 권장

---

## §9 파일 구조

```
src/main/java/com/example/training/
├── config/
│   ├── VirtualThreadConfig.java      # Virtual Thread 설정
│   └── AsyncConfig.java              # @Async 설정
├── hybrid/
│   ├── service/
│   │   └── HybridProductService.java # 하이브리드 서비스
│   ├── adapter/
│   │   └── LegacySystemAdapter.java  # 레거시 어댑터
│   └── client/
│       └── ExternalApiClient.java    # 외부 API 클라이언트
└── ...

src/test/java/com/example/training/hybrid/
└── VirtualThreadsIntegrationTest.java
```

---

## §10 마이그레이션 체크리스트

- [ ] Java 21 업그레이드
- [ ] `spring.threads.virtual.enabled=true` 설정
- [ ] VirtualThreadConfig 클래스 추가
- [ ] 블로킹 코드 래핑 (subscribeOn)
- [ ] 레거시 어댑터 구현
- [ ] 외부 API 클라이언트 구현
- [ ] 동시성 제한 (Semaphore) 설정
- [ ] 통합 테스트 추가
- [ ] 모든 테스트 통과
