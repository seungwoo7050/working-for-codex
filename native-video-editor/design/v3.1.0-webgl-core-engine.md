# WebGL 코어 엔진 포팅 설계 일지 (v3.1.0)
> Phase 3.1 시작 - WebGL 기반 브라우저 비디오 편집

## 1. 문제 정의 & 요구사항

### 1.1 핵심 목표

**v3.1.0 - WebGL Core Engine Port**:
- **WebGL2 컨텍스트**: 브라우저 GPU 렌더링 초기화
- **확장 관리**: WebGL 확장 감지 및 폴백
- **디버깅**: 개발 시 에러 추적
- **메모리 관리**: GPU 리소스 수명 주기 관리

### 1.2 성능 요구사항

- 60 FPS 실시간 프리뷰
- 4K 비디오 지원
- 브라우저 메모리 < 500MB

### 1.3 브라우저 지원

- Chrome 51+
- Firefox 45+
- Safari 10+
- Edge 79+

---

## 2. 아키텍처 설계

### 2.1 디렉토리 구조

```
frontend/src/webgl/
├── WebGLEngine.ts          # WebGL 컨텍스트 관리
├── WebGLExtensions.ts      # 확장 감지 및 폴백
├── WebGLDebug.ts           # 디버깅 유틸리티
├── WebGLMemoryManager.ts   # 메모리/리소스 관리
└── index.ts                # 모듈 익스포트
```

### 2.2 클래스 다이어그램

```
┌─────────────────────────────────────────────────────┐
│                   WebGLEngine                        │
├─────────────────────────────────────────────────────┤
│ - gl: WebGL2RenderingContext                        │
│ - canvas: HTMLCanvasElement                         │
│ - extensions: WebGLExtensions                       │
│ - memoryManager: WebGLMemoryManager                 │
├─────────────────────────────────────────────────────┤
│ + constructor(canvas: HTMLCanvasElement)            │
│ + getContext(): WebGL2RenderingContext              │
│ + resize(width: number, height: number): void       │
│ + dispose(): void                                   │
└─────────────────────────────────────────────────────┘
         │
         ├──────────────────┬──────────────────┐
         ▼                  ▼                  ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│ WebGLExtensions │ │   WebGLDebug    │ │WebGLMemoryMgr   │
├─────────────────┤ ├─────────────────┤ ├─────────────────┤
│ + floatTextures │ │ + logError()    │ │ + allocate()    │
│ + anisotropic   │ │ + checkState()  │ │ + release()     │
│ + instancedArr  │ │ + wrapContext() │ │ + getUsage()    │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

---

## 3. 패치별 상세 설계

### 3.1.0.1: WebGL 컨텍스트 초기화

**파일**: `frontend/src/webgl/WebGLEngine.ts`

```typescript
interface WebGLEngineOptions {
  antialias?: boolean;
  alpha?: boolean;
  depth?: boolean;
  stencil?: boolean;
  preserveDrawingBuffer?: boolean;
  powerPreference?: 'default' | 'high-performance' | 'low-power';
}

class WebGLEngine {
  private gl: WebGL2RenderingContext;
  private canvas: HTMLCanvasElement;
  
  constructor(canvas: HTMLCanvasElement, options?: WebGLEngineOptions) {
    const contextAttributes: WebGLContextAttributes = {
      antialias: options?.antialias ?? true,
      alpha: options?.alpha ?? false,
      depth: options?.depth ?? true,
      stencil: options?.stencil ?? false,
      preserveDrawingBuffer: options?.preserveDrawingBuffer ?? false,
      powerPreference: options?.powerPreference ?? 'high-performance',
    };
    
    const gl = canvas.getContext('webgl2', contextAttributes);
    if (!gl) {
      throw new Error('WebGL2 not supported');
    }
    
    this.gl = gl;
    this.canvas = canvas;
  }
}
```

**핵심 포인트**:
1. WebGL2 컨텍스트 생성 (WebGL1 폴백 없음 - 명시적 요구사항)
2. 고성능 GPU 선호 설정
3. 컨텍스트 속성 커스터마이징

---

### 3.1.0.2: WebGL 확장 지원

**파일**: `frontend/src/webgl/WebGLExtensions.ts`

```typescript
interface ExtensionSupport {
  floatTextures: boolean;
  anisotropicFiltering: boolean;
  instancedArrays: boolean;
  drawBuffers: boolean;
  depthTexture: boolean;
}

class WebGLExtensions {
  private gl: WebGL2RenderingContext;
  private extensions: Map<string, any> = new Map();
  
  // 필수 확장
  private readonly REQUIRED_EXTENSIONS = [
    'EXT_color_buffer_float',
  ];
  
  // 선택 확장
  private readonly OPTIONAL_EXTENSIONS = [
    'EXT_texture_filter_anisotropic',
    'WEBGL_debug_renderer_info',
    'WEBGL_lose_context',
  ];
  
  getExtension<T>(name: string): T | null {
    if (this.extensions.has(name)) {
      return this.extensions.get(name);
    }
    const ext = this.gl.getExtension(name);
    this.extensions.set(name, ext);
    return ext as T;
  }
}
```

**핵심 포인트**:
1. 확장 감지 및 캐싱
2. 필수 vs 선택 확장 구분
3. 폴백 전략 정의

---

### 3.1.0.3: WebGL 디버깅 유틸리티

**파일**: `frontend/src/webgl/WebGLDebug.ts`

```typescript
interface WebGLDebugOptions {
  enabled?: boolean;
  throwOnError?: boolean;
  logCalls?: boolean;
}

const GL_ERROR_NAMES: Record<number, string> = {
  0x0500: 'INVALID_ENUM',
  0x0501: 'INVALID_VALUE',
  0x0502: 'INVALID_OPERATION',
  0x0505: 'OUT_OF_MEMORY',
  0x0506: 'INVALID_FRAMEBUFFER_OPERATION',
  0x9242: 'CONTEXT_LOST_WEBGL',
};

class WebGLDebug {
  private gl: WebGL2RenderingContext;
  private enabled: boolean;
  private throwOnError: boolean;
  
  constructor(gl: WebGL2RenderingContext, options?: WebGLDebugOptions) {
    this.gl = gl;
    this.enabled = options?.enabled ?? true;
    this.throwOnError = options?.throwOnError ?? false;
  }
  
  checkError(operation: string): boolean {
    if (!this.enabled) return true;
    
    const error = this.gl.getError();
    if (error === this.gl.NO_ERROR) {
      return true;
    }
    
    const errorName = GL_ERROR_NAMES[error] || `UNKNOWN_ERROR(${error})`;
    const message = `[WebGL Error] ${operation}: ${errorName}`;
    console.error(message);
    
    if (this.throwOnError) {
      throw new Error(message);
    }
    return false;
  }
  
  checkFramebufferStatus(target: number = this.gl.FRAMEBUFFER): boolean {
    if (!this.enabled) return true;
    const status = this.gl.checkFramebufferStatus(target);
    return status === this.gl.FRAMEBUFFER_COMPLETE;
  }
}
```

**핵심 포인트**:
1. 개발 모드에서만 활성화
2. 에러 코드 → 읽기 쉬운 문자열 변환
3. 작업별 에러 추적

---

### 3.1.0.4: WebGL 메모리 관리

**파일**: `frontend/src/webgl/WebGLMemoryManager.ts`

```typescript
interface ResourceStats {
  textures: number;
  buffers: number;
  programs: number;
  framebuffers: number;
  renderbuffers: number;
  vertexArrays: number;
  estimatedBytes: number;
}

interface TextureInfo {
  texture: WebGLTexture;
  width: number;
  height: number;
  format: number;
}

class WebGLMemoryManager {
  private gl: WebGL2RenderingContext;
  private textures: Map<WebGLTexture, TextureInfo> = new Map();
  private buffers: Map<WebGLBuffer, number> = new Map(); // buffer -> size in bytes
  private programs: Set<WebGLProgram> = new Set();
  private framebuffers: Set<WebGLFramebuffer> = new Set();
  private renderbuffers: Set<WebGLRenderbuffer> = new Set();
  private vertexArrays: Set<WebGLVertexArrayObject> = new Set();
  
  trackTexture(texture: WebGLTexture, width: number, height: number, format: number = this.gl.RGBA): void {
    this.textures.set(texture, { texture, width, height, format });
  }
  
  deleteTexture(texture: WebGLTexture): void {
    if (this.textures.has(texture)) {
      this.gl.deleteTexture(texture);
      this.textures.delete(texture);
    }
  }
  
  trackBuffer(buffer: WebGLBuffer, sizeInBytes: number): void {
    this.buffers.set(buffer, sizeInBytes);
  }
  
  deleteBuffer(buffer: WebGLBuffer): void {
    if (this.buffers.has(buffer)) {
      this.gl.deleteBuffer(buffer);
      this.buffers.delete(buffer);
    }
  }
  
  disposeAll(): void {
    this.textures.forEach((_, t) => this.gl.deleteTexture(t));
    this.buffers.forEach((_, b) => this.gl.deleteBuffer(b));
    this.programs.forEach(p => this.gl.deleteProgram(p));
    this.framebuffers.forEach(f => this.gl.deleteFramebuffer(f));
    this.renderbuffers.forEach(r => this.gl.deleteRenderbuffer(r));
    this.vertexArrays.forEach(v => this.gl.deleteVertexArray(v));
    
    this.textures.clear();
    this.buffers.clear();
    this.programs.clear();
    this.framebuffers.clear();
    this.renderbuffers.clear();
    this.vertexArrays.clear();
  }
  
  getStats(): ResourceStats {
    return {
      textures: this.textures.size,
      buffers: this.buffers.size,
      programs: this.programs.size,
      framebuffers: this.framebuffers.size,
      renderbuffers: this.renderbuffers.size,
      vertexArrays: this.vertexArrays.size,
      estimatedBytes: this.estimateMemoryUsage(),
    };
  }
}
```

**핵심 포인트**:
1. 리소스 추적 및 수명 주기 관리
2. 메모리 사용량 추정
3. 일괄 해제 (dispose)

---

## 4. 테스트 전략

### 4.1 단위 테스트

```typescript
describe('WebGLEngine', () => {
  it('should create WebGL2 context', () => {
    const canvas = document.createElement('canvas');
    const engine = new WebGLEngine(canvas);
    expect(engine.getContext()).toBeInstanceOf(WebGL2RenderingContext);
  });
  
  it('should throw if WebGL2 not supported', () => {
    // Mock WebGL2 unsupported
    jest.spyOn(HTMLCanvasElement.prototype, 'getContext').mockReturnValue(null);
    expect(() => new WebGLEngine(document.createElement('canvas'))).toThrow();
  });
});
```

### 4.2 통합 테스트

- 컨텍스트 생성 → 확장 로드 → 리소스 할당 → 해제 흐름 검증
- 컨텍스트 손실/복구 시나리오

---

## 5. 완료 기준

- [ ] WebGL2 컨텍스트 초기화 성공
- [ ] 확장 감지 및 폴백 동작
- [ ] 디버그 모드에서 에러 로깅
- [ ] 메모리 누수 없음 (DevTools Memory 확인)
- [ ] 모든 지원 브라우저에서 동작

---

## 6. 다음 단계

→ v3.1.1: WebGL 셰이더 시스템
