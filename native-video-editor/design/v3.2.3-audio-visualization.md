# 오디오 시각화 설계 일지 (v3.2.3)
> Phase 3.2 - 오디오 데이터 시각화

## 1. 문제 정의 & 요구사항

### 1.1 핵심 목표

**v3.2.3 - Audio Visualization**:
- **웨이브폼 렌더링**: 시간 도메인 데이터 표시
- **스펙트로그램**: 주파수 도메인 2D 표시
- **실시간 시각화**: 애니메이션 프레임 동기화
- **WebGL 가속**: GPU 기반 렌더링

---

## 2. 패치별 상세 설계

### 3.2.3.1: 웨이브폼 렌더링

**파일**: `frontend/src/audio/WaveformRenderer.ts`

```typescript
interface WaveformStyle {
  color: string;
  lineWidth: number;
  backgroundColor: string;
}

class WaveformRenderer {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private style: WaveformStyle;
  
  constructor(canvas: HTMLCanvasElement, style?: Partial<WaveformStyle>) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d')!;
    this.style = {
      color: style?.color ?? '#00ff00',
      lineWidth: style?.lineWidth ?? 2,
      backgroundColor: style?.backgroundColor ?? '#000000',
    };
  }
  
  renderStatic(audioBuffer: AudioBuffer): void {
    const data = audioBuffer.getChannelData(0);
    this.clear();
    this.drawWaveform(data);
  }
  
  renderRealtime(timeDomainData: Uint8Array): void {
    this.clear();
    
    const { width, height } = this.canvas;
    const sliceWidth = width / timeDomainData.length;
    
    this.ctx.beginPath();
    this.ctx.strokeStyle = this.style.color;
    this.ctx.lineWidth = this.style.lineWidth;
    
    let x = 0;
    for (let i = 0; i < timeDomainData.length; i++) {
      const v = timeDomainData[i] / 128.0;
      const y = (v * height) / 2;
      
      if (i === 0) {
        this.ctx.moveTo(x, y);
      } else {
        this.ctx.lineTo(x, y);
      }
      
      x += sliceWidth;
    }
    
    this.ctx.stroke();
  }
  
  private clear(): void {
    this.ctx.fillStyle = this.style.backgroundColor;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }
  
  private drawWaveform(data: Float32Array): void {
    const { width, height } = this.canvas;
    const step = Math.ceil(data.length / width);
    const amp = height / 2;
    
    this.ctx.beginPath();
    this.ctx.strokeStyle = this.style.color;
    this.ctx.lineWidth = this.style.lineWidth;
    
    for (let i = 0; i < width; i++) {
      let min = 1.0;
      let max = -1.0;
      
      for (let j = 0; j < step; j++) {
        const datum = data[i * step + j];
        if (datum < min) min = datum;
        if (datum > max) max = datum;
      }
      
      this.ctx.moveTo(i, (1 + min) * amp);
      this.ctx.lineTo(i, (1 + max) * amp);
    }
    
    this.ctx.stroke();
  }
}
```

---

### 3.2.3.2: 스펙트로그램

**파일**: `frontend/src/audio/SpectrogramRenderer.ts`

```typescript
interface SpectrogramStyle {
  colorMap: 'viridis' | 'plasma' | 'inferno' | 'magma';
  minDb: number;
  maxDb: number;
}

class SpectrogramRenderer {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private imageData: ImageData;
  private style: SpectrogramStyle;
  
  constructor(canvas: HTMLCanvasElement, style?: Partial<SpectrogramStyle>) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d')!;
    this.imageData = this.ctx.createImageData(canvas.width, canvas.height);
    this.style = {
      colorMap: style?.colorMap ?? 'viridis',
      minDb: style?.minDb ?? -100,
      maxDb: style?.maxDb ?? -30,
    };
  }
  
  update(frequencyData: Uint8Array): void {
    // Shift existing data left
    this.shiftLeft();
    
    // Draw new column
    this.drawColumn(frequencyData);
    
    // Render
    this.ctx.putImageData(this.imageData, 0, 0);
  }
  
  private shiftLeft(): void {
    const { width, height } = this.canvas;
    const data = this.imageData.data;
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width - 1; x++) {
        const srcIdx = (y * width + x + 1) * 4;
        const dstIdx = (y * width + x) * 4;
        data[dstIdx] = data[srcIdx];
        data[dstIdx + 1] = data[srcIdx + 1];
        data[dstIdx + 2] = data[srcIdx + 2];
        data[dstIdx + 3] = data[srcIdx + 3];
      }
    }
  }
  
  private drawColumn(frequencyData: Uint8Array): void {
    const { width, height } = this.canvas;
    const x = width - 1;
    
    for (let i = 0; i < frequencyData.length && i < height; i++) {
      const y = height - 1 - Math.floor(i * height / frequencyData.length);
      const value = frequencyData[i] / 255;
      const color = this.getColor(value);
      
      const idx = (y * width + x) * 4;
      this.imageData.data[idx] = color.r;
      this.imageData.data[idx + 1] = color.g;
      this.imageData.data[idx + 2] = color.b;
      this.imageData.data[idx + 3] = 255;
    }
  }
  
  private getColor(value: number): { r: number; g: number; b: number } {
    // Viridis colormap approximation
    const r = Math.floor(255 * Math.min(1, 1.5 - Math.abs(4 * value - 3)));
    const g = Math.floor(255 * Math.min(1, 1.5 - Math.abs(4 * value - 2)));
    const b = Math.floor(255 * Math.min(1, 1.5 - Math.abs(4 * value - 1)));
    return { r, g, b };
  }
}
```

---

### 3.2.3.3: 실시간 시각화

**파일**: `frontend/src/audio/RealtimeVisualizer.ts`

```typescript
class RealtimeVisualizer {
  private analyser: FFTAnalyzer;
  private waveformRenderer: WaveformRenderer;
  private spectrogramRenderer: SpectrogramRenderer;
  private animationId: number | null = null;
  
  constructor(
    analyser: FFTAnalyzer,
    waveformCanvas: HTMLCanvasElement,
    spectrogramCanvas: HTMLCanvasElement
  ) {
    this.analyser = analyser;
    this.waveformRenderer = new WaveformRenderer(waveformCanvas);
    this.spectrogramRenderer = new SpectrogramRenderer(spectrogramCanvas);
  }
  
  start(): void {
    const render = () => {
      // Update waveform
      const timeDomainData = this.analyser.getTimeDomainData();
      this.waveformRenderer.renderRealtime(timeDomainData);
      
      // Update spectrogram
      const frequencyData = this.analyser.getFrequencyData();
      this.spectrogramRenderer.update(frequencyData);
      
      this.animationId = requestAnimationFrame(render);
    };
    
    render();
  }
  
  stop(): void {
    if (this.animationId !== null) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }
  
  isRunning(): boolean {
    return this.animationId !== null;
  }
}
```

---

### 3.2.3.4: WebGL 오디오 시각화

**파일**: `frontend/src/audio/WebGLAudioVisualizer.ts`

```typescript
class WebGLAudioVisualizer {
  private gl: WebGL2RenderingContext;
  private program: WebGLProgram;
  private frequencyTexture: WebGLTexture;
  private analyser: FFTAnalyzer;
  
  constructor(canvas: HTMLCanvasElement, analyser: FFTAnalyzer) {
    const gl = canvas.getContext('webgl2');
    if (!gl) throw new Error('WebGL2 not supported');
    
    this.gl = gl;
    this.analyser = analyser;
    this.program = this.createProgram();
    this.frequencyTexture = this.createTexture();
  }
  
  private readonly FRAGMENT_SHADER = `#version 300 es
    precision highp float;
    
    uniform sampler2D uFrequencyData;
    uniform float uTime;
    in vec2 vTexCoord;
    out vec4 fragColor;
    
    void main() {
      float frequency = texture(uFrequencyData, vec2(vTexCoord.x, 0.5)).r;
      
      // Create bar visualization
      float barHeight = frequency;
      float y = vTexCoord.y;
      
      if (y < barHeight) {
        // Gradient color based on frequency
        vec3 color = mix(
          vec3(0.0, 0.5, 1.0),  // Low frequency color
          vec3(1.0, 0.2, 0.2),  // High frequency color
          vTexCoord.x
        );
        
        // Add glow effect
        float glow = 1.0 - (barHeight - y) / barHeight;
        color *= 0.5 + 0.5 * glow;
        
        fragColor = vec4(color, 1.0);
      } else {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
      }
    }
  `;
  
  render(): void {
    const frequencyData = this.analyser.getFrequencyData();
    
    // Update texture with frequency data
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.frequencyTexture);
    this.gl.texImage2D(
      this.gl.TEXTURE_2D,
      0,
      this.gl.R8,
      frequencyData.length,
      1,
      0,
      this.gl.RED,
      this.gl.UNSIGNED_BYTE,
      frequencyData
    );
    
    // Draw fullscreen quad
    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
  }
}
```

---

## 3. 완료 기준

- [ ] 웨이브폼 렌더링 동작
- [ ] 스펙트로그램 실시간 업데이트
- [ ] 실시간 시각화 60 FPS
- [ ] WebGL 가속 시각화

---

## 4. 다음 단계

→ v3.2.4: WebAudio 성능 최적화
