# WebGL 셰이더 시스템 설계 일지 (v3.1.1)
> Phase 3.1 - GLSL 셰이더 프로그래밍

## 1. 문제 정의 & 요구사항

### 1.1 핵심 목표

**v3.1.1 - WebGL Shader System**:
- **셰이더 컴파일**: GLSL ES 3.0 셰이더 컴파일 및 에러 리포팅
- **프로그램 관리**: 셰이더 프로그램 링킹 및 사용
- **유니폼 바인딩**: 타입별 유니폼 변수 전달
- **셰이더 캐싱**: 컴파일된 셰이더 재사용

---

## 2. 패치별 상세 설계

### 3.1.1.1: GLSL 셰이더 컴파일러

**파일**: `frontend/src/webgl/ShaderCompiler.ts`

```typescript
type ShaderType = 'vertex' | 'fragment';

interface CompileResult {
  shader: WebGLShader | null;
  success: boolean;
  errors: string[];
}

class ShaderCompiler {
  private gl: WebGL2RenderingContext;
  
  compile(source: string, type: ShaderType): CompileResult {
    const shaderType = type === 'vertex' 
      ? this.gl.VERTEX_SHADER 
      : this.gl.FRAGMENT_SHADER;
    
    const shader = this.gl.createShader(shaderType);
    if (!shader) {
      return { shader: null, success: false, errors: ['Failed to create shader'] };
    }
    
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      const log = this.gl.getShaderInfoLog(shader) || '';
      this.gl.deleteShader(shader);
      return { shader: null, success: false, errors: this.parseErrors(log) };
    }
    
    return { shader, success: true, errors: [] };
  }
  
  private parseErrors(log: string): string[] {
    return log.split('\n').filter(line => line.trim().length > 0);
  }
}
```

---

### 3.1.1.2: 셰이더 프로그램 관리

**파일**: `frontend/src/webgl/ShaderProgram.ts`

```typescript
interface ShaderProgramOptions {
  vertexSource: string;
  fragmentSource: string;
  attributes?: string[];
}

class ShaderProgram {
  private gl: WebGL2RenderingContext;
  private program: WebGLProgram;
  private uniformLocations: Map<string, WebGLUniformLocation> = new Map();
  private attributeLocations: Map<string, number> = new Map();
  
  constructor(gl: WebGL2RenderingContext, options: ShaderProgramOptions) {
    this.gl = gl;
    this.program = this.createProgram(options);
  }
  
  use(): void {
    this.gl.useProgram(this.program);
  }
  
  getUniformLocation(name: string): WebGLUniformLocation | null {
    if (!this.uniformLocations.has(name)) {
      const location = this.gl.getUniformLocation(this.program, name);
      if (location) this.uniformLocations.set(name, location);
    }
    return this.uniformLocations.get(name) || null;
  }
  
  dispose(): void {
    this.gl.deleteProgram(this.program);
  }
}
```

---

### 3.1.1.3: 유니폼 변수 바인딩

**파일**: `frontend/src/webgl/UniformBinder.ts`

```typescript
class UniformBinder {
  private gl: WebGL2RenderingContext;
  
  setFloat(location: WebGLUniformLocation, value: number): void {
    this.gl.uniform1f(location, value);
  }
  
  setVec2(location: WebGLUniformLocation, x: number, y: number): void {
    this.gl.uniform2f(location, x, y);
  }
  
  setVec3(location: WebGLUniformLocation, x: number, y: number, z: number): void {
    this.gl.uniform3f(location, x, y, z);
  }
  
  setMat4(location: WebGLUniformLocation, matrix: Float32Array): void {
    this.gl.uniformMatrix4fv(location, false, matrix);
  }
  
  setTexture(location: WebGLUniformLocation, texture: WebGLTexture, unit: number): void {
    this.gl.activeTexture(this.gl.TEXTURE0 + unit);
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    this.gl.uniform1i(location, unit);
  }
}
```

---

### 3.1.1.4: 셰이더 캐싱 시스템

**파일**: `frontend/src/webgl/ShaderCache.ts`

```typescript
class ShaderCache {
  private cache: Map<string, ShaderProgram> = new Map();
  
  private generateKey(vertexSource: string, fragmentSource: string): string {
    // Simple hash for shader source
    return `${this.hash(vertexSource)}_${this.hash(fragmentSource)}`;
  }
  
  get(vertexSource: string, fragmentSource: string): ShaderProgram | null {
    const key = this.generateKey(vertexSource, fragmentSource);
    return this.cache.get(key) || null;
  }
  
  set(vertexSource: string, fragmentSource: string, program: ShaderProgram): void {
    const key = this.generateKey(vertexSource, fragmentSource);
    this.cache.set(key, program);
  }
  
  clear(): void {
    this.cache.forEach(program => program.dispose());
    this.cache.clear();
  }
}
```

---

## 3. 완료 기준

- [ ] 셰이더 컴파일 및 에러 리포팅
- [ ] 프로그램 링킹 성공
- [ ] 유니폼 타입별 바인딩 동작
- [ ] 셰이더 캐싱으로 재컴파일 방지

---

## 4. 다음 단계

→ v3.1.2: WebGL 텍스처 관리
