```markdown
# CLAUDE.md - cpp-pvp-server v3.1 대규모 성능 최적화

> AI 코딩 에이전트를 위한 프로젝트 컨텍스트 가이드 (시니어 레벨)

## 프로젝트 개요

### 선행 조건
- v3.0.0 멀티 리전 아키텍처 완료
- 글로벌 매칭메이킹 및 크로스 리전 동기화 가능

### 현재 상태 (v3.0.0)
- 멀티 리전 아키텍처 구축
- 글로벌 매칭메이킹 동작
- 크로스 리전 데이터 동기화

### 목표 상태 (v3.1.0)
- **10만+ 동시 접속** 처리
- 락-프리 데이터 구조
- NUMA-aware 메모리 관리
- io_uring 기반 고성능 네트워킹

## 버전 로드맵 (v3.1 세부화)

| 버전 | 기간 | 설명 |
|------|------|------|
| v3.1.0 | 2주 | 락-프리 데이터 구조 |
| v3.1.1 | 2주 | NUMA-aware 메모리 할당 |
| v3.1.2 | 2주 | io_uring 기반 네트워킹 |
| v3.1.3 | 2주 | 성능 벤치마크 및 튜닝 |

---

## v3.1.0: 락-프리 데이터 구조

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.1.0.1 | Lock-Free Queue 구현 | `LockFreeQueue.hpp` |
| 3.1.0.2 | Lock-Free HashMap | `LockFreeHashMap.hpp` |
| 3.1.0.3 | Atomic 카운터 | `AtomicCounters.hpp` |
| 3.1.0.4 | 기존 구조 교체 | 전체 적용 |

### 구현 세부 사항
- Michael-Scott 알고리즘 기반 락-프리 큐
- Split-ordered 리스트 기반 락-프리 해시맵
- 원자적 연산을 통한 카운터 구현

#### 3.1.0.1 Lock-Free Queue (Michael-Scott Queue)
```cpp
// LockFreeQueue.hpp
template<typename T>
class LockFreeQueue {
public:
    void enqueue(T item) {
        Node* newNode = new Node{std::move(item), nullptr};
        Node* oldTail = tail_.load(std::memory_order_relaxed);
        
        while (true) {
            Node* next = oldTail->next.load(std::memory_order_acquire);
            
            if (next == nullptr) {
                if (oldTail->next.compare_exchange_weak(
                    next, newNode,
                    std::memory_order_release,
                    std::memory_order_relaxed
                )) {
                    tail_.compare_exchange_strong(
                        oldTail, newNode,
                        std::memory_order_release,
                        std::memory_order_relaxed
                    );
                    return;
                }
            } else {
                tail_.compare_exchange_weak(
                    oldTail, next,
                    std::memory_order_release,
                    std::memory_order_relaxed
                );
            }
            oldTail = tail_.load(std::memory_order_relaxed);
        }
    }

    std::optional<T> dequeue() {
        // Michael-Scott queue dequeue 구현
        while (true) {
            Node* oldHead = head_.load(std::memory_order_acquire);
            Node* oldTail = tail_.load(std::memory_order_acquire);
            Node* next = oldHead->next.load(std::memory_order_acquire);
            
            if (oldHead == head_.load(std::memory_order_acquire)) {
                if (oldHead == oldTail) {
                    if (next == nullptr) {
                        return std::nullopt;  // 큐가 비어있음
                    }
                    tail_.compare_exchange_weak(oldTail, next,
                        std::memory_order_release, std::memory_order_relaxed);
                } else {
                    T value = std::move(next->data);
                    if (head_.compare_exchange_weak(oldHead, next,
                        std::memory_order_release, std::memory_order_relaxed)) {
                        delete oldHead;
                        return value;
                    }
                }
            }
        }
    }

private:
    struct Node {
        T data;
        std::atomic<Node*> next;
    };
    
    std::atomic<Node*> head_;
    std::atomic<Node*> tail_;
};
```

---

## v3.1.1: NUMA-aware 메모리 할당

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.1.1.1 | NUMA Allocator 구현 | `NUMAAllocator.cpp` |
| 3.1.1.2 | 스레드 노드 바인딩 | `NUMAAllocator.cpp` |
| 3.1.1.3 | 플레이어 데이터 NUMA 로컬화 | `NUMAGameServer.cpp` |
| 3.1.1.4 | 메모리 접근 최적화 | 전체 적용 |

### 커밋 포인트
```bash
git commit -m "feat(numa): implement NUMA-aware memory allocator"
git commit -m "feat(numa): add thread to NUMA node binding"
git commit -m "feat(numa): localize player data to NUMA nodes"
git commit -m "perf(numa): optimize memory access patterns"
git tag -a v3.1.1 -m "v3.1.1: NUMA-aware Memory Management"
```

### 상세 구현 가이드

#### 3.1.1.1 NUMA Allocator
```cpp
// NUMAAllocator.hpp
class NUMAAllocator {
public:
    // 현재 스레드의 NUMA 노드에서 메모리 할당
    void* allocateLocal(size_t size) {
        int node = getCurrentNUMANode();
        return numa_alloc_onnode(size, node);
    }
    
    // 특정 NUMA 노드에서 할당
    void* allocateOnNode(size_t size, int node) {
        return numa_alloc_onnode(size, node);
    }
    
    // 모든 노드에 인터리브 할당 (공유 데이터용)
    void* allocateInterleaved(size_t size) {
        return numa_alloc_interleaved(size);
    }

    // 스레드를 특정 NUMA 노드에 고정
    void bindThreadToNode(int node) {
        cpu_set_t cpuset;
        CPU_ZERO(&cpuset);
        
        // 해당 노드의 모든 CPU 추가
        for (int cpu : getNodeCPUs(node)) {
            CPU_SET(cpu, &cpuset);
        }
        
        pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset);
    }

private:
    int getCurrentNUMANode() {
        return numa_node_of_cpu(sched_getcpu());
    }
};

// 사용 예시: 게임 서버에서 플레이어 데이터를 NUMA 로컬로 관리
class NUMAGameServer {
public:
    void assignPlayerToNode(PlayerId player) {
        int node = player.hash() % numa_num_configured_nodes();
        playerNodes_[player] = node;
        
        // 플레이어 데이터를 해당 노드에 할당
        auto* data = (PlayerData*)allocator_.allocateOnNode(
            sizeof(PlayerData), node
        );
        playerData_[player] = data;
    }
};
```

---

## v3.1.2: io_uring 기반 네트워킹

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.1.2.1 | io_uring 래퍼 구현 | `IoUringNetwork.cpp` |
| 3.1.2.2 | 비동기 수신/송신 | `IoUringNetwork.cpp` |
| 3.1.2.3 | 배치 처리 최적화 | `IoUringNetwork.cpp` |
| 3.1.2.4 | UDP 서버 적용 | `HighPerfUDPServer.cpp` |

### 커밋 포인트
```bash
git commit -m "feat(io): implement io_uring wrapper for async I/O"
git commit -m "feat(io): add async recv/send with io_uring"
git commit -m "perf(io): optimize batch submission and completion"
git commit -m "refactor(io): migrate UDP server to io_uring"
git tag -a v3.1.2 -m "v3.1.2: io_uring High-Performance Networking"
```

### 상세 구현 가이드

#### 3.1.2.1 io_uring 네트워크 래퍼
```cpp
// IoUringNetwork.hpp
class IoUringNetwork {
public:
    IoUringNetwork(int queueDepth = 4096) {
        io_uring_queue_init(queueDepth, &ring_, 0);
    }
    
    ~IoUringNetwork() {
        io_uring_queue_exit(&ring_);
    }

    // 비동기 수신 등록
    void prepareRecv(int fd, void* buffer, size_t len, void* userData) {
        io_uring_sqe* sqe = io_uring_get_sqe(&ring_);
        io_uring_prep_recv(sqe, fd, buffer, len, 0);
        io_uring_sqe_set_data(sqe, userData);
    }
    
    // 비동기 송신 등록
    void prepareSend(int fd, const void* buffer, size_t len, void* userData) {
        io_uring_sqe* sqe = io_uring_get_sqe(&ring_);
        io_uring_prep_send(sqe, fd, buffer, len, 0);
        io_uring_sqe_set_data(sqe, userData);
    }
    
    // 배치 제출
    int submit() {
        return io_uring_submit(&ring_);
    }
    
    // 완료 이벤트 처리
    void processCompletions(std::function<void(void*, int)> handler) {
        io_uring_cqe* cqe;
        unsigned head;
        int count = 0;
        
        io_uring_for_each_cqe(&ring_, head, cqe) {
            void* userData = io_uring_cqe_get_data(cqe);
            handler(userData, cqe->res);
            count++;
        }
        
        io_uring_cq_advance(&ring_, count);
    }

private:
    io_uring ring_;
};

// 사용 예시: 고성능 UDP 서버
class HighPerfUDPServer {
public:
    void run() {
        // 수신 버퍼 사전 등록
        for (int i = 0; i < RECV_BUFFER_COUNT; i++) {
            network_.prepareRecv(socket_, buffers_[i], BUFFER_SIZE, &buffers_[i]);
        }
        network_.submit();
        
        while (running_) {
            network_.processCompletions([this](void* userData, int result) {
                if (result > 0) {
                    processPacket(userData, result);
                    // 버퍼 재사용
                    network_.prepareRecv(socket_, userData, BUFFER_SIZE, userData);
                }
            });
            network_.submit();
        }
    }
};
```

---

## v3.1.3: 성능 벤치마크 및 튜닝

### 작업 내용
| 순서 | 작업 | 핵심 파일 |
|------|------|----------|
| 3.1.3.1 | 벤치마크 프레임워크 | `Benchmark.cpp` |
| 3.1.3.2 | 부하 테스트 스크립트 | `scripts/load_test.sh` |
| 3.1.3.3 | 성능 프로파일링 | `Profiler.cpp` |
| 3.1.3.4 | 결과 문서화 | `docs/PERFORMANCE.md` |

### 커밋 포인트
```bash
git commit -m "test(bench): add benchmark framework with Google Benchmark"
git commit -m "test(bench): add load testing scripts"
git commit -m "feat(perf): add performance profiling tools"
git commit -m "docs: add performance benchmark results"
git tag -a v3.1.3 -m "v3.1.3: Performance Benchmark Complete"
```

## 파일 구조

```
cpp-pvp-server/
├── server/
│   ├── src/
│   │   ├── performance/
│   │   │   ├── LockFreeQueue.hpp
│   │   │   ├── LockFreeHashMap.hpp
│   │   │   ├── AtomicCounters.hpp
│   │   │   ├── NUMAAllocator.cpp
│   │   │   ├── NUMAAllocator.hpp
│   │   │   ├── NUMAGameServer.cpp
│   │   │   ├── IoUringNetwork.cpp
│   │   │   ├── IoUringNetwork.hpp
│   │   │   └── HighPerfUDPServer.cpp
│   │   └── ...
│   └── tests/
│       ├── performance/
│       │   ├── LockFreeQueueTest.cpp
│       │   └── NUMAAllocatorTest.cpp
│       └── benchmark/
│           └── NetworkBenchmark.cpp
└── scripts/
    └── load_test.sh
```

## 성능 요구사항

| 메트릭 | 목표값 |
|--------|--------|
| 동시 접속 | 10만+ |
| 패킷 처리량 | 100만 pps |
| 지연 시간 (p99) | < 1ms |
| CPU 사용률 | < 70% |

## 학습 자료

### 성능 최적화
- [Systems Performance (Brendan Gregg)](https://www.brendangregg.com/systems-performance-2nd-edition-book.html)
- [The Art of Multiprocessor Programming](https://www.amazon.com/Art-Multiprocessor-Programming-Revised-Reprint/dp/0123973376)
- [io_uring 문서](https://kernel.dk/io_uring.pdf)
```
