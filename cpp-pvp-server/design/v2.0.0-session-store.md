# v2.0.0 설계 문서: 세션 서버 분리 및 Redis 통합

## 개요

서버 무상태화를 위해 세션 데이터를 Redis Cluster에 저장하여 수평 확장 가능한 아키텍처로 전환합니다.

## 아키텍처 변경

### Before (v1.4.x)
```
┌─────────────────────────────────────┐
│         단일 게임 서버              │
│  ┌───────────────────────────────┐  │
│  │    메모리 세션 저장           │  │
│  │  (GameSession 내부)          │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘
```

### After (v2.0.0)
```
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ 게임 서버 1  │  │ 게임 서버 2  │  │ 게임 서버 N  │
└──────┬───────┘  └──────┬───────┘  └──────┬───────┘
       │                 │                 │
       └────────────────┼────────────────┘
                        │
              ┌─────────▼─────────┐
              │   Redis Cluster   │
              │  (세션 저장소)     │
              └───────────────────┘
```

## 컴포넌트 설계

### 1. SessionStore 인터페이스

```cpp
// storage/session_store.h
#pragma once

#include <optional>
#include <string>
#include <vector>

namespace pvpserver {
namespace storage {

struct SessionData {
    std::string player_id;
    std::string player_name;
    std::string server_id;
    int64_t created_at;
    int64_t last_activity;
    int elo_rating;

    std::string Serialize() const;
    static std::optional<SessionData> Deserialize(const std::string& data);
};

class SessionStore {
public:
    virtual ~SessionStore() = default;

    virtual bool SaveSession(const std::string& session_id,
                            const SessionData& data) = 0;

    virtual std::optional<SessionData> GetSession(
        const std::string& session_id) = 0;

    virtual bool DeleteSession(const std::string& session_id) = 0;

    virtual bool RefreshSession(const std::string& session_id) = 0;

    virtual std::vector<std::string> GetAllSessionIds() = 0;
};

}  // namespace storage
}  // namespace pvpserver
```

### 2. InMemorySessionStore

로컬 개발 및 테스트용 구현체입니다.

```cpp
class InMemorySessionStore : public SessionStore {
public:
    explicit InMemorySessionStore(int ttl_seconds = 3600);
    ~InMemorySessionStore();

    // SessionStore 인터페이스
    bool SaveSession(const std::string& session_id,
                    const SessionData& data) override;
    std::optional<SessionData> GetSession(
        const std::string& session_id) override;
    bool DeleteSession(const std::string& session_id) override;
    bool RefreshSession(const std::string& session_id) override;
    std::vector<std::string> GetAllSessionIds() override;

    // 추가 유틸리티
    size_t GetActiveSessionCount() const;
    void CleanExpiredSessions();

private:
    struct SessionEntry {
        SessionData data;
        int64_t expiry_time;
    };

    std::unordered_map<std::string, SessionEntry> sessions_;
    mutable std::mutex mutex_;
    int ttl_seconds_;

    std::thread cleanup_thread_;
    std::atomic<bool> running_{true};

    void CleanupLoop();
};
```

### 3. RedisSessionStore

Redis Cluster를 사용하는 프로덕션 구현체입니다.

```cpp
struct RedisConfig {
    std::vector<std::string> cluster_nodes;  // "host:port"
    std::string password;
    int connection_pool_size = 10;
    int connection_timeout_ms = 5000;
    int command_timeout_ms = 1000;
};

class RedisSessionStore : public SessionStore {
public:
    explicit RedisSessionStore(const RedisConfig& config);
    ~RedisSessionStore();

    // SessionStore 인터페이스
    bool SaveSession(const std::string& session_id,
                    const SessionData& data) override;
    std::optional<SessionData> GetSession(
        const std::string& session_id) override;
    bool DeleteSession(const std::string& session_id) override;
    bool RefreshSession(const std::string& session_id) override;
    std::vector<std::string> GetAllSessionIds() override;

    // Redis 특화 기능
    bool IsConnected() const;
    void Reconnect();

private:
    RedisConfig config_;
    std::unique_ptr<RedisClusterClient> client_;
    int session_ttl_seconds_ = 3600;

    static constexpr const char* SESSION_PREFIX = "pvp:session:";

    std::string MakeKey(const std::string& session_id) const;
};
```

## 세션 데이터 직렬화

JSON 형식을 사용합니다 (Protocol Buffers 대안 가능).

```cpp
std::string SessionData::Serialize() const {
    nlohmann::json j;
    j["player_id"] = player_id;
    j["player_name"] = player_name;
    j["server_id"] = server_id;
    j["created_at"] = created_at;
    j["last_activity"] = last_activity;
    j["elo_rating"] = elo_rating;
    return j.dump();
}

std::optional<SessionData> SessionData::Deserialize(const std::string& data) {
    try {
        auto j = nlohmann::json::parse(data);
        SessionData session;
        session.player_id = j["player_id"];
        session.player_name = j["player_name"];
        session.server_id = j["server_id"];
        session.created_at = j["created_at"];
        session.last_activity = j["last_activity"];
        session.elo_rating = j["elo_rating"];
        return session;
    } catch (...) {
        return std::nullopt;
    }
}
```

## Redis 명령어 패턴

### 세션 저장 (SETEX)
```
SETEX pvp:session:{session_id} 3600 {serialized_data}
```

### 세션 조회 (GET)
```
GET pvp:session:{session_id}
```

### 세션 갱신 (EXPIRE)
```
EXPIRE pvp:session:{session_id} 3600
```

### 세션 삭제 (DEL)
```
DEL pvp:session:{session_id}
```

### 모든 세션 조회 (SCAN)
```
SCAN 0 MATCH pvp:session:* COUNT 1000
```

## 의존성

### vcpkg.json 추가
```json
{
  "dependencies": [
    "hiredis",
    "redis-plus-plus",
    "nlohmann-json"
  ]
}
```

## 테스트 전략

### 단위 테스트
- InMemorySessionStore CRUD 동작
- TTL 만료 및 정리 동작
- 동시성 테스트 (멀티스레드)

### 통합 테스트
- RedisSessionStore 연결/재연결
- Redis Cluster 페일오버
- 대용량 세션 처리 (1000+ 동시 세션)

## 마이그레이션 경로

1. SessionStore 인터페이스 정의
2. InMemorySessionStore 구현 (기존 동작 유지)
3. GameSession 리팩토링 (인터페이스 사용)
4. RedisSessionStore 구현
5. 설정 기반 구현체 선택

## 성능 목표

| 메트릭 | 목표 |
|--------|------|
| 세션 저장 | < 5ms |
| 세션 조회 | < 2ms |
| 동시 세션 | 10,000+ |
| Redis 연결 풀 | 10 connections |
