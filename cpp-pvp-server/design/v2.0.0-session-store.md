# v2.0.0 설계 문서: 세션 서버 분리 및 Redis 통합

**상태**: ✅ 완료

---

## 개요

서버 무상태화를 위해 세션 데이터를 Redis Cluster에 저장하여 수평 확장 가능한 아키텍처로 전환합니다.

## 아키텍처 변경

### Before (v1.4.x)
```
┌─────────────────────────────────────┐
│         단일 게임 서버              │
│  ┌───────────────────────────────┐  │
│  │    메모리 세션 저장           │  │
│  │  (GameSession 내부)          │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘
```

### After (v2.0.0)
```
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ 게임 서버 1  │  │ 게임 서버 2  │  │ 게임 서버 N  │
└──────┬───────┘  └──────┬───────┘  └──────┬───────┘
       │                 │                 │
       └────────────────┼────────────────┘
                        │
              ┌─────────▼─────────┐
              │   Redis Cluster   │
              │  (세션 저장소)     │
              └───────────────────┘
```

## 컴포넌트 설계

### 1. SessionStore 인터페이스

```cpp
// storage/session_store.h
#pragma once

#include <chrono>
#include <optional>
#include <string>
#include <vector>

namespace pvpserver {
namespace storage {

/**
 * 세션 데이터 구조체
 */
struct SessionData {
    std::string player_id;
    std::string player_name;
    std::string server_id;        // 할당된 게임 서버
    int64_t created_at;           // 생성 타임스탬프 (epoch ms)
    int64_t last_activity;        // 마지막 활동 타임스탬프
    int elo_rating;
    std::string match_id;         // 현재 매치 (있는 경우)

    std::string Serialize() const;
    static std::optional<SessionData> Deserialize(const std::string& data);

    void Touch();      // last_activity 갱신
    bool IsValid() const;
};

/**
 * 세션 저장소 추상 인터페이스
 */
class SessionStore {
public:
    virtual ~SessionStore() = default;

    // CRUD 연산
    virtual bool SaveSession(const std::string& session_id,
                            const SessionData& data) = 0;

    virtual std::optional<SessionData> GetSession(
        const std::string& session_id) = 0;

    virtual bool DeleteSession(const std::string& session_id) = 0;

    virtual bool RefreshSession(const std::string& session_id) = 0;

    virtual std::vector<std::string> GetAllSessionIds() = 0;

    // 추가 조회 메서드
    virtual std::optional<std::string> GetSessionByPlayerId(
        const std::string& player_id) = 0;

    virtual size_t GetActiveSessionCount() = 0;

    virtual bool SessionExists(const std::string& session_id) = 0;
};

// 유틸리티 함수
std::string GenerateSessionId();
int64_t GetCurrentTimestamp();

}  // namespace storage
}  // namespace pvpserver
```

### 2. InMemorySessionStore

로컬 개발 및 테스트용 구현체입니다.

```cpp
// storage/in_memory_session_store.h
class InMemorySessionStore : public SessionStore {
public:
    /**
     * 생성자
     * @param ttl_seconds 세션 TTL (기본 1시간)
     * @param cleanup_interval_seconds 정리 주기 (기본 60초)
     */
    explicit InMemorySessionStore(int ttl_seconds = 3600,
                                  int cleanup_interval_seconds = 60);
    ~InMemorySessionStore() override;

    // SessionStore 인터페이스 구현
    bool SaveSession(const std::string& session_id,
                    const SessionData& data) override;
    std::optional<SessionData> GetSession(
        const std::string& session_id) override;
    bool DeleteSession(const std::string& session_id) override;
    bool RefreshSession(const std::string& session_id) override;
    std::vector<std::string> GetAllSessionIds() override;
    std::optional<std::string> GetSessionByPlayerId(
        const std::string& player_id) override;
    size_t GetActiveSessionCount() override;
    bool SessionExists(const std::string& session_id) override;

    // 추가 유틸리티
    void CleanExpiredSessions();
    void StopCleanup();

private:
    struct SessionEntry {
        SessionData data;
        int64_t expiry_time;  // epoch ms
    };

    int ttl_seconds_;
    int cleanup_interval_seconds_;

    mutable std::mutex mutex_;
    std::unordered_map<std::string, SessionEntry> sessions_;
    std::unordered_map<std::string, std::string> player_to_session_;

    std::atomic<bool> running_{true};
    std::thread cleanup_thread_;

    void CleanupLoop();
    bool IsExpired(const SessionEntry& entry) const;
};
```

### 3. RedisSessionStore

Redis Cluster를 사용하는 프로덕션 구현체입니다.

```cpp
// storage/redis_session_store.h
struct RedisConfig {
    std::vector<std::string> cluster_nodes;  // "host:port" 형태
    std::string password;
    int connection_pool_size = 10;
    int connection_timeout_ms = 5000;
    int command_timeout_ms = 1000;
    int session_ttl_seconds = 3600;
};

class RedisSessionStore : public SessionStore {
public:
    explicit RedisSessionStore(const RedisConfig& config);
    ~RedisSessionStore() override;

    // SessionStore 인터페이스 구현
    bool SaveSession(const std::string& session_id,
                    const SessionData& data) override;
    std::optional<SessionData> GetSession(
        const std::string& session_id) override;
    bool DeleteSession(const std::string& session_id) override;
    bool RefreshSession(const std::string& session_id) override;
    std::vector<std::string> GetAllSessionIds() override;
    std::optional<std::string> GetSessionByPlayerId(
        const std::string& player_id) override;
    size_t GetActiveSessionCount() override;
    bool SessionExists(const std::string& session_id) override;

    // Redis 특화 기능
    bool IsConnected() const;
    void Reconnect();

private:
    RedisConfig config_;
    std::unique_ptr<RedisClusterClient> client_;

    static constexpr const char* SESSION_KEY_PREFIX = "pvp:session:";
    static constexpr const char* PLAYER_SESSION_PREFIX = "pvp:player_session:";
    static constexpr const char* SESSION_SET_KEY = "pvp:sessions";

    std::string MakeSessionKey(const std::string& session_id) const;
    std::string MakePlayerSessionKey(const std::string& player_id) const;
};
```

## 세션 데이터 직렬화

JSON 형식을 사용합니다 (Protocol Buffers 대안 가능).

```cpp
std::string SessionData::Serialize() const {
    nlohmann::json j;
    j["player_id"] = player_id;
    j["player_name"] = player_name;
    j["server_id"] = server_id;
    j["created_at"] = created_at;
    j["last_activity"] = last_activity;
    j["elo_rating"] = elo_rating;
    return j.dump();
}

std::optional<SessionData> SessionData::Deserialize(const std::string& data) {
    try {
        auto j = nlohmann::json::parse(data);
        SessionData session;
        session.player_id = j["player_id"];
        session.player_name = j["player_name"];
        session.server_id = j["server_id"];
        session.created_at = j["created_at"];
        session.last_activity = j["last_activity"];
        session.elo_rating = j["elo_rating"];
        return session;
    } catch (...) {
        return std::nullopt;
    }
}
```

## Redis 명령어 패턴

### 세션 저장 (SETEX + SADD)
```
SETEX pvp:session:{session_id} 3600 {serialized_data}
SET pvp:player_session:{player_id} {session_id}
SADD pvp:sessions {session_id}
```

### 세션 조회 (GET)
```
GET pvp:session:{session_id}
```

### 플레이어로 세션 조회
```
GET pvp:player_session:{player_id}
```

### 세션 갱신 (EXPIRE)
```
EXPIRE pvp:session:{session_id} 3600
```

### 세션 삭제 (DEL + SREM)
```
DEL pvp:session:{session_id}
DEL pvp:player_session:{player_id}
SREM pvp:sessions {session_id}
```

### 모든 세션 조회 (SMEMBERS)
```
SMEMBERS pvp:sessions
```

## 파일 구조

```
server/
├── include/pvpserver/
│   └── storage/
│       ├── session_store.h           # 세션 저장소 인터페이스
│       ├── in_memory_session_store.h # 인메모리 구현
│       ├── redis_session_store.h     # Redis 구현
│       └── postgres_storage.h        # PostgreSQL 영속화
└── src/
    └── storage/
        ├── session_store.cpp
        ├── in_memory_session_store.cpp
        ├── redis_session_store.cpp
        └── postgres_storage.cpp
```

## 의존성

### vcpkg.json 추가
```json
{
  "dependencies": [
    "hiredis",
    "redis-plus-plus",
    "nlohmann-json"
  ]
}
```

## 테스트 전략

### 단위 테스트
- InMemorySessionStore CRUD 동작
- TTL 만료 및 정리 동작
- 동시성 테스트 (멀티스레드)
- player_id → session_id 매핑

### 통합 테스트
- RedisSessionStore 연결/재연결
- Redis Cluster 페일오버
- 대용량 세션 처리 (1000+ 동시 세션)

## 마이그레이션 경로

1. SessionStore 인터페이스 정의
2. InMemorySessionStore 구현 (기존 동작 유지)
3. GameSession 리팩토링 (인터페이스 사용)
4. RedisSessionStore 구현
5. 설정 기반 구현체 선택

## 성능 목표

| 메트릭 | 목표 |
|--------|------|
| 세션 저장 | < 5ms |
| 세션 조회 | < 2ms |
| 동시 세션 | 10,000+ |
| Redis 연결 풀 | 10 connections |

---

## 다음 버전 연결

v2.0.0에서 구축한 분산 세션 저장소는 이후 로드 밸런서와 gRPC 통신의 기반이 됩니다:

| 현재 (v2.0.0) | 다음 (v2.0.1) | 연결점 |
|---------------|---------------|--------|
| SessionStore 인터페이스 | LoadBalancer | 세션 기반 서버 할당 |
| Redis 세션 키 | Consistent Hash | 세션-서버 매핑 |
| GetSessionByPlayerId | 서버 라우팅 | 플레이어 세션 조회 |

### 다음 단계: [v2.0.1-load-balancer.md](v2.0.1-load-balancer.md)
- Consistent Hash 기반 로드 밸런서
- 서버 헬스 체크
- 세션 기반 서버 라우팅