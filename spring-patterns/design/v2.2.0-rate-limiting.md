# v2.2.0: Rate Limiting

## 개요

API Rate Limiting을 구현하여 서비스 안정성을 보장하고 악의적인 사용을 방지합니다.
Token Bucket 알고리즘을 사용하여 버스트 트래픽을 허용하면서도 전체 요청 속도를 제한합니다.

## 목표

1. **Token Bucket Rate Limiter** - 유연한 요청 제한
2. **클라이언트 식별** - IP/사용자별 제한
3. **표준 헤더 응답** - X-RateLimit-* 헤더
4. **429 Too Many Requests** - 제한 초과 시 적절한 응답

---

## §1 Rate Limiting 알고리즘

### 1.1 Token Bucket

```
┌─────────────────────────────────────┐
│         Token Bucket                │
│                                     │
│  ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐    │
│  │ T │ │ T │ │ T │ │ T │ │ T │    │  ← 토큰 (최대 10개)
│  └───┘ └───┘ └───┘ └───┘ └───┘    │
│                                     │
│  리필 속도: 1 토큰/초               │
│  버킷 용량: 10 토큰                 │
└─────────────────────────────────────┘
```

- **버스트 허용**: 버킷에 토큰이 있으면 즉시 요청 처리
- **속도 제한**: 토큰이 없으면 요청 거부
- **자동 리필**: 시간이 지나면 토큰이 리필됨

### 1.2 알고리즘 비교

| 알고리즘 | 장점 | 단점 | 사용 사례 |
|----------|------|------|-----------|
| Token Bucket | 버스트 허용 | 구현 복잡 | API Gateway |
| Leaky Bucket | 일정 속도 | 버스트 불가 | 스트리밍 |
| Fixed Window | 단순 | 경계 문제 | 간단한 제한 |
| Sliding Window | 정밀 | 메모리 사용 | 정밀 제어 |

---

## §2 구현 상세

### 2.1 RateLimitingFilter

```java
package com.example.training.ratelimit;

import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import java.io.IOException;

/**
 * Rate Limiting 필터
 * 모든 API 요청에 대해 속도 제한 적용
 */
@Component
@Order(1)  // 가장 먼저 실행
public class RateLimitingFilter implements Filter {

    private final RateLimiter rateLimiter;
    private final ClientKeyResolver keyResolver;

    public RateLimitingFilter(RateLimiter rateLimiter, 
                               ClientKeyResolver keyResolver) {
        this.rateLimiter = rateLimiter;
        this.keyResolver = keyResolver;
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                         FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;

        // 클라이언트 키 추출
        String clientKey = keyResolver.resolve(httpRequest);

        // Rate Limit 확인
        RateLimitResult result = rateLimiter.tryConsume(clientKey);

        // 헤더 추가
        addRateLimitHeaders(httpResponse, result);

        if (result.isAllowed()) {
            chain.doFilter(request, response);
        } else {
            httpResponse.setStatus(429);
            httpResponse.setContentType("application/json");
            httpResponse.getWriter().write(
                "{\"error\":\"Too Many Requests\",\"retryAfter\":" + 
                result.getRetryAfterSeconds() + "}"
            );
        }
    }

    private void addRateLimitHeaders(HttpServletResponse response, 
                                      RateLimitResult result) {
        response.setHeader("X-RateLimit-Limit", 
            String.valueOf(result.getLimit()));
        response.setHeader("X-RateLimit-Remaining", 
            String.valueOf(result.getRemaining()));
        response.setHeader("X-RateLimit-Reset", 
            String.valueOf(result.getResetEpochSeconds()));
    }
}
```

### 2.2 ClientKeyResolver

```java
package com.example.training.ratelimit;

import jakarta.servlet.http.HttpServletRequest;
import org.springframework.stereotype.Component;

/**
 * 클라이언트 키 리졸버
 * 클라이언트를 식별하는 키 생성
 */
@Component
public class ClientKeyResolver {

    private static final String X_FORWARDED_FOR = "X-Forwarded-For";
    private static final String AUTHORIZATION = "Authorization";

    /**
     * 클라이언트 식별 키 추출
     * 우선순위: 1. 인증 토큰 2. X-Forwarded-For 3. RemoteAddr
     */
    public String resolve(HttpServletRequest request) {
        // 1. 인증된 사용자인 경우 토큰 기반 식별
        String authorization = request.getHeader(AUTHORIZATION);
        if (authorization != null && authorization.startsWith("Bearer ")) {
            return "user:" + authorization.substring(7, 
                Math.min(authorization.length(), 50));
        }

        // 2. 프록시를 통한 요청인 경우 원본 IP
        String xForwardedFor = request.getHeader(X_FORWARDED_FOR);
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return "ip:" + xForwardedFor.split(",")[0].trim();
        }

        // 3. 직접 연결된 클라이언트 IP
        return "ip:" + request.getRemoteAddr();
    }
}
```

### 2.3 TokenBucketRateLimiter

```java
package com.example.training.ratelimit;

import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * Token Bucket Rate Limiter
 * 인메모리 구현 (단일 인스턴스용)
 */
@Component
public class TokenBucketRateLimiter implements RateLimiter {

    private final ConcurrentMap<String, Bucket> buckets = 
        new ConcurrentHashMap<>();

    private static final int MAX_TOKENS = 100;  // 버킷 최대 용량
    private static final int REFILL_RATE = 10;  // 초당 리필 토큰 수
    private static final long REFILL_INTERVAL_MS = 1000;  // 리필 간격

    @Override
    public RateLimitResult tryConsume(String key) {
        Bucket bucket = buckets.computeIfAbsent(key, 
            k -> new Bucket(MAX_TOKENS, System.currentTimeMillis()));

        synchronized (bucket) {
            refillTokens(bucket);

            if (bucket.tokens > 0) {
                bucket.tokens--;
                return RateLimitResult.allowed(
                    MAX_TOKENS,
                    bucket.tokens,
                    bucket.lastRefillTime / 1000 + 1
                );
            } else {
                long retryAfter = (REFILL_INTERVAL_MS - 
                    (System.currentTimeMillis() - bucket.lastRefillTime)) / 1000 + 1;
                return RateLimitResult.denied(
                    MAX_TOKENS,
                    0,
                    bucket.lastRefillTime / 1000 + 1,
                    retryAfter
                );
            }
        }
    }

    private void refillTokens(Bucket bucket) {
        long now = System.currentTimeMillis();
        long elapsed = now - bucket.lastRefillTime;

        if (elapsed >= REFILL_INTERVAL_MS) {
            int tokensToAdd = (int) (elapsed / REFILL_INTERVAL_MS * REFILL_RATE);
            bucket.tokens = Math.min(MAX_TOKENS, bucket.tokens + tokensToAdd);
            bucket.lastRefillTime = now;
        }
    }

    private static class Bucket {
        int tokens;
        long lastRefillTime;

        Bucket(int tokens, long lastRefillTime) {
            this.tokens = tokens;
            this.lastRefillTime = lastRefillTime;
        }
    }
}
```

### 2.4 RateLimiter 인터페이스

```java
package com.example.training.ratelimit;

/**
 * Rate Limiter 인터페이스
 */
public interface RateLimiter {
    RateLimitResult tryConsume(String key);
}
```

### 2.5 RateLimitResult

```java
package com.example.training.ratelimit;

/**
 * Rate Limit 결과
 */
public class RateLimitResult {
    private final boolean allowed;
    private final int limit;
    private final int remaining;
    private final long resetEpochSeconds;
    private final long retryAfterSeconds;

    private RateLimitResult(boolean allowed, int limit, int remaining, 
                            long resetEpochSeconds, long retryAfterSeconds) {
        this.allowed = allowed;
        this.limit = limit;
        this.remaining = remaining;
        this.resetEpochSeconds = resetEpochSeconds;
        this.retryAfterSeconds = retryAfterSeconds;
    }

    public static RateLimitResult allowed(int limit, int remaining, 
                                           long resetEpochSeconds) {
        return new RateLimitResult(true, limit, remaining, 
            resetEpochSeconds, 0);
    }

    public static RateLimitResult denied(int limit, int remaining, 
                                          long resetEpochSeconds, 
                                          long retryAfterSeconds) {
        return new RateLimitResult(false, limit, remaining, 
            resetEpochSeconds, retryAfterSeconds);
    }

    // Getters
    public boolean isAllowed() { return allowed; }
    public int getLimit() { return limit; }
    public int getRemaining() { return remaining; }
    public long getResetEpochSeconds() { return resetEpochSeconds; }
    public long getRetryAfterSeconds() { return retryAfterSeconds; }
}
```

---

## §3 응답 헤더

### 3.1 표준 Rate Limit 헤더

| 헤더 | 설명 | 예시 |
|------|------|------|
| `X-RateLimit-Limit` | 최대 허용 요청 수 | `100` |
| `X-RateLimit-Remaining` | 남은 요청 수 | `95` |
| `X-RateLimit-Reset` | 리셋 시간 (Unix Epoch) | `1640000000` |
| `Retry-After` | 재시도까지 대기 시간 (초) | `60` |

### 3.2 429 응답 예시

```http
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1640000060
Retry-After: 60

{
  "error": "Too Many Requests",
  "message": "Rate limit exceeded. Please retry after 60 seconds.",
  "retryAfter": 60
}
```

---

## §4 설정

### 4.1 application.yml

```yaml
ratelimit:
  enabled: true
  default-limit: 100        # 기본 요청 제한
  default-interval: 60      # 시간 윈도우 (초)
  burst-capacity: 150       # 버스트 허용량

  # 경로별 설정
  rules:
    - path: "/api/v2/**"
      limit: 100
      interval: 60
    - path: "/api/health"
      limit: 1000           # 헬스체크는 높은 한도
      interval: 60
```

---

## §5 파일 구조

```
src/main/java/com/example/training/ratelimit/
├── RateLimitingFilter.java       # 필터
├── ClientKeyResolver.java        # 클라이언트 식별
├── RateLimiter.java              # 인터페이스
├── TokenBucketRateLimiter.java   # Token Bucket 구현
├── RateLimitResult.java          # 결과 객체
└── RateLimitConfig.java          # 설정

src/test/java/com/example/training/ratelimit/
└── RateLimitingTest.java         # 테스트
```

---

## §6 테스트

```java
@SpringBootTest
class RateLimitingTest {

    @Autowired
    private RateLimiter rateLimiter;

    @Test
    void shouldAllowRequestsWithinLimit() {
        for (int i = 0; i < 100; i++) {
            RateLimitResult result = rateLimiter.tryConsume("test-client");
            assertThat(result.isAllowed()).isTrue();
        }
    }

    @Test
    void shouldDenyRequestsExceedingLimit() {
        // 한도 소진
        for (int i = 0; i < 100; i++) {
            rateLimiter.tryConsume("test-client-2");
        }

        // 추가 요청 거부
        RateLimitResult result = rateLimiter.tryConsume("test-client-2");
        assertThat(result.isAllowed()).isFalse();
    }
}
```

---

## §7 마이그레이션 체크리스트

- [ ] RateLimitingFilter 구현
- [ ] ClientKeyResolver 구현
- [ ] TokenBucketRateLimiter 구현
- [ ] RateLimitResult 구현
- [ ] X-RateLimit-* 헤더 추가
- [ ] 429 응답 구현
- [ ] 통합 테스트 추가
- [ ] 모든 테스트 통과
