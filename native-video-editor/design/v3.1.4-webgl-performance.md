# WebGL 성능 최적화 설계 일지 (v3.1.4)
> Phase 3.1 완료 - GPU 성능 최적화

## 1. 문제 정의 & 요구사항

### 1.1 핵심 목표

**v3.1.4 - WebGL Performance Optimization**:
- **상태 캐싱**: WebGL 상태 변경 최소화
- **배치 렌더링**: 드로우콜 최적화
- **GPU 메모리 최적화**: 텍스처/버퍼 재사용
- **프로파일링**: 성능 측정 및 병목 분석

### 1.2 성능 목표

- 60 FPS 유지 (16.67ms/프레임)
- 드로우콜 < 100/프레임
- GPU 메모리 < 500MB

---

## 2. 패치별 상세 설계

### 3.1.4.1: WebGL 상태 캐싱

**파일**: `frontend/src/webgl/StateCache.ts`

```typescript
class StateCache {
  private gl: WebGL2RenderingContext;
  private currentProgram: WebGLProgram | null = null;
  private currentVAO: WebGLVertexArrayObject | null = null;
  private boundTextures: Map<number, WebGLTexture> = new Map();
  private currentFramebuffer: WebGLFramebuffer | null = null;
  
  useProgram(program: WebGLProgram): void {
    if (this.currentProgram !== program) {
      this.gl.useProgram(program);
      this.currentProgram = program;
    }
  }
  
  bindTexture(unit: number, texture: WebGLTexture): void {
    if (this.boundTextures.get(unit) !== texture) {
      this.gl.activeTexture(this.gl.TEXTURE0 + unit);
      this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
      this.boundTextures.set(unit, texture);
    }
  }
  
  invalidate(): void {
    this.currentProgram = null;
    this.currentVAO = null;
    this.boundTextures.clear();
    this.currentFramebuffer = null;
  }
}
```

---

### 3.1.4.2: 배치 렌더링

**파일**: `frontend/src/webgl/BatchRenderer.ts`

```typescript
interface BatchItem {
  texture: WebGLTexture;
  vertices: Float32Array;
  indices: Uint16Array;
}

class BatchRenderer {
  private gl: WebGL2RenderingContext;
  private maxBatchSize = 1000;
  private batches: Map<WebGLTexture, BatchItem[]> = new Map();
  
  add(item: BatchItem): void {
    if (!this.batches.has(item.texture)) {
      this.batches.set(item.texture, []);
    }
    this.batches.get(item.texture)!.push(item);
    
    if (this.batches.get(item.texture)!.length >= this.maxBatchSize) {
      this.flush(item.texture);
    }
  }
  
  flush(texture?: WebGLTexture): void {
    if (texture) {
      this.renderBatch(texture, this.batches.get(texture)!);
      this.batches.delete(texture);
    } else {
      this.batches.forEach((items, tex) => this.renderBatch(tex, items));
      this.batches.clear();
    }
  }
  
  private renderBatch(texture: WebGLTexture, items: BatchItem[]): void {
    // Merge vertices and draw in single call
  }
}
```

---

### 3.1.4.3: GPU 메모리 최적화

**파일**: `frontend/src/webgl/GPUMemoryOptimizer.ts`

```typescript
class GPUMemoryOptimizer {
  private gl: WebGL2RenderingContext;
  private texturePool: Map<string, WebGLTexture[]> = new Map();
  private bufferPool: Map<number, WebGLBuffer[]> = new Map();
  
  acquireTexture(width: number, height: number, format: number): WebGLTexture {
    const key = `${width}x${height}_${format}`;
    const pool = this.texturePool.get(key) || [];
    
    if (pool.length > 0) {
      return pool.pop()!;
    }
    
    return this.createTexture(width, height, format);
  }
  
  releaseTexture(texture: WebGLTexture, width: number, height: number, format: number): void {
    const key = `${width}x${height}_${format}`;
    if (!this.texturePool.has(key)) {
      this.texturePool.set(key, []);
    }
    this.texturePool.get(key)!.push(texture);
  }
  
  getMemoryUsage(): { textures: number; buffers: number; total: number } {
    // Estimate memory usage
  }
}
```

---

### 3.1.4.4: WebGL 프로파일링

**파일**: `frontend/src/webgl/WebGLProfiler.ts`

```typescript
interface ProfileMetrics {
  fps: number;
  frameTime: number;
  drawCalls: number;
  triangles: number;
  textureBinds: number;
  programSwitches: number;
}

class WebGLProfiler {
  private frameCount = 0;
  private lastTime = performance.now();
  private drawCalls = 0;
  private triangles = 0;
  
  beginFrame(): void {
    this.drawCalls = 0;
    this.triangles = 0;
  }
  
  recordDrawCall(triangleCount: number): void {
    this.drawCalls++;
    this.triangles += triangleCount;
  }
  
  endFrame(): ProfileMetrics {
    this.frameCount++;
    const now = performance.now();
    const elapsed = now - this.lastTime;
    
    if (elapsed >= 1000) {
      const fps = (this.frameCount * 1000) / elapsed;
      this.frameCount = 0;
      this.lastTime = now;
      
      return {
        fps,
        frameTime: 1000 / fps,
        drawCalls: this.drawCalls,
        triangles: this.triangles,
        textureBinds: 0, // tracked by StateCache
        programSwitches: 0,
      };
    }
    
    return { fps: 0, frameTime: 0, drawCalls: 0, triangles: 0, textureBinds: 0, programSwitches: 0 };
  }
}
```

---

## 3. 완료 기준

- [ ] 상태 변경 캐싱으로 API 호출 50% 감소
- [ ] 배치 렌더링으로 드로우콜 최소화
- [ ] 텍스처/버퍼 풀링 동작
- [ ] 프로파일러 메트릭 확인 가능
- [ ] 60 FPS 실시간 프리뷰 달성

---

## 4. Phase 3.1 완료

→ 다음: Phase 3.2 (WebAudio 기반 오디오 편집)
