# WebGL 셰이더 시스템 설계 일지 (v3.1.1)
> Phase 3.1 - GLSL 셰이더 프로그래밍

## 1. 문제 정의 & 요구사항

### 1.1 핵심 목표

**v3.1.1 - WebGL Shader System**:
- **셰이더 컴파일**: GLSL ES 3.0 셰이더 컴파일 및 에러 리포팅
- **프로그램 관리**: 셰이더 프로그램 링킹 및 사용
- **유니폼 바인딩**: 타입별 유니폼 변수 전달
- **셰이더 캐싱**: 컴파일된 셰이더 재사용

---

## 2. 패치별 상세 설계

### 3.1.1.1: GLSL 셰이더 컴파일러

**파일**: `frontend/src/webgl/ShaderCompiler.ts`

```typescript
type ShaderType = 'vertex' | 'fragment';

interface CompileResult {
  shader: WebGLShader | null;
  success: boolean;
  errors: string[];
}

class ShaderCompiler {
  private gl: WebGL2RenderingContext;
  
  constructor(gl: WebGL2RenderingContext) {
    this.gl = gl;
  }
  
  compile(source: string, type: ShaderType): CompileResult {
    const shaderType = type === 'vertex' 
      ? this.gl.VERTEX_SHADER 
      : this.gl.FRAGMENT_SHADER;
    
    const shader = this.gl.createShader(shaderType);
    if (!shader) {
      return { shader: null, success: false, errors: ['Failed to create shader object'] };
    }
    
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      const log = this.gl.getShaderInfoLog(shader) || 'Unknown compilation error';
      const errors = this.parseErrors(log, type);
      this.gl.deleteShader(shader);
      return { shader: null, success: false, errors };
    }
    
    return { shader, success: true, errors: [] };
  }
  
  compileVertex(source: string): CompileResult {
    return this.compile(source, 'vertex');
  }
  
  compileFragment(source: string): CompileResult {
    return this.compile(source, 'fragment');
  }
  
  private parseErrors(log: string, type: ShaderType): string[] {
    const lines = log.split('\n').filter(line => line.trim().length > 0);
    return lines.map(line => `[${type}] ${line}`);
  }
}
```

---

### 3.1.1.2: 셰이더 프로그램 관리

**파일**: `frontend/src/webgl/ShaderProgram.ts`

```typescript
interface ShaderProgramOptions {
  vertexSource: string;    // 버텍스 셰이더 GLSL 소스 코드
  fragmentSource: string;  // 프래그먼트 셰이더 GLSL 소스 코드
}

class ShaderProgram {
  private gl: WebGL2RenderingContext;
  private program: WebGLProgram;
  private uniformLocations: Map<string, WebGLUniformLocation> = new Map();
  private attributeLocations: Map<string, number> = new Map();
  
  constructor(gl: WebGL2RenderingContext, options: ShaderProgramOptions) {
    this.gl = gl;
    this.program = this.createProgram(options);
  }
  
  use(): void {
    this.gl.useProgram(this.program);
  }
  
  getUniformLocation(name: string): WebGLUniformLocation | null {
    if (!this.uniformLocations.has(name)) {
      const location = this.gl.getUniformLocation(this.program, name);
      if (location) this.uniformLocations.set(name, location);
    }
    return this.uniformLocations.get(name) || null;
  }
  
  dispose(): void {
    this.gl.deleteProgram(this.program);
  }
}
```

---

### 3.1.1.3: 유니폼 변수 바인딩

**파일**: `frontend/src/webgl/UniformBinder.ts`

```typescript
class UniformBinder {
  private gl: WebGL2RenderingContext;
  
  constructor(gl: WebGL2RenderingContext) {
    this.gl = gl;
  }
  
  // Integer uniforms
  setInt(location: WebGLUniformLocation, value: number): void {
    this.gl.uniform1i(location, value);
  }
  
  // Float uniforms
  setFloat(location: WebGLUniformLocation, value: number): void {
    this.gl.uniform1f(location, value);
  }
  
  setVec2(location: WebGLUniformLocation, x: number, y: number): void {
    this.gl.uniform2f(location, x, y);
  }
  
  setVec3(location: WebGLUniformLocation, x: number, y: number, z: number): void {
    this.gl.uniform3f(location, x, y, z);
  }
  
  setVec4(location: WebGLUniformLocation, x: number, y: number, z: number, w: number): void {
    this.gl.uniform4f(location, x, y, z, w);
  }
  
  // Matrix uniforms
  setMat3(location: WebGLUniformLocation, matrix: Float32Array): void {
    this.gl.uniformMatrix3fv(location, false, matrix);
  }
  
  setMat4(location: WebGLUniformLocation, matrix: Float32Array): void {
    this.gl.uniformMatrix4fv(location, false, matrix);
  }
  
  // Texture binding
  setTexture(location: WebGLUniformLocation, texture: WebGLTexture, unit: number): void {
    this.gl.activeTexture(this.gl.TEXTURE0 + unit);
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    this.gl.uniform1i(location, unit);
  }
  
  // Boolean (as int)
  setBool(location: WebGLUniformLocation, value: boolean): void {
    this.gl.uniform1i(location, value ? 1 : 0);
  }
}
```

---

### 3.1.1.4: 셰이더 캐싱 시스템

**파일**: `frontend/src/webgl/ShaderCache.ts`

```typescript
class ShaderCache {
  private gl: WebGL2RenderingContext;
  private cache: Map<string, ShaderProgram> = new Map();
  
  constructor(gl: WebGL2RenderingContext) {
    this.gl = gl;
  }
  
  private generateKey(vertexSource: string, fragmentSource: string): string {
    const vHash = this.simpleHash(vertexSource);
    const fHash = this.simpleHash(fragmentSource);
    return `${vHash}_${fHash}`;
  }
  
  private simpleHash(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(36);
  }
  
  get(vertexSource: string, fragmentSource: string): ShaderProgram | null {
    const key = this.generateKey(vertexSource, fragmentSource);
    return this.cache.get(key) || null;
  }
  
  getOrCreate(options: ShaderProgramOptions): ShaderProgram {
    const key = this.generateKey(options.vertexSource, options.fragmentSource);
    let program = this.cache.get(key);
    if (!program) {
      program = new ShaderProgram(this.gl, options);
      this.cache.set(key, program);
    }
    return program;
  }
  
  set(vertexSource: string, fragmentSource: string, program: ShaderProgram): void {
    const key = this.generateKey(vertexSource, fragmentSource);
    const existing = this.cache.get(key);
    if (existing && existing !== program) {
      existing.dispose();
    }
    this.cache.set(key, program);
  }
  
  clear(): void {
    this.cache.forEach(program => program.dispose());
    this.cache.clear();
  }
}
```

---

## 3. 완료 기준

- [ ] 셰이더 컴파일 및 에러 리포팅
- [ ] 프로그램 링킹 성공
- [ ] 유니폼 타입별 바인딩 동작
- [ ] 셰이더 캐싱으로 재컴파일 방지

---

## 4. 다음 단계

→ v3.1.2: WebGL 텍스처 관리
