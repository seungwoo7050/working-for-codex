# CLAUDE.md - native-video-editor v4.1 GPU 가속 (GPU 필터 체인)

> 이 문서는 Claude AI 코딩 에이전트가 프로젝트 컨텍스트를 이해하기 위한 가이드입니다.

## 프로젝트 개요

### 선행 조건
- v4.0.0 HW 디코더 완료
- GPU 메모리에 디코딩된 프레임 유지 가능

### 현재 상태 (v4.0.0)
- 플랫폼별 하드웨어 디코더 통합 (NVDEC, VideoToolbox 등)
- 디코딩된 프레임이 GPU 메모리에 유지
- 기존 WebGL/WebAudio 기능 유지

### 목표 상태 (v4.1.0)
- **목표**: GPU 메모리에서 직접 필터 처리 (제로카피)
- **핵심 변경**: CUDA/Metal 기반 GPU 필터 체인 구현
- **성능 향상**: 필터 적용 속도 10-20배 향상

## 아키텍처

### 현재 (v4.0 - HW 디코딩)
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Input     │────▶│ HW Decoder  │────▶│   Output    │
│   Video     │     │ (GPU 메모리)│     │   Video     │
└─────────────┘     └─────────────┘     └─────────────┘
```

### 목표 (v4.1 - GPU 필터)
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Input     │────▶│ HW Decoder  │────▶│ GPU Filters │────▶│   Output    │
│   Video     │     │ (GPU 메모리)│     │ (CUDA/Metal)│     │   Video     │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
                          │                   │                   │
                       GPU 메모리 ────────────┴───────────────────┘
```

## 구현할 기능

### Phase 2: GPU 필터 체인 (Week 3-4)

#### 2.1 필터 인터페이스
```cpp
// GPUFilter.hpp
class IGPUFilter {
public:
    virtual ~IGPUFilter() = default;
    
    struct Frame {
        void* gpuBuffer;
        int width, height;
        AVPixelFormat format;
    };
    
    virtual Frame process(const Frame& input) = 0;
    virtual std::string name() const = 0;
};
```

#### 2.2 CUDA 필터 예시: 색보정
```cpp
// CUDAColorCorrection.cu
__global__ void colorCorrectionKernel(
    unsigned char* input,
    unsigned char* output,
    int width, int height,
    float brightness,    // -1.0 ~ 1.0
    float contrast,      // 0.0 ~ 2.0
    float saturation     // 0.0 ~ 2.0
) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    
    if (x >= width || y >= height) return;
    
    int idx = (y * width + x) * 3;
    
    // RGB 읽기
    float r = input[idx] / 255.0f;
    float g = input[idx + 1] / 255.0f;
    float b = input[idx + 2] / 255.0f;
    
    // 밝기 조절
    r += brightness;
    g += brightness;
    b += brightness;
    
    // 대비 조절
    r = (r - 0.5f) * contrast + 0.5f;
    g = (g - 0.5f) * contrast + 0.5f;
    b = (b - 0.5f) * contrast + 0.5f;
    
    // 채도 조절 (HSL 변환 필요, 간략화)
    float gray = 0.299f * r + 0.587f * g + 0.114f * b;
    r = gray + (r - gray) * saturation;
    g = gray + (g - gray) * saturation;
    b = gray + (g - gray) * saturation;
    
    // 클램프 및 출력
    output[idx] = (unsigned char)(fminf(fmaxf(r, 0.0f), 1.0f) * 255.0f);
    output[idx + 1] = (unsigned char)(fminf(fmaxf(g, 0.0f), 1.0f) * 255.0f);
    output[idx + 2] = (unsigned char)(fminf(fmaxf(b, 0.0f), 1.0f) * 255.0f);
}
```

```cpp
// CUDAColorCorrection.cpp
class CUDAColorCorrection : public IGPUFilter {
public:
    struct Params {
        float brightness = 0.0f;
        float contrast = 1.0f;
        float saturation = 1.0f;
    };

    Frame process(const Frame& input) override {
        // CUDA 메모리 할당
        unsigned char* d_output;
        cudaMalloc(&d_output, input.width * input.height * 3);
        
        // 커널 실행
        dim3 block(16, 16);
        dim3 grid((input.width + 15) / 16, (input.height + 15) / 16);
        
        colorCorrectionKernel<<<grid, block>>>(
            (unsigned char*)input.gpuBuffer,
            d_output,
            input.width, input.height,
            params_.brightness, params_.contrast, params_.saturation
        );
        
        return Frame{d_output, input.width, input.height, input.format};
    }

private:
    Params params_;
};
```

#### 2.3 Metal 필터 예시 (macOS)
```cpp
// MetalColorCorrection.mm
class MetalColorCorrection : public IGPUFilter {
public:
    Frame process(const Frame& input) override {
        // Metal 커맨드 큐 및 버퍼 설정
        id<MTLCommandQueue> queue = [device_ newCommandQueue];
        id<MTLCommandBuffer> buffer = [queue commandBuffer];
        
        // Metal 셰이더 실행
        // ...
        
        return Frame{outputBuffer, input.width, input.height, input.format};
    }

private:
    id<MTLDevice> device_;
    id<MTLLibrary> library_;
};
```

#### 2.4 필터 체인
```cpp
// FilterChain.hpp
class FilterChain {
public:
    void addFilter(std::unique_ptr<IGPUFilter> filter) {
        filters_.push_back(std::move(filter));
    }

    IGPUFilter::Frame process(const IGPUFilter::Frame& input) {
        IGPUFilter::Frame current = input;
        
        for (auto& filter : filters_) {
            current = filter->process(current);
        }
        
        return current;
    }

private:
    std::vector<std::unique_ptr<IGPUFilter>> filters_;
};

// 사용 예시
FilterChain chain;
chain.addFilter(std::make_unique<CUDAColorCorrection>(brightness=0.1));
chain.addFilter(std::make_unique<CUDAScale>(1920, 1080));
chain.addFilter(std::make_unique<CUDABlur>(radius=5));
```

#### 2.5 추가 필터 구현
- **CUDAScale**: 해상도 변경
- **CUDABlur**: 블러 효과
- **CUDASharpen**: 선명도 향상
- **Metal counterparts**: macOS용 Metal 구현

## 구현 순서

1. **Week 3**: IGPUFilter 인터페이스 및 CUDA 색보정 필터
2. **Week 4**: Metal 필터 및 필터 체인 통합
3. **테스트**: 필터 체인 성능 측정, GPU 메모리 관리 확인

## 호환성 요구사항

- v4.0 HW 디코더와 통합 (GPU 메모리 공유)
- 기존 CPU 필터와 병행 사용 가능
- GPU 지원되지 않는 경우 CPU 필터로 폴백
- WebGL 필터와의 시너지 (프론트엔드 미리보기 연동)

## 성공 지표

- [ ] 색보정 필터 10배 이상 성능 향상
- [ ] 필터 체인 GPU 메모리에서 완전 처리
- [ ] CUDA/Metal 플랫폼 지원
- [ ] 기존 v3.x 기능 유지

---

*Generated: 2025년 12월 6일*  
*For Claude AI Implementation*