# WebGL 렌더링 파이프라인 설계 일지 (v3.1.3)
> Phase 3.1 - 고급 렌더링 기법

## 1. 문제 정의 & 요구사항

### 1.1 핵심 목표

**v3.1.3 - WebGL Rendering Pipeline**:
- **프레임버퍼**: 오프스크린 렌더링
- **렌더버퍼**: 깊이/스텐실 버퍼
- **다중 패스 렌더링**: 복잡한 효과 체인
- **포스트 프로세싱**: 블룸, 블러 등

---

## 2. 패치별 상세 설계

### 3.1.3.1: 프레임버퍼 객체

**파일**: `frontend/src/webgl/Framebuffer.ts`

```typescript
interface FramebufferOptions {
  width: number;
  height: number;
  colorAttachments?: number;
  depthBuffer?: boolean;
  stencilBuffer?: boolean;
}

class Framebuffer {
  private gl: WebGL2RenderingContext;
  private fbo: WebGLFramebuffer;
  private colorTextures: WebGLTexture[] = [];
  private depthRenderbuffer: WebGLRenderbuffer | null = null;
  
  constructor(gl: WebGL2RenderingContext, options: FramebufferOptions) {
    this.gl = gl;
    this.fbo = gl.createFramebuffer()!;
    this.setup(options);
  }
  
  bind(): void {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
  }
  
  unbind(): void {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
  }
  
  getColorTexture(index = 0): WebGLTexture {
    return this.colorTextures[index];
  }
}
```

---

### 3.1.3.2: 렌더버퍼 관리

**파일**: `frontend/src/webgl/Renderbuffer.ts`

```typescript
type RenderbufferFormat = 'depth16' | 'depth24' | 'depth24stencil8';

class Renderbuffer {
  private gl: WebGL2RenderingContext;
  private rbo: WebGLRenderbuffer;
  
  constructor(gl: WebGL2RenderingContext, width: number, height: number, format: RenderbufferFormat) {
    this.gl = gl;
    this.rbo = gl.createRenderbuffer()!;
    
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.rbo);
    
    const internalFormat = this.getInternalFormat(format);
    gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
  }
  
  private getInternalFormat(format: RenderbufferFormat): number {
    switch (format) {
      case 'depth16': return this.gl.DEPTH_COMPONENT16;
      case 'depth24': return this.gl.DEPTH_COMPONENT24;
      case 'depth24stencil8': return this.gl.DEPTH24_STENCIL8;
    }
  }
}
```

---

### 3.1.3.3: 다중 패스 렌더링

**파일**: `frontend/src/webgl/MultiPassRenderer.ts`

```typescript
interface RenderPass {
  name: string;
  shader: ShaderProgram;
  inputs: WebGLTexture[];
  output: Framebuffer | null; // null = 화면 출력
  setup?: () => void;
}

class MultiPassRenderer {
  private gl: WebGL2RenderingContext;
  private passes: RenderPass[] = [];
  private quadVAO: WebGLVertexArrayObject;
  
  addPass(pass: RenderPass): void {
    this.passes.push(pass);
  }
  
  render(): void {
    for (const pass of this.passes) {
      if (pass.output) {
        pass.output.bind();
      } else {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
      }
      
      pass.shader.use();
      pass.setup?.();
      
      // Bind input textures
      pass.inputs.forEach((tex, i) => {
        this.gl.activeTexture(this.gl.TEXTURE0 + i);
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
      });
      
      // Draw fullscreen quad
      this.gl.bindVertexArray(this.quadVAO);
      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }
  }
}
```

---

### 3.1.3.4: 포스트 프로세싱

**파일**: `frontend/src/webgl/PostProcessor.ts`

```typescript
type PostEffect = 'blur' | 'bloom' | 'sharpen' | 'vignette';

class PostProcessor {
  private gl: WebGL2RenderingContext;
  private effects: Map<PostEffect, ShaderProgram> = new Map();
  
  // Gaussian Blur 셰이더
  private readonly BLUR_FRAGMENT = `#version 300 es
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDirection;
    in vec2 vTexCoord;
    out vec4 fragColor;
    
    void main() {
      vec2 texelSize = 1.0 / vec2(textureSize(uTexture, 0));
      vec4 result = vec4(0.0);
      float weights[5] = float[](0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);
      
      for (int i = 0; i < 5; i++) {
        vec2 offset = uDirection * texelSize * float(i);
        result += texture(uTexture, vTexCoord + offset) * weights[i];
        result += texture(uTexture, vTexCoord - offset) * weights[i];
      }
      
      fragColor = result;
    }
  `;
  
  applyBlur(input: WebGLTexture, iterations: number): WebGLTexture {
    // Ping-pong blur implementation
    // ...
  }
}
```

---

## 3. 완료 기준

- [ ] FBO 기반 오프스크린 렌더링
- [ ] 깊이/스텐실 버퍼 동작
- [ ] 다중 패스 효과 적용
- [ ] 포스트 프로세싱 효과 동작 (blur, bloom 등)

---

## 4. 다음 단계

→ v3.1.4: WebGL 성능 최적화
