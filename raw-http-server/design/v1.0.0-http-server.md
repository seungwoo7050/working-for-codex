# HTTP/1.1 Server from Raw Sockets (Milestone 1.1)

> Building a multi-threaded HTTP server using Python sockets and ThreadPoolExecutor

## 1. Problem Definition & Requirements

### 1.1 Project Goal

**Objective**: Implement an HTTP/1.1 server from scratch using raw TCP sockets

**Why Build This**:
- Understand HTTP as a text-based protocol over TCP
- Learn socket programming fundamentals
- Experience thread pool management
- Foundation for web framework (Milestone 1.2)

**Educational Value**: Most developers never see below the framework abstraction. This milestone reveals what libraries like `http.server`, Express, or Spring Boot hide.

### 1.2 Functional Requirements

1. **TCP Server**
   - Listen on configurable port (default 8080)
   - Accept multiple concurrent connections
   - Handle 100+ simultaneous clients

2. **HTTP/1.1 Protocol**
   - Parse HTTP request (method, path, headers, body)
   - Support GET, POST methods
   - Generate valid HTTP responses
   - Include status codes (200, 404, 500)

3. **Routing**
   - Basic path-to-handler mapping
   - Extract path parameters (e.g., `/users/{id}`)
   - Return 404 for unmatched routes

4. **Concurrency**
   - Thread pool for connection handling
   - Graceful shutdown
   - No resource leaks (sockets closed)

### 1.3 Non-Functional Requirements

- **Performance**: Handle 1,000+ requests/sec on local machine
- **Reliability**: No crashes on malformed requests
- **Code Quality**: Clear error messages, logging
- **Resource Management**: RAII-style socket cleanup

### 1.4 Out of Scope (For This Milestone)

- âŒ HTTPS/TLS
- âŒ HTTP/2 or HTTP/3
- âŒ Middleware pipeline (comes in Milestone 1.2)
- âŒ Dependency injection (comes in Milestone 1.2)
- âŒ Static file serving
- âŒ WebSocket support

---

## 2. Technical Background & Design Motivation

### 2.1 Why Raw Sockets Instead of `http.server`?

**Python `http.server` Module**:
```python
# What most tutorials show
from http.server import HTTPServer, BaseHTTPRequestHandler
server = HTTPServer(('localhost', 8080), RequestHandler)
server.serve_forever()
```

**Problem**: Hides TCP/IP fundamentals

**Our Approach**: Build from `socket` module
```python
import socket
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('0.0.0.0', 8080))
server_socket.listen()
# ... manual HTTP parsing
```

**What You Learn**:
- TCP three-way handshake
- Socket options (`SO_REUSEADDR`)
- Buffer management (`recv`, `send`)
- Connection lifecycle
- HTTP as text protocol

### 2.2 Concurrency Model: Thread-per-Connection

**Alternatives Considered**:

1. **Single-threaded event loop** (`select`/`poll`)
   - âœ… Efficient for many idle connections
   - âŒ Complex state management
   - âŒ Not how traditional frameworks work

2. **Thread-per-connection** (chosen)
   - âœ… Simple mental model
   - âœ… Matches Spring Boot (Tomcat), Gunicorn
   - âœ… Easy to reason about state
   - âŒ Limited by GIL (acceptable for learning)

3. **Async/await** (`asyncio`)
   - âœ… Modern Python approach
   - âŒ More advanced (defer to future milestone)

**Decision**: Thread-per-connection for educational clarity

### 2.3 HTTP/1.1 Basics

**HTTP Request Format**:
```
GET /api/users/42 HTTP/1.1\r\n
Host: localhost:8080\r\n
Content-Type: application/json\r\n
Content-Length: 15\r\n
\r\n
{"query":"..."}
```

**HTTP Response Format**:
```
HTTP/1.1 200 OK\r\n
Content-Type: application/json\r\n
Content-Length: 18\r\n
\r\n
{"status":"ok"}
```

**Key Observations**:
- Line delimiter: `\r\n` (CRLF)
- Header separator: Blank line (`\r\n\r\n`)
- Body length specified in `Content-Length`

---

## 3. System Architecture

### 3.1 Component Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  HTTP Server                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â”œâ”€ [1] TCP Socket (server_socket)
              â”‚    - bind(port)
              â”‚    - listen(backlog)
              â”‚    - accept() â†’ client_socket
              â”‚
              â”œâ”€ [2] ThreadPoolExecutor
              â”‚    - max_workers = 100
              â”‚    - submit(handle_connection, socket)
              â”‚
              â”œâ”€ [3] Router
              â”‚    - Map: (method, path) â†’ handler
              â”‚    - resolve(method, path) â†’ (handler, params)
              â”‚
              â””â”€ [4] HttpRequest/HttpResponse
                   - Parse request from bytes
                   - Format response to bytes
```

### 3.2 Request Handling Flow

```
Client connects
    â†“
1. accept() returns client_socket
    â†“
2. Submit to ThreadPoolExecutor
    â†“
3. _handle_connection(client_socket)
    â”œâ”€â”€ Parse HTTP request
    â”œâ”€â”€ Router.resolve(method, path)
    â”œâ”€â”€ Call handler(request)
    â”œâ”€â”€ Build HTTP response
    â””â”€â”€ Send response bytes
    â†“
4. Close socket
    â†“
Thread returns to pool
```

### 3.3 Module Structure

```
milestone-1.1/
â”œâ”€â”€ http_server.py      # HttpServer, HttpResponse classes
â”œâ”€â”€ http_parser.py      # HttpRequest.from_socket()
â”œâ”€â”€ router.py           # Router class, route registration
â””â”€â”€ main.py             # Entry point, example routes
```

---

## 4. Data Models

### 4.1 HttpRequest

**Purpose**: Represent parsed HTTP request

**Implementation** (`http_parser.py`):
```python
@dataclass
class HttpRequest:
    method: str           # "GET", "POST", etc.
    path: str             # "/api/users/42"
    version: str          # "HTTP/1.1"
    headers: Dict[str, str]  # {"host": "localhost", ...}
    body: str             # Request body (if any)
    path_params: Dict[str, str] = field(default_factory=dict)

    @classmethod
    def from_socket(cls, socket: socket.socket) -> Optional["HttpRequest"]:
        """Parse HTTP request from socket bytes."""
        # Read request line: "GET /path HTTP/1.1\r\n"
        # Read headers until blank line
        # Read body if Content-Length present
```

**Parsing Strategy**:
1. Read until first `\r\n` â†’ Request line
2. Split by spaces â†’ `[method, path, version]`
3. Read headers until `\r\n\r\n`
4. If `Content-Length` exists, read N bytes â†’ body

### 4.2 HttpResponse

**Purpose**: Build and serialize HTTP response

**Implementation** (`http_server.py`):
```python
@dataclass
class HttpResponse:
    status_code: int      # 200, 404, 500, etc.
    body: str             # Response payload
    headers: Dict[str, str] = field(default_factory=dict)

    def to_bytes(self) -> bytes:
        """Convert to HTTP wire format."""
        reason = _STATUS_REASONS[self.status_code]  # "OK", "Not Found"
        body_bytes = self.body.encode("utf-8")

        headers = {
            "Content-Length": str(len(body_bytes)),
            "Content-Type": self.headers.get("Content-Type", "application/json"),
            **self.headers
        }

        header_lines = "\r\n".join(f"{k}: {v}" for k, v in headers.items())
        http_response = f"HTTP/1.1 {status_code} {reason}\r\n"
        http_response += f"{header_lines}\r\n\r\n"

        return http_response.encode("utf-8") + body_bytes
```

**Helper Methods**:
```python
HttpResponse.ok(payload="")            # 200 OK
HttpResponse.not_found(message="")      # 404 Not Found
HttpResponse.server_error(message="")   # 500 Internal Server Error
```

### 4.3 Router

**Purpose**: Map (method, path) to handler functions

**Implementation** (`router.py`):
```python
class Router:
    def __init__(self):
        self._routes: List[Tuple[str, str, Callable]] = []

    def register(self, method: str, path: str, handler: Callable):
        """Add route to routing table."""
        self._routes.append((method.upper(), path, handler))

    def resolve(self, method: str, path: str) -> Tuple[Callable, Dict[str, str]]:
        """Find handler and extract path parameters."""
        for route_method, route_path, handler in self._routes:
            if route_method != method:
                continue

            params = self._match_path(route_path, path)
            if params is not None:
                return handler, params

        raise RouteNotFound(f"{method} {path}")

    def _match_path(self, pattern: str, path: str) -> Optional[Dict[str, str]]:
        """Match path pattern like /users/{id}."""
        pattern_parts = pattern.strip("/").split("/")
        path_parts = path.strip("/").split("/")

        if len(pattern_parts) != len(path_parts):
            return None

        params = {}
        for pattern_part, path_part in zip(pattern_parts, path_parts):
            if pattern_part.startswith("{") and pattern_part.endswith("}"):
                param_name = pattern_part[1:-1]
                params[param_name] = path_part
            elif pattern_part != path_part:
                return None

        return params
```

**Example Usage**:
```python
router = Router()
router.register("GET", "/users/{id}", get_user_handler)

# Request: GET /users/42
handler, params = router.resolve("GET", "/users/42")
# handler = get_user_handler
# params = {"id": "42"}
```

---

## 5. Detailed Implementation

### 5.1 HttpServer Core

**File**: `http_server.py`

```python
class HttpServer:
    def __init__(
        self,
        host: str = "0.0.0.0",
        port: int = 8080,
        router: Optional[Router] = None,
        max_workers: int = 100
    ):
        self.host = host
        self.port = port
        self.router = router or Router()
        self.max_workers = max_workers
        self._is_running = False

    def start(self) -> None:
        """Start HTTP server."""
        self._is_running = True

        # Create TCP socket
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
            # Allow port reuse (avoid "Address already in use")
            server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

            # Bind to address
            server_socket.bind((self.host, self.port))

            # Listen for connections (backlog queue)
            server_socket.listen()

            # Set timeout for accept() (allows checking _is_running)
            server_socket.settimeout(1.0)

            LOGGER.info("HTTP server listening on %s:%s", self.host, self.port)

            # Accept loop with thread pool
            with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                while self._is_running:
                    try:
                        client_socket, address = server_socket.accept()
                    except socket.timeout:
                        continue  # Check _is_running flag
                    except OSError:
                        break  # Server socket closed

                    # Handle connection in thread pool
                    executor.submit(self._handle_connection, client_socket, address)

    def _handle_connection(self, client_socket: socket.socket, address):
        """Handle single client connection."""
        with client_socket:  # Ensure socket is closed
            try:
                # Parse HTTP request
                request = HttpRequest.from_socket(client_socket)
                if request is None:
                    return  # Empty request (client disconnected)

                # Resolve route
                try:
                    handler, params = self.router.resolve(request.method, request.path)
                    request.path_params = params
                    response = handler(request)

                    if not isinstance(response, HttpResponse):
                        raise TypeError("Handler must return HttpResponse")

                except RouteNotFound:
                    response = HttpResponse.not_found('{"error":"not_found"}')

                except Exception as exc:
                    LOGGER.exception("Error handling request: %s", exc)
                    response = HttpResponse.server_error()

                # Send response
                client_socket.sendall(response.to_bytes())

            except ValueError as exc:
                # Malformed HTTP request
                LOGGER.warning("Bad request from %s: %s", address, exc)
                error_response = HttpResponse(status_code=400, body='{"error":"bad_request"}')
                client_socket.sendall(error_response.to_bytes())

            except Exception as exc:
                LOGGER.exception("Unexpected error: %s", exc)
```

**Key Design Choices**:

1. **Context Manager (`with` statement)**
   - Ensures `server_socket` and `client_socket` are closed
   - Prevents resource leaks

2. **SO_REUSEADDR**
   - Allows restarting server without "Address already in use" error
   - TIME_WAIT state after shutdown

3. **Timeout on `accept()`**
   - Allows checking `_is_running` flag
   - Enables graceful shutdown

4. **ThreadPoolExecutor**
   - Limits concurrent threads (prevents resource exhaustion)
   - Automatic thread lifecycle management

### 5.2 HTTP Parsing

**File**: `http_parser.py`

```python
class HttpRequest:
    @classmethod
    def from_socket(cls, conn: socket.socket) -> Optional["HttpRequest"]:
        """Parse HTTP request from socket."""
        buffer = conn.makefile("rb")  # Buffered reader

        try:
            # 1. Read request line: "GET /path HTTP/1.1\r\n"
            request_line = buffer.readline().decode("iso-8859-1").strip()
            if not request_line:
                return None  # Connection closed

            parts = request_line.split()
            if len(parts) != 3:
                raise ValueError(f"Malformed request line: {request_line!r}")

            method, target, version = parts

            # Extract path (ignore query string for now)
            path = target.split("?")[0]

            # 2. Read headers until blank line
            headers: Dict[str, str] = {}
            while True:
                line = buffer.readline().decode("iso-8859-1")
                if line in ("\r\n", "\n", ""):
                    break  # End of headers

                if ":" not in line:
                    raise ValueError(f"Malformed header: {line!r}")

                name, value = line.split(":", 1)
                headers[name.strip().lower()] = value.strip()

            # 3. Read body (if Content-Length present)
            body = ""
            content_length = headers.get("content-length")
            if content_length:
                length = int(content_length)
                body_bytes = buffer.read(length)
                body = body_bytes.decode("utf-8", errors="replace")

            return cls(
                method=method.upper(),
                path=path,
                version=version,
                headers=headers,
                body=body
            )

        finally:
            buffer.close()
```

**Parsing Challenges**:

1. **Line Endings**: HTTP uses `\r\n`, but Python `readline()` handles both `\r\n` and `\n`
2. **Character Encoding**: Request line and headers use ISO-8859-1, body uses UTF-8
3. **Content-Length**: Must read exact number of bytes (not until EOF)
4. **Empty Requests**: Client may disconnect before sending data

### 5.3 Example Routes

**File**: `main.py`

```python
from http_server import HttpServer, HttpResponse
from router import Router

def health_handler(request) -> HttpResponse:
    """Health check endpoint."""
    return HttpResponse.ok('{"status":"up"}')

def get_user_handler(request) -> HttpResponse:
    """Get user by ID."""
    user_id = request.path_params["id"]
    return HttpResponse.ok(f'{{"user_id":"{user_id}"}}')

def main():
    router = Router()
    router.register("GET", "/health", health_handler)
    router.register("GET", "/users/{id}", get_user_handler)

    server = HttpServer(host="0.0.0.0", port=8080, router=router)
    server.start()

if __name__ == "__main__":
    main()
```

---

## 6. Validation Strategy

### 6.1 Manual Testing

**Test 1: Basic Routing**
```bash
# Start server
python -m milestone-1.1.main

# Test health endpoint
$ curl http://localhost:8080/health
{"status":"up"}

# Test path parameters
$ curl http://localhost:8080/users/42
{"user_id":"42"}

# Test 404
$ curl http://localhost:8080/nonexistent
{"error":"not_found"}
```

**Test 2: Concurrent Connections**
```bash
# Load test with ApacheBench
ab -n 1000 -c 100 http://localhost:8080/health

# Expected output:
# Requests per second: ~1,826
# Time per request: ~54ms (mean)
# Failed requests: 0
```

**Test 3: Malformed Requests**
```bash
# Send invalid HTTP
echo -ne "INVALID REQUEST\r\n\r\n" | nc localhost 8080

# Expected: 400 Bad Request
```

### 6.2 Validation Checklist

- [x] Server starts on port 8080
- [x] Accepts HTTP GET requests
- [x] Returns 200 OK with valid JSON
- [x] Returns 404 for unmatched routes
- [x] Handles 100+ concurrent connections
- [x] No resource leaks (sockets closed)
- [x] Graceful shutdown (Ctrl+C)
- [x] Path parameters extracted correctly
- [x] POST requests with body parsed correctly

### 6.3 Evidence

**Validation Report**: `docs/evidence/m1.1/validation-report.md`
**Code Walkthrough**: `docs/evidence/m1.1/code-walkthrough.md`

---

## 7. Performance Characteristics

### 7.1 Benchmarks

**Environment**:
- Machine: M1 Mac / Ubuntu 22.04
- Python: 3.11
- Test: ApacheBench (ab)

**Results**:
```
ab -n 10000 -c 100 http://localhost:8080/health

Concurrency Level:      100
Time taken for tests:   5.476 seconds
Complete requests:      10000
Failed requests:        0
Requests per second:    1826.31 [#/sec] (mean)
Time per request:       54.758 [ms] (mean)
Time per request:       0.548 [ms] (mean, across all concurrent requests)
```

**Analysis**:
- **~1,826 req/sec**: Acceptable for educational project
- **54ms latency**: Mostly thread scheduling overhead
- **0 failures**: Stable under load

### 7.2 Bottlenecks

1. **Python GIL**: Limits true parallelism
   - Only one thread executing Python bytecode at a time
   - I/O operations (socket recv/send) release GIL

2. **Thread Overhead**: Each thread ~1MB memory
   - 100 threads = ~100MB overhead
   - Context switching penalty

3. **Sequential Request Parsing**: No HTTP pipelining
   - One request per connection
   - No keep-alive support (yet)

### 7.3 Comparison: mini-spring vs Production Servers

| Server | Requests/sec | Notes |
|--------|--------------|-------|
| mini-spring (this) | ~1,826 | Educational, thread-per-connection |
| Gunicorn (Python) | ~5,000 | Production WSGI server |
| Node.js (Express) | ~15,000 | Event loop, single-threaded |
| Spring Boot (Tomcat) | ~20,000+ | NIO connector, optimized |

**Takeaway**: We're 10x slower than production, but that's expected for educational code

---

## 8. Known Limitations & Future Work

### 8.1 Current Limitations

1. **No Keep-Alive**
   - Each connection handles one request then closes
   - HTTP/1.1 persistent connections not implemented

2. **No Chunked Transfer Encoding**
   - Only supports `Content-Length` for body size
   - Can't handle streaming responses

3. **Basic Error Handling**
   - Returns generic 500 errors
   - No detailed error messages for debugging

4. **Single Process**
   - Can't utilize multiple CPU cores
   - (GIL prevents true parallelism anyway)

### 8.2 Future Enhancements (Milestone 1.2)

- **Middleware Pipeline**: Pre/post request processing
- **Dependency Injection**: Share resources between handlers
- **Request/Response Abstraction**: Clean API for handlers
- **JSON Parsing Helpers**: Automatic request.json() parsing

---

## 9. Key Learnings

### 9.1 Technical Insights

1. **HTTP is Simple**: Just text over TCP
   - Request line + headers + optional body
   - Response follows same format

2. **Sockets Require Careful Management**
   - Must close sockets (resource leak)
   - `SO_REUSEADDR` prevents "Address in use" errors
   - Timeouts enable graceful shutdown

3. **Threading is Tricky**
   - ThreadPoolExecutor simplifies thread management
   - GIL limits Python parallelism
   - Context switching has overhead

4. **Parsing is Error-Prone**
   - Must handle malformed requests gracefully
   - Character encoding matters (ISO-8859-1 vs UTF-8)
   - Buffer management requires care

### 9.2 Design Patterns Learned

1. **RAII (Resource Acquisition Is Initialization)**
   - Python: `with` statement
   - Ensures cleanup even on exceptions

2. **Thread Pool Pattern**
   - Limits resource usage
   - Amortizes thread creation cost

3. **Routing Table**
   - Linear search acceptable for small scale
   - Trie structure for production (see Spring Boot)

---

## 10. Connection to Next Milestone

### Milestone 1.1 â†’ 1.2 Transition

**What We Have**:
- âœ… HTTP server accepting connections
- âœ… Request/response parsing
- âœ… Basic routing

**What We Need** (Milestone 1.2):
- ðŸ”² Middleware pipeline (logging, auth, etc.)
- ðŸ”² Dependency injection (share DB connections)
- ðŸ”² Better request/response abstractions
- ðŸ”² Decorator-based routing (`@app.route()`)

**Upgrade Path**:
```python
# Milestone 1.1 (current)
def get_user(request):
    return HttpResponse.ok('{"user":"..."}')

# Milestone 1.2 (next)
@app.route("/users/{id}", methods=["GET"])
@app.middleware(auth_required)
def get_user(request, id, db=inject(Database)):
    user = db.get_user(id)
    return {"user": user}  # Automatic JSON serialization
```

---

## References

- **RFC 7230**: HTTP/1.1 Message Syntax and Routing
- **RFC 7231**: HTTP/1.1 Semantics and Content
- **Python Socket Programming**: [docs.python.org/3/library/socket.html](https://docs.python.org/3/library/socket.html)
- **ThreadPoolExecutor**: [docs.python.org/3/library/concurrent.futures.html](https://docs.python.org/3/library/concurrent.futures.html)
