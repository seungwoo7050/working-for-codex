# raw-http-server - 초기 설계 문서 (0.0)

> **"프레임워크 없이 프레임워크를 만들다"**  
> 원시 소켓으로부터 웹 프레임워크까지, 장인정신으로 한 줄씩 쌓아가는 여정

---

## 1. 프로젝트 비전

### 1.1 왜 이 프로젝트인가?

**문제 인식**:
```
"Spring Boot가 @RestController를 어떻게 처리하나요?"
"... 자동으로요?"

"TCP 연결 위에서 HTTP가 어떻게 동작하나요?"
"... 라이브러리가요?"
```

대부분의 개발자들은 프레임워크를 **사용**하지만, **이해**하지 못한다.

Django, Express, Spring Boot 위에서 코드를 작성하면서:
- HTTP가 실제로 어떤 텍스트 형식인지 모른다
- 쓰레드 풀이 왜 필요한지 체감하지 못한다
- DI 컨테이너가 어떻게 의존성을 주입하는지 마법처럼 느낀다
- 커넥션 풀의 존재 이유를 설명하지 못한다

**해결책**: 모든 것을 **밑바닥부터** 직접 구현한다.

### 1.2 프로젝트 정체성

**이름**: raw-http-server  
**철학**: "소켓에서 시작해서 프레임워크까지, 한 단계씩 장인정신으로"  
**핵심 가치**: 추상화 제거, 원리 이해, 직접 구현

**비유**:
```
요리사가 되려면 재료의 본질을 알아야 한다.

레토르트 음식(프레임워크)으로 요리하는 것이 아니라,
재료(소켓, 바이트)부터 시작해서
요리(웹 서비스)를 완성하는 것.

그래야 레시피(프레임워크)를 읽을 수 있고,
새로운 요리(시스템)를 창조할 수 있다.
```

### 1.3 목표와 비목표

**목표**:
- ✅ TCP 소켓 프로그래밍의 완전한 이해
- ✅ HTTP 프로토콜의 텍스트 기반 본질 체감
- ✅ 쓰레드 풀과 동시성 관리 직접 구현
- ✅ 의존성 주입(DI)의 원리 파악
- ✅ 커넥션 풀의 필요성과 구현 이해
- ✅ 프레임워크가 제공하는 편의성의 실체 인식

**비목표**:
- ❌ 프로덕션 레벨의 성능 (교육 목적)
- ❌ 완벽한 HTTP 스펙 준수 (핵심만)
- ❌ 모든 기능 구현 (선택과 집중)

---

## 2. 설계 철학

### 2.1 핵심 원칙

```
┌─────────────────────────────────────────────────────────┐
│               raw-http-server 설계 원칙                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 외부 라이브러리 금지 (Pure Implementation)            │
│     - HTTP 파싱? 직접 한다                               │
│     - 라우팅? 직접 한다                                  │
│     - DI? 직접 한다                                      │
│                                                         │
│  2. 계층별 분리 (Layer by Layer)                        │
│     - 각 마일스톤은 독립적으로 동작 가능                   │
│     - 아래 계층 없이 위 계층 없음                         │
│                                                         │
│  3. 점진적 복잡성 (Progressive Complexity)               │
│     - 단순 → 복잡                                       │
│     - 동기 → 비동기                                     │
│     - 단일 → 풀링                                       │
│                                                         │
│  4. 증명 가능한 학습 (Demonstrable Learning)             │
│     - 모든 구현에 대한 명확한 문서화                      │
│     - 동작 증거 스크린샷/로그                            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 2.2 기술 스택 선택

**언어**: Python 3.11+

**왜 Python인가?**
1. **낮은 진입 장벽**: 소켓/HTTP 개념에 집중 가능
2. **명확한 표현력**: 알고리즘 의도가 코드에 드러남
3. **표준 라이브러리**: `socket`, `threading`만으로 충분
4. **빠른 프로토타이핑**: 개념 검증에 적합

**금지 목록** (교육적 목적):
```
❌ http.server      → 직접 구현
❌ flask/django     → 직접 구현  
❌ requests         → 직접 구현
❌ aiohttp          → 직접 구현
❌ SQLAlchemy       → 직접 구현 (커넥션 풀)
❌ Dependency Injector → 직접 구현
```

**허용 목록**:
```
✅ socket           → TCP 기반
✅ threading        → 동시성 기반
✅ typing           → 타입 힌트
✅ dataclasses      → 데이터 구조
✅ re               → 정규표현식
✅ json             → JSON 파싱
```

### 2.3 프로젝트 구조

```
socketcraft/
├── src/
│   ├── milestone-1.1/           # HTTP 서버 (소켓)
│   │   ├── server.py            # 메인 서버
│   │   ├── http_parser.py       # HTTP 파싱
│   │   ├── http_response.py     # HTTP 응답 빌더
│   │   ├── router.py            # 기본 라우터
│   │   └── thread_pool.py       # 쓰레드 풀
│   │
│   ├── milestone-1.2/           # 미니 프레임워크
│   │   ├── framework.py         # 프레임워크 코어
│   │   ├── decorators.py        # @route, @middleware
│   │   ├── middleware.py        # 미들웨어 체인
│   │   ├── di_container.py      # 의존성 주입
│   │   └── context.py           # 요청 컨텍스트
│   │
│   ├── milestone-1.3/           # 커넥션 풀
│   │   ├── pool.py              # 제네릭 풀
│   │   ├── db_pool.py           # DB 커넥션 풀
│   │   └── health_check.py      # 연결 상태 검사
│   │
│   ├── milestone-1.4/           # 통합 앱
│   │   └── sample_app/          # CRUD 예제
│   │
│   └── milestone-1.4.5/         # Spring 브릿지
│       └── spring_concepts.py   # Spring 개념 매핑
│
├── design/
│   ├── 0.0-initial-design.md    # 이 문서
│   ├── 1.1-http-server.md
│   ├── 1.2-mini-framework.md
│   ├── 1.3-connection-pool.md
│   ├── 1.4-integration.md
│   └── 1.4.5-spring-bridge.md
│
├── docs/
│   ├── learning-journal.md      # 학습 일지
│   └── evidence/                # 동작 증거
│
├── build.sh
├── run_sample.sh
└── README.md
```

---

## 3. 로드맵

### 3.1 전체 여정

```
┌───────────────────────────────────────────────────────────────────┐
│                       raw-http-server 로드맵                           │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│  Week 1                                                           │
│  ┌─────────────────────────────────────────────────┐              │
│  │ Milestone 1.1: HTTP 서버 (Raw Sockets)          │              │
│  │ • TCP 소켓 바인딩/리스닝                         │              │
│  │ • HTTP 요청 파싱                                │              │
│  │ • 쓰레드 풀 관리                                │              │
│  │ • 기본 라우팅                                   │              │
│  └─────────────────────────────────────────────────┘              │
│         │                                                         │
│         ▼                                                         │
│  Week 2                                                           │
│  ┌─────────────────────────────────────────────────┐              │
│  │ Milestone 1.2: 미니 프레임워크                   │              │
│  │ • 데코레이터 기반 라우팅 (@route)                │              │
│  │ • 미들웨어 파이프라인                           │              │
│  │ • 의존성 주입 컨테이너                          │              │
│  │ • 요청 컨텍스트 관리                            │              │
│  └─────────────────────────────────────────────────┘              │
│         │                                                         │
│         ▼                                                         │
│  Week 3                                                           │
│  ┌─────────────────────────────────────────────────┐              │
│  │ Milestone 1.3: 커넥션 풀링                       │              │
│  │ • 제네릭 풀 구현                                │              │
│  │ • 데이터베이스 커넥션 풀                         │              │
│  │ • 쓰레드 안전성 보장                            │              │
│  │ • 상태 검사 및 재연결                           │              │
│  └─────────────────────────────────────────────────┘              │
│         │                                                         │
│         ▼                                                         │
│  Week 4-5                                                         │
│  ┌─────────────────────────────────────────────────┐              │
│  │ Milestone 1.4: 통합 샘플 애플리케이션            │              │
│  │ • 사용자 CRUD API                              │              │
│  │ • 인증 미들웨어 적용                            │              │
│  │ • DB 풀 연동                                   │              │
│  │ • 에러 핸들링                                  │              │
│  └─────────────────────────────────────────────────┘              │
│         │                                                         │
│         ▼                                                         │
│  Week 6                                                           │
│  ┌─────────────────────────────────────────────────┐              │
│  │ Milestone 1.4.5: Spring Boot 브릿지             │              │
│  │ • raw-http-server ↔ Spring 개념 매핑                │              │
│  │ • 동일 기능 비교 구현                           │              │
│  │ • Phase 2 준비                                 │              │
│  └─────────────────────────────────────────────────┘              │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

### 3.2 마일스톤별 핵심 학습

| 마일스톤 | 핵심 질문 | 답을 찾는 방법 |
|---------|---------|--------------|
| 1.1 | HTTP가 어떻게 TCP 위에서 동작하는가? | 바이트 스트림 직접 파싱 |
| 1.2 | 프레임워크가 어떻게 편의성을 제공하는가? | 데코레이터/DI 직접 구현 |
| 1.3 | 커넥션 풀이 왜 필요한가? | 생성/파괴 비용 체감 |
| 1.4 | 모든 조각이 어떻게 맞물리는가? | 실제 앱 구현 |
| 1.4.5 | Spring은 이것을 어떻게 하는가? | 개념 대응 및 비교 |

---

## 4. 아키텍처 스케치

### 4.1 계층 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                      Application Layer                          │
│                    (Milestone 1.4: 샘플 앱)                      │
│                                                                 │
│   ┌─────────────┐   ┌─────────────┐   ┌─────────────┐          │
│   │ UserHandler │   │ AuthHandler │   │ HealthCheck │          │
│   └─────────────┘   └─────────────┘   └─────────────┘          │
├─────────────────────────────────────────────────────────────────┤
│                      Framework Layer                            │
│                   (Milestone 1.2: 프레임워크)                    │
│                                                                 │
│   ┌───────────┐ ┌────────────┐ ┌──────────┐ ┌─────────────┐    │
│   │ @route()  │ │ Middleware │ │ DI Cont. │ │ Request Ctx │    │
│   │ Decorator │ │ Pipeline   │ │          │ │             │    │
│   └───────────┘ └────────────┘ └──────────┘ └─────────────┘    │
├─────────────────────────────────────────────────────────────────┤
│                      Connection Layer                           │
│                    (Milestone 1.3: 풀링)                         │
│                                                                 │
│   ┌──────────────────────────────────────────────────────┐     │
│   │              Generic Connection Pool                  │     │
│   │   ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐        │     │
│   │   │ Conn 1 │ │ Conn 2 │ │ Conn 3 │ │ Conn N │        │     │
│   │   └────────┘ └────────┘ └────────┘ └────────┘        │     │
│   └──────────────────────────────────────────────────────┘     │
├─────────────────────────────────────────────────────────────────┤
│                      HTTP Layer                                 │
│                   (Milestone 1.1: 서버)                          │
│                                                                 │
│   ┌───────────────────────────────────────────────────────┐    │
│   │                  HTTP Server Core                      │    │
│   │                                                        │    │
│   │   ┌─────────┐   ┌─────────────┐   ┌──────────────┐    │    │
│   │   │  TCP    │ → │ HTTP Parser │ → │ Thread Pool  │    │    │
│   │   │ Socket  │   │             │   │              │    │    │
│   │   └─────────┘   └─────────────┘   └──────────────┘    │    │
│   └───────────────────────────────────────────────────────┘    │
├─────────────────────────────────────────────────────────────────┤
│                      OS/Network Layer                           │
│                      (Python socket)                            │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 데이터 흐름

```
Client Request                                      Client Response
     │                                                    ▲
     ▼                                                    │
┌─────────────────────────────────────────────────────────────────┐
│ 1. TCP Accept                                                    │
│    socket.accept() → client_socket                              │
├─────────────────────────────────────────────────────────────────┤
│ 2. Thread Pool Dispatch                                          │
│    threadpool.submit(handle, client_socket)                     │
├─────────────────────────────────────────────────────────────────┤
│ 3. HTTP Parse                                                    │
│    raw_bytes → HttpRequest(method, path, headers, body)         │
├─────────────────────────────────────────────────────────────────┤
│ 4. Middleware Pipeline (순방향)                                   │
│    [Auth] → [Logging] → [CORS] → ...                           │
├─────────────────────────────────────────────────────────────────┤
│ 5. Route Matching                                                │
│    path → handler_function                                      │
├─────────────────────────────────────────────────────────────────┤
│ 6. Handler Execution                                             │
│    handler(request, context) → response_data                    │
├─────────────────────────────────────────────────────────────────┤
│ 7. Middleware Pipeline (역방향)                                   │
│    ... → [CORS] → [Logging] → [Auth]                           │
├─────────────────────────────────────────────────────────────────┤
│ 8. HTTP Response Build                                           │
│    response_data → "HTTP/1.1 200 OK\r\n..."                    │
├─────────────────────────────────────────────────────────────────┤
│ 9. TCP Send                                                      │
│    client_socket.sendall(response_bytes)                        │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. 핵심 설계

### 5.1 HTTP 파싱 (Milestone 1.1)

**HTTP 요청의 실체**:
```
GET /users/123 HTTP/1.1\r\n
Host: localhost:8080\r\n
Content-Type: application/json\r\n
\r\n
{"name": "test"}
```

**파서 설계**:
```python
@dataclass
class HttpRequest:
    method: str           # GET, POST, PUT, DELETE
    path: str             # /users/123
    version: str          # HTTP/1.1
    headers: dict         # {Host: ..., Content-Type: ...}
    body: str             # JSON 문자열
    path_params: dict     # {id: "123"}
    query_params: dict    # {page: "1", size: "10"}

class HttpParser:
    def parse(self, raw_data: bytes) -> HttpRequest:
        """
        바이트 스트림을 HttpRequest 객체로 변환
        
        1. \r\n\r\n으로 헤더와 바디 분리
        2. 첫 줄에서 method, path, version 추출
        3. 나머지 줄에서 headers 추출
        4. Content-Length에 맞춰 body 추출
        """
        pass
```

### 5.2 라우터 설계 (Milestone 1.1 → 1.2)

**기본 라우터 (1.1)**:
```python
class Router:
    def __init__(self):
        self.routes: Dict[str, Dict[str, Callable]] = {}
    
    def add_route(self, method: str, path: str, handler: Callable):
        """경로 패턴 등록"""
        pass
    
    def match(self, method: str, path: str) -> Tuple[Callable, Dict]:
        """요청을 핸들러에 매칭, path params 추출"""
        pass
```

**데코레이터 라우터 (1.2)**:
```python
def route(method: str, path: str):
    """
    @route("GET", "/users/{id}")
    def get_user(request, context, id: str):
        return {"id": id, "name": "test"}
    """
    def decorator(func):
        # 라우터에 자동 등록
        router.add_route(method, path, func)
        return func
    return decorator
```

### 5.3 쓰레드 풀 설계 (Milestone 1.1)

```python
class ThreadPool:
    """
    동시 요청 처리를 위한 쓰레드 풀
    
    왜 필요한가?
    - 요청마다 쓰레드 생성 → 비용 ↑
    - 쓰레드 재사용 → 효율 ↑
    - 최대 쓰레드 제한 → 시스템 보호
    """
    def __init__(self, max_workers: int = 100):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.active_count = 0
    
    def submit(self, func: Callable, *args) -> Future:
        """작업을 쓰레드 풀에 제출"""
        pass
    
    def shutdown(self, wait: bool = True):
        """그레이스풀 셧다운"""
        pass
```

### 5.4 미들웨어 체인 설계 (Milestone 1.2)

```
Request → [MW1] → [MW2] → [MW3] → Handler
                                      │
Response ← [MW1] ← [MW2] ← [MW3] ←────┘
```

```python
class MiddlewareChain:
    def __init__(self):
        self.middlewares: List[Middleware] = []
    
    def use(self, middleware: Middleware):
        """미들웨어 추가"""
        self.middlewares.append(middleware)
    
    def execute(self, request: HttpRequest, handler: Callable) -> HttpResponse:
        """체인 실행"""
        # 양파 껍질 구조: 
        # 바깥 → 안 → Handler → 안 → 바깥
        pass

class Middleware(ABC):
    @abstractmethod
    def before(self, request: HttpRequest, context: Context) -> Optional[HttpResponse]:
        """핸들러 실행 전"""
        pass
    
    @abstractmethod
    def after(self, response: HttpResponse, context: Context) -> HttpResponse:
        """핸들러 실행 후"""
        pass
```

### 5.5 의존성 주입 설계 (Milestone 1.2)

```python
class DIContainer:
    """
    간단한 DI 컨테이너
    
    Spring의 ApplicationContext와 유사하지만,
    어노테이션 대신 명시적 등록 사용
    """
    def __init__(self):
        self._singletons: Dict[Type, Any] = {}
        self._factories: Dict[Type, Callable] = {}
    
    def register_singleton(self, cls: Type, instance: Any):
        """싱글톤 등록 (Spring @Service와 유사)"""
        self._singletons[cls] = instance
    
    def register_factory(self, cls: Type, factory: Callable):
        """팩토리 등록 (매번 새 인스턴스)"""
        self._factories[cls] = factory
    
    def resolve(self, cls: Type) -> Any:
        """의존성 해결 (Spring @Autowired와 유사)"""
        if cls in self._singletons:
            return self._singletons[cls]
        if cls in self._factories:
            return self._factories[cls]()
        raise DependencyNotFound(cls)
```

### 5.6 커넥션 풀 설계 (Milestone 1.3)

```python
class ConnectionPool(Generic[T]):
    """
    제네릭 커넥션 풀
    
    왜 필요한가?
    - DB 연결 생성: ~50ms
    - 풀에서 가져오기: ~0.1ms
    - 500배 성능 차이!
    """
    def __init__(
        self,
        factory: Callable[[], T],
        max_size: int = 10,
        min_size: int = 2,
        timeout: float = 30.0
    ):
        self._factory = factory
        self._pool: Queue[T] = Queue(maxsize=max_size)
        self._lock = threading.Lock()
        self._created = 0
        
    def acquire(self) -> T:
        """커넥션 획득 (없으면 대기 or 생성)"""
        pass
    
    def release(self, conn: T):
        """커넥션 반환"""
        pass
    
    def health_check(self):
        """주기적 상태 검사"""
        pass
```

---

## 6. 성능 목표

### 6.1 벤치마크 기준

| 메트릭 | 목표 | 측정 방법 |
|-------|------|---------|
| 동시 연결 | 100+ | ab -c 100 |
| RPS (간단 GET) | 1,000+ | ab -n 10000 |
| 레이턴시 (p99) | < 100ms | 로깅 |
| 메모리 | < 100MB | top |

### 6.2 최적화 포인트

```
1. 쓰레드 풀 크기 조정
   - CPU 바운드: cores * 2
   - I/O 바운드: cores * 10

2. 소켓 버퍼 튜닝
   - SO_RCVBUF, SO_SNDBUF

3. 커넥션 풀 크기
   - 너무 작으면: 대기 시간 증가
   - 너무 크면: 리소스 낭비
```

---

## 7. 테스트 전략

### 7.1 테스트 계층

```
┌─────────────────────────────────────────┐
│         E2E Tests (수동)                 │
│     curl, httpie, 브라우저              │
├─────────────────────────────────────────┤
│       Integration Tests                 │
│    실제 서버 기동 + 요청                 │
├─────────────────────────────────────────┤
│         Unit Tests                      │
│    HttpParser, Router, Pool 개별        │
└─────────────────────────────────────────┘
```

### 7.2 수동 검증 체크리스트

**Milestone 1.1**:
- [ ] 서버 시작됨 (포트 바인딩)
- [ ] GET /health → 200 OK
- [ ] POST /echo → 바디 반환
- [ ] 100 동시 요청 처리
- [ ] Ctrl+C 그레이스풀 셧다운

**Milestone 1.2**:
- [ ] @route 데코레이터 동작
- [ ] 미들웨어 체인 실행
- [ ] DI로 서비스 주입
- [ ] 경로 파라미터 추출

**Milestone 1.3**:
- [ ] 풀에서 커넥션 획득/반환
- [ ] 최대 크기 초과 시 대기
- [ ] 상태 검사 동작
- [ ] 끊긴 커넥션 재연결

---

## 8. 리스크와 완화 전략

| 리스크 | 확률 | 영향 | 완화 전략 |
|-------|------|------|----------|
| HTTP 파싱 버그 | 높음 | 중간 | 에지 케이스 문서화, 점진적 구현 |
| 쓰레드 데드락 | 중간 | 높음 | Lock 순서 규칙, 타임아웃 |
| 메모리 누수 | 중간 | 높음 | 소켓 닫기 명시적 보장 |
| 학습 시간 초과 | 낮음 | 중간 | 핵심 기능만 우선 구현 |

---

## 9. 성공 지표

### 9.1 기술적 성공

- [ ] 외부 웹 프레임워크 없이 HTTP 서버 동작
- [ ] 100+ 동시 요청 처리
- [ ] CRUD API 완성
- [ ] Spring 개념과의 명확한 매핑

### 9.2 학습 성공

면접에서 대답할 수 있어야 하는 질문들:

1. **"HTTP는 어떻게 동작하나요?"**
   > "텍스트 기반 프로토콜입니다. \r\n으로 구분된 헤더와 바디로 구성되며, 
   > Content-Length로 바디 길이를 알 수 있습니다."

2. **"쓰레드 풀이 왜 필요한가요?"**
   > "쓰레드 생성 비용이 비싸기 때문입니다. 재사용하면 성능이 500배 좋아집니다."

3. **"DI란 무엇인가요?"**
   > "의존성을 외부에서 주입받는 패턴입니다. 직접 구현해보니 생성자 주입이 
   > 가장 명확하고, 테스트하기 쉬웠습니다."

4. **"커넥션 풀이 필요한 이유는?"**
   > "DB 연결 수립에 50ms, 풀에서 가져오면 0.1ms입니다. 
   > 고부하 환경에서 필수입니다."

---

## 10. 다음 단계

이 초기 설계가 완료되면:

1. **[Milestone 1.1](1.1-http-server.md)**: HTTP 서버 상세 설계로 이동
2. 각 마일스톤 완료 후 `docs/evidence/`에 동작 증거 기록
3. 최종적으로 **Phase 2: spring-commerce** 프로젝트로 연결

---

## 부록: Spring Boot와의 개념 대응

| raw-http-server | Spring Boot | 설명 |
|-------------|-------------|------|
| ThreadPool | Tomcat Thread Pool | 동시 요청 처리 |
| HttpParser | DispatcherServlet | 요청 파싱 및 라우팅 |
| @route() | @RequestMapping | 경로 매핑 |
| Middleware | Filter/Interceptor | 요청 전후 처리 |
| DIContainer | ApplicationContext | 의존성 관리 |
| ConnectionPool | HikariCP | 커넥션 풀링 |

---

*"프레임워크의 마법을 걷어내면, 거기엔 소켓과 바이트가 있다."*
