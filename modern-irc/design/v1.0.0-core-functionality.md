# modern-irc - Phase 1: Core Functionality

> TCP 소켓 서버, poll() 이벤트 루프, 기본 IRC 명령어 구현

---

## 1. 개요

### 1-1. Phase 1 목표
- TCP 소켓 기반 서버 구현
- poll() 논블로킹 I/O 멀티플렉싱
- 기본 IRC 인증 및 채널 시스템
- PRIVMSG를 통한 메시지 전송

### 1-2. 구현 범위
| 기능 | 상태 |
|------|------|
| TCP 서버 | ✅ |
| poll() 이벤트 루프 | ✅ |
| 클라이언트 관리 | ✅ |
| 인증 (PASS/NICK/USER) | ✅ |
| 채널 (JOIN/PART/NAMES/LIST) | ✅ |
| 메시지 (PRIVMSG/NOTICE) | ✅ |
| 서버 명령 (PING/PONG/QUIT) | ✅ |

---

## 2. 네트워크 레이어

### 2-1. Socket 클래스
```cpp
// network/Socket.hpp
class Socket {
public:
    Socket();
    ~Socket();
    
    void create();                    // socket() 호출
    void bind(int port);              // bind() 호출
    void listen(int backlog = 10);    // listen() 호출
    int accept();                     // accept() 호출
    void setNonBlocking(int fd);      // fcntl(O_NONBLOCK)
    void close();
    
    int getFd() const { return _fd; }
    
private:
    int _fd;
};
```

**구현 포인트:**
```cpp
void Socket::create() {
    _fd = socket(AF_INET, SOCK_STREAM, 0);
    if (_fd < 0)
        throw std::runtime_error("socket() failed");
    
    // SO_REUSEADDR 설정 (재시작 시 bind 에러 방지)
    int opt = 1;
    setsockopt(_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
}

void Socket::setNonBlocking(int fd) {
    int flags = fcntl(fd, F_GETFL, 0);
    fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}
```

### 2-2. Poller 클래스
```cpp
// network/Poller.hpp
class Poller {
public:
    void add(int fd, short events = POLLIN);
    void remove(int fd);
    int poll(int timeout = -1);       // poll() 호출
    
    bool hasEvent(int fd, short event) const;
    const std::vector<pollfd>& getFds() const { return _fds; }
    
private:
    std::vector<pollfd> _fds;
};
```

**poll() 이벤트 루프:**
```cpp
void Server::run() {
    _poller.add(_socket.getFd(), POLLIN);
    
    while (_running) {
        int ready = _poller.poll(1000);  // 1초 타임아웃
        
        for (size_t i = 0; i < _poller.getFds().size(); i++) {
            int fd = _poller.getFds()[i].fd;
            
            if (_poller.hasEvent(fd, POLLIN)) {
                if (fd == _socket.getFd())
                    handleNewConnection();
                else
                    handleClientData(fd);
            }
        }
    }
}
```

---

## 3. 핵심 클래스

### 3-1. Client 클래스
```cpp
// core/Client.hpp
class Client {
public:
    enum State {
        CONNECTED,       // 연결됨 (인증 전)
        PASSWORD_SENT,   // PASS 전송됨
        REGISTERED       // NICK + USER 완료
    };
    
    Client(int fd);
    ~Client();
    
    // Getters
    int getFd() const;
    State getState() const;
    const std::string& getNickname() const;
    const std::string& getUsername() const;
    bool isRegistered() const;
    
    // Setters
    void setState(State state);
    void setNickname(const std::string& nick);
    void setUsername(const std::string& user);
    
    // 통신
    void appendToBuffer(const std::string& data);
    std::string extractLine();          // \\r\\n 기준 한 줄 추출
    void send(const std::string& message);
    
    // 채널
    void joinChannel(Channel* channel);
    void leaveChannel(Channel* channel);
    
private:
    int _fd;
    State _state;
    std::string _nickname;
    std::string _username;
    std::string _realname;
    std::string _buffer;              // 수신 버퍼
    std::vector<Channel*> _channels;
};
```

**버퍼 처리 (부분 수신):**
```cpp
void Client::appendToBuffer(const std::string& data) {
    _buffer += data;
}

std::string Client::extractLine() {
    size_t pos = _buffer.find("\\r\\n");
    if (pos == std::string::npos)
        return "";  // 아직 완전한 명령 없음
    
    std::string line = _buffer.substr(0, pos);
    _buffer.erase(0, pos + 2);
    return line;
}
```

### 3-2. Channel 클래스
```cpp
// core/Channel.hpp
class Channel {
public:
    Channel(const std::string& name);
    
    const std::string& getName() const;
    const std::string& getTopic() const;
    void setTopic(const std::string& topic);
    
    void addClient(Client* client);
    void removeClient(Client* client);
    bool hasClient(Client* client) const;
    size_t getClientCount() const;
    
    void broadcast(const std::string& message, Client* exclude = NULL);
    std::string getNamesList() const;  // NAMES 응답용
    
private:
    std::string _name;
    std::string _topic;
    std::set<Client*> _clients;
};
```

### 3-3. Message 클래스
```cpp
// core/Message.hpp
// IRC 메시지 형식: [:prefix] COMMAND [params] [:trailing]
class Message {
public:
    static Message parse(const std::string& raw);
    
    const std::string& getPrefix() const;
    const std::string& getCommand() const;
    const std::vector<std::string>& getParams() const;
    std::string getTrailing() const;  // 마지막 파라미터 (: 이후)
    
private:
    std::string _prefix;
    std::string _command;
    std::vector<std::string> _params;
};
```

**메시지 파싱:**
```cpp
Message Message::parse(const std::string& raw) {
    Message msg;
    std::string line = raw;
    
    // 1. prefix 추출 (선택적)
    if (!line.empty() && line[0] == ':') {
        size_t space = line.find(' ');
        msg._prefix = line.substr(1, space - 1);
        line = line.substr(space + 1);
    }
    
    // 2. command 추출
    size_t space = line.find(' ');
    if (space == std::string::npos) {
        msg._command = line;
        return msg;
    }
    msg._command = line.substr(0, space);
    line = line.substr(space + 1);
    
    // 3. params 추출
    while (!line.empty()) {
        if (line[0] == ':') {
            // trailing (나머지 전부)
            msg._params.push_back(line.substr(1));
            break;
        }
        space = line.find(' ');
        if (space == std::string::npos) {
            msg._params.push_back(line);
            break;
        }
        msg._params.push_back(line.substr(0, space));
        line = line.substr(space + 1);
    }
    
    return msg;
}
```

---

## 4. 인증 명령어

### 4-1. PASS
```cpp
// commands/AuthCommands.cpp
void handlePass(Server& server, Client* client, const Message& msg) {
    if (client->isRegistered()) {
        client->send(":server 462 * :You may not reregister\\r\\n");
        return;
    }
    
    if (msg.getParams().empty()) {
        client->send(":server 461 * PASS :Not enough parameters\\r\\n");
        return;
    }
    
    if (msg.getParams()[0] != server.getPassword()) {
        client->send(":server 464 * :Password incorrect\\r\\n");
        return;
    }
    
    client->setState(Client::PASSWORD_SENT);
}
```

### 4-2. NICK
```cpp
void handleNick(Server& server, Client* client, const Message& msg) {
    if (msg.getParams().empty()) {
        client->send(":server 431 * :No nickname given\\r\\n");
        return;
    }
    
    const std::string& nick = msg.getParams()[0];
    
    // 닉네임 유효성 검사
    if (!isValidNickname(nick)) {
        client->send(":server 432 * " + nick + " :Erroneous nickname\\r\\n");
        return;
    }
    
    // 중복 검사
    if (server.findClientByNick(nick)) {
        client->send(":server 433 * " + nick + " :Nickname is already in use\\r\\n");
        return;
    }
    
    std::string oldNick = client->getNickname();
    client->setNickname(nick);
    
    if (client->isRegistered()) {
        // 닉네임 변경 알림
        std::string notice = ":" + oldNick + " NICK " + nick + "\\r\\n";
        // 같은 채널 사용자들에게 브로드캐스트
    }
    
    tryRegister(client);
}
```

### 4-3. USER
```cpp
void handleUser(Server& server, Client* client, const Message& msg) {
    if (client->isRegistered()) {
        client->send(":server 462 * :You may not reregister\\r\\n");
        return;
    }
    
    if (msg.getParams().size() < 4) {
        client->send(":server 461 * USER :Not enough parameters\\r\\n");
        return;
    }
    
    client->setUsername(msg.getParams()[0]);
    client->setRealname(msg.getParams()[3]);  // trailing
    
    tryRegister(client);
}
```

### 4-4. 등록 완료 처리
```cpp
void tryRegister(Client* client) {
    if (client->getState() != Client::PASSWORD_SENT)
        return;
    if (client->getNickname().empty())
        return;
    if (client->getUsername().empty())
        return;
    
    client->setState(Client::REGISTERED);
    
    // Welcome 메시지 전송
    std::string nick = client->getNickname();
    client->send(":server 001 " + nick + " :Welcome to the IRC Network, " + nick + "\\r\\n");
    client->send(":server 002 " + nick + " :Your host is server, running version 1.0\\r\\n");
    client->send(":server 003 " + nick + " :This server was created today\\r\\n");
    client->send(":server 004 " + nick + " server 1.0 o o\\r\\n");
}
```

---

## 5. 채널 명령어

### 5-1. JOIN
```cpp
// commands/ChannelCommands.cpp
void handleJoin(Server& server, Client* client, const Message& msg) {
    if (!client->isRegistered()) {
        client->send(":server 451 * :You have not registered\\r\\n");
        return;
    }
    
    if (msg.getParams().empty()) {
        client->send(":server 461 " + client->getNickname() + " JOIN :Not enough parameters\\r\\n");
        return;
    }
    
    std::string channelName = msg.getParams()[0];
    
    // 채널명 유효성 검사
    if (channelName[0] != '#') {
        client->send(":server 403 " + client->getNickname() + " " + channelName + " :No such channel\\r\\n");
        return;
    }
    
    // 채널 가져오기 또는 생성
    Channel* channel = server.getOrCreateChannel(channelName);
    
    // 이미 참여 중인지 확인
    if (channel->hasClient(client))
        return;
    
    // 참여
    channel->addClient(client);
    client->joinChannel(channel);
    
    // JOIN 알림 브로드캐스트
    std::string joinMsg = ":" + client->getNickname() + " JOIN " + channelName + "\\r\\n";
    channel->broadcast(joinMsg);
    
    // 토픽 전송
    if (!channel->getTopic().empty()) {
        client->send(":server 332 " + client->getNickname() + " " + channelName + " :" + channel->getTopic() + "\\r\\n");
    }
    
    // 사용자 목록 전송
    client->send(":server 353 " + client->getNickname() + " = " + channelName + " :" + channel->getNamesList() + "\\r\\n");
    client->send(":server 366 " + client->getNickname() + " " + channelName + " :End of /NAMES list\\r\\n");
}
```

### 5-2. PART
```cpp
void handlePart(Server& server, Client* client, const Message& msg) {
    if (msg.getParams().empty()) {
        client->send(":server 461 " + client->getNickname() + " PART :Not enough parameters\\r\\n");
        return;
    }
    
    std::string channelName = msg.getParams()[0];
    Channel* channel = server.findChannel(channelName);
    
    if (!channel) {
        client->send(":server 403 " + client->getNickname() + " " + channelName + " :No such channel\\r\\n");
        return;
    }
    
    if (!channel->hasClient(client)) {
        client->send(":server 442 " + client->getNickname() + " " + channelName + " :You're not on that channel\\r\\n");
        return;
    }
    
    std::string reason = msg.getParams().size() > 1 ? msg.getParams()[1] : client->getNickname();
    std::string partMsg = ":" + client->getNickname() + " PART " + channelName + " :" + reason + "\\r\\n";
    channel->broadcast(partMsg);
    
    channel->removeClient(client);
    client->leaveChannel(channel);
    
    // 빈 채널 삭제
    if (channel->getClientCount() == 0)
        server.removeChannel(channelName);
}
```

---

## 6. 메시지 명령어

### 6-1. PRIVMSG
```cpp
// commands/MessageCommands.cpp
void handlePrivmsg(Server& server, Client* client, const Message& msg) {
    if (msg.getParams().size() < 2) {
        client->send(":server 461 " + client->getNickname() + " PRIVMSG :Not enough parameters\\r\\n");
        return;
    }
    
    const std::string& target = msg.getParams()[0];
    const std::string& text = msg.getParams()[1];
    
    std::string privmsg = ":" + client->getNickname() + " PRIVMSG " + target + " :" + text + "\\r\\n";
    
    if (target[0] == '#') {
        // 채널 메시지
        Channel* channel = server.findChannel(target);
        if (!channel) {
            client->send(":server 401 " + client->getNickname() + " " + target + " :No such nick/channel\\r\\n");
            return;
        }
        if (!channel->hasClient(client)) {
            client->send(":server 404 " + client->getNickname() + " " + target + " :Cannot send to channel\\r\\n");
            return;
        }
        channel->broadcast(privmsg, client);  // 자신 제외
    } else {
        // DM
        Client* targetClient = server.findClientByNick(target);
        if (!targetClient) {
            client->send(":server 401 " + client->getNickname() + " " + target + " :No such nick/channel\\r\\n");
            return;
        }
        targetClient->send(privmsg);
    }
}
```

---

## 7. 테스트 시나리오

### 7-1. 기본 연결 테스트
```bash
# 터미널 1: 서버 실행
./modern-irc 6667 testpass

# 터미널 2: 클라이언트 연결
nc localhost 6667
PASS testpass
NICK alice
USER alice 0 * :Alice
# 예상: 001~004 Welcome 메시지
```

### 7-2. 채널 테스트
```bash
# 클라이언트 1
JOIN #test
# 예상: JOIN 메시지, 353/366 NAMES 응답

# 클라이언트 2
PASS testpass
NICK bob
USER bob 0 * :Bob
JOIN #test
# 예상: 클라이언트 1에 bob JOIN 알림

PRIVMSG #test :Hello everyone!
# 예상: 클라이언트 1에 메시지 수신
```

---

## 8. 커밋 포인트

```bash
git commit -m "feat(network): implement TCP socket server with poll()"
git commit -m "feat(core): add Client and Channel classes"
git commit -m "feat(core): implement IRC message parser"
git commit -m "feat(auth): implement PASS, NICK, USER commands"
git commit -m "feat(channel): implement JOIN, PART, NAMES, LIST"
git commit -m "feat(message): implement PRIVMSG, NOTICE"
git commit -m "feat(server): implement PING, PONG, QUIT"
# v1.0.0 tag
```
