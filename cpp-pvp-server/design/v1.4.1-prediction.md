# 클라이언트 예측 & 리컨실리에이션 설계 (v1.4.1)
> 클라이언트 예측, 서버 리컨실리에이션, 입력 버퍼링, 지연 보상 구현 설계

## 1. 개요

### 1.1 목표
- 클라이언트 예측으로 즉각적인 입력 반응
- 서버 리컨실리에이션으로 상태 보정
- 입력 버퍼링으로 일관된 시뮬레이션
- 지연 보상으로 공정한 히트 판정

### 1.2 배경
UDP 기반 권위 서버에서 클라이언트는 서버 응답을 기다리면 지연을 느낍니다:
- RTT(Round-Trip Time) = 50~200ms
- 입력 → 서버 처리 → 결과 수신까지 체감 지연

**해결책:**
1. **클라이언트 예측**: 서버 응답 없이 로컬에서 미리 시뮬레이션
2. **서버 리컨실리에이션**: 서버 상태와 불일치 시 보정
3. **입력 버퍼링**: 입력 히스토리 유지로 재시뮬레이션 지원
4. **지연 보상**: 과거 상태로 되돌려 히트 판정

---

## 2. 패치별 설계

### 2.1 패치 1.4.1-p1: 클라이언트 예측 엔진

#### 2.1.1 책임
- 로컬 입력에 대한 즉각적인 상태 예측
- 예측 상태 저장 (리컨실리에이션용)
- 서버와 동일한 시뮬레이션 로직 사용

#### 2.1.2 인터페이스
```cpp
// include/pvpserver/netcode/client_prediction.h
namespace pvpserver::netcode {

struct PredictedState {
    uint32_t inputSequence;  // 이 예측을 만든 입력의 시퀀스
    PlayerState state;       // 예측된 플레이어 상태
    uint64_t timestamp;
};

class ClientPrediction {
public:
    static constexpr size_t MAX_PENDING_INPUTS = 128;

    // 입력 적용 및 예측 상태 생성
    PredictedState predict(
        const PlayerState& currentState,
        const InputCommand& input,
        float deltaTime
    );

    // 예측 상태 저장
    void savePrediction(const PredictedState& prediction);

    // 서버 확인된 시퀀스까지의 예측 제거
    void acknowledgeUpTo(uint32_t serverSequence);

    // 리컨실리에이션을 위한 미확인 입력 목록
    std::vector<InputCommand> getUnacknowledgedInputs(
        uint32_t afterSequence
    ) const;

    // 가장 최근 예측 상태
    std::optional<PredictedState> getLatestPrediction() const;

private:
    std::deque<PredictedState> predictions_;
    std::deque<InputCommand> inputHistory_;
    uint32_t lastAcknowledged_ = 0;
};

}  // namespace pvpserver::netcode
```

#### 2.1.3 예측 알고리즘
```
1. 클라이언트 입력 발생
2. 입력을 서버로 전송 (시퀀스 번호 포함)
3. 로컬에서 입력 적용하여 예측 상태 생성
4. 예측 상태를 화면에 즉시 렌더링
5. 서버 응답 도착 시 리컨실리에이션 수행
```

#### 2.1.4 시뮬레이션 일관성
- 클라이언트와 서버가 동일한 물리 로직 사용
- 고정 타임스텝 (1/60초)
- 부동소수점 결정성 보장 (플랫폼별 차이 최소화)

---

### 2.2 패치 1.4.1-p2: 리컨실리에이션 시스템

#### 2.2.1 책임
- 서버 상태와 예측 상태 비교
- 불일치 시 클라이언트 상태 보정
- 미확인 입력 재적용

#### 2.2.2 인터페이스
```cpp
// include/pvpserver/netcode/reconciliation.h
namespace pvpserver::netcode {

struct ReconciliationResult {
    bool mismatchDetected;
    float positionError;     // 위치 오차 (미터)
    float velocityError;     // 속도 오차
    PlayerState correctedState;
};

class Reconciliation {
public:
    // 보정 임계값 (이 이상 차이나면 보정)
    static constexpr float POSITION_THRESHOLD = 0.1f;   // 10cm
    static constexpr float VELOCITY_THRESHOLD = 0.5f;   // 0.5 m/s

    // 서버 상태와 비교하여 리컨실리에이션 수행
    ReconciliationResult reconcile(
        const PlayerState& serverState,
        uint32_t serverInputSequence,
        ClientPrediction& prediction,
        float deltaTime
    );

    // 부드러운 보정 (스냅이 아닌 보간)
    PlayerState smoothCorrection(
        const PlayerState& current,
        const PlayerState& target,
        float blendFactor
    );

private:
    // 미확인 입력 재시뮬레이션
    PlayerState resimulate(
        const PlayerState& serverState,
        const std::vector<InputCommand>& inputs,
        float deltaTime
    );
};

}  // namespace pvpserver::netcode
```

#### 2.2.3 리컨실리에이션 흐름
```
1. 서버 스냅샷 수신 (시퀀스 N 기준)
2. 클라이언트의 시퀀스 N 예측 상태와 비교
3. 오차가 임계값 초과 시:
   a. 서버 상태를 기준으로 설정
   b. 시퀀스 N+1 이후 미확인 입력 수집
   c. 미확인 입력들을 순차 재적용
   d. 최종 상태로 클라이언트 갱신
4. 오차가 임계값 이하면 무시 (예측 유지)
```

#### 2.2.4 부드러운 보정
- 즉각적인 스냅은 플레이어에게 불쾌함 유발
- 선형 보간으로 점진적 보정 (3~5 프레임에 걸쳐)
- 시각적 위치와 물리적 위치 분리 고려

---

### 2.3 패치 1.4.1-p3: 입력 버퍼링

#### 2.3.1 책임
- 클라이언트 입력 히스토리 관리
- 서버 측 입력 버퍼링 (지터 완화)
- 입력 시퀀스 관리

#### 2.3.2 인터페이스
```cpp
// include/pvpserver/netcode/input_buffer.h
namespace pvpserver::netcode {

struct TimestampedInput {
    uint32_t sequence;
    uint64_t clientTimestamp;
    uint64_t serverReceiveTime;
    InputCommand command;
};

class InputBuffer {
public:
    static constexpr size_t BUFFER_SIZE = 64;
    static constexpr int BUFFER_DELAY_MS = 50;  // 지터 완화

    // 입력 추가
    void push(const TimestampedInput& input);

    // 처리할 입력 가져오기 (시간순)
    std::optional<InputCommand> pop(uint64_t currentTime);

    // 특정 시퀀스의 입력 조회
    std::optional<InputCommand> getInput(uint32_t sequence) const;

    // 시퀀스 범위의 입력들 조회
    std::vector<InputCommand> getInputRange(
        uint32_t startSeq,
        uint32_t endSeq
    ) const;

    // 버퍼 상태
    size_t size() const;
    bool isEmpty() const;

private:
    std::deque<TimestampedInput> buffer_;
    uint32_t lastProcessedSequence_ = 0;
};

}  // namespace pvpserver::netcode
```

#### 2.3.3 서버 측 입력 버퍼링
```
문제: 네트워크 지터로 입력 도착 시간이 불규칙
- t=0ms: 입력1 도착
- t=20ms: 입력2 도착 (예상: 16.6ms)
- t=30ms: 입력3, 입력4 동시 도착

해결: 버퍼 딜레이
- 입력을 즉시 처리하지 않고 50ms 버퍼링
- 일정한 간격으로 입력 소비
- 네트워크 지터 흡수
```

---

### 2.4 패치 1.4.1-p4: 지연 보상

#### 2.4.1 책임
- 과거 게임 상태 버퍼링
- 히트 판정 시 과거 상태 조회
- 공정한 히트 판정 보장

#### 2.4.2 인터페이스
```cpp
// include/pvpserver/netcode/lag_compensation.h
namespace pvpserver::netcode {

class LagCompensation {
public:
    static constexpr size_t HISTORY_SIZE = 128;     // 약 2초
    static constexpr int MAX_REWIND_MS = 200;       // 최대 되돌리기

    // 현재 상태 저장
    void saveWorldState(const WorldState& state, uint64_t timestamp);

    // 특정 시점의 상태 조회 (보간 포함)
    WorldState getWorldStateAt(uint64_t timestamp) const;

    // 지연 보상된 히트 검증
    HitResult validateHitWithCompensation(
        const HitRequest& request,
        uint64_t clientTimestamp
    );

    // 클라이언트 RTT 기반 되돌리기 시간 계산
    uint64_t calculateRewindTime(
        uint64_t clientTimestamp,
        uint64_t serverTime,
        uint32_t clientRtt
    ) const;

private:
    struct HistoryEntry {
        uint64_t timestamp;
        WorldState state;
    };
    
    std::deque<HistoryEntry> history_;

    // 두 상태 간 보간
    WorldState interpolate(
        const WorldState& a,
        const WorldState& b,
        float t
    ) const;
};

}  // namespace pvpserver::netcode
```

#### 2.4.3 지연 보상 흐름
```
시나리오:
- 플레이어 A가 t=0에서 발사
- RTT = 100ms
- 서버가 t=50ms에 요청 수신
- 적 B는 t=50ms에는 다른 위치

지연 보상:
1. 클라이언트 타임스탬프 (t=0) 추출
2. 서버 시간 기준으로 되돌리기 시간 계산
3. 과거 월드 상태 조회 (t=0 근처)
4. 과거 상태에서 히트 판정 수행
5. 결과를 현재 상태에 적용
```

#### 2.4.4 악용 방지
- 최대 되돌리기 시간 제한 (200ms)
- 비정상적인 타임스탬프 거부
- 핑이 너무 높은 플레이어 경고/제한

---

## 3. 기존 코드와의 연관성

### 3.1 영향받는 모듈
| 모듈 | 변경 유형 | 설명 |
|------|----------|------|
| `netcode/` | 신규 | 넷코드 관련 새 모듈 |
| `network/udp_game_server.h` | 수정 | 입력 버퍼, 지연 보상 통합 |
| `game/combat.h` | 수정 | 히트 검증에 지연 보상 적용 |
| `network/snapshot_manager.h` | 수정 | 리컨실리에이션 지원 |

### 3.2 의존성
```
UdpGameServer
    ├── InputBuffer
    ├── LagCompensation
    │   └── SnapshotManager (월드 상태 히스토리)
    └── Combat
        └── LagCompensation::validateHitWithCompensation()

ClientPrediction
    └── Reconciliation
```

---

## 4. 파일 구조

```
server/
├── include/pvpserver/
│   └── netcode/                    # 신규 모듈
│       ├── client_prediction.h
│       ├── reconciliation.h
│       ├── input_buffer.h
│       └── lag_compensation.h
├── src/
│   └── netcode/                    # 신규 모듈
│       ├── client_prediction.cpp
│       ├── reconciliation.cpp
│       ├── input_buffer.cpp
│       └── lag_compensation.cpp
└── tests/
    └── unit/
        ├── test_client_prediction.cpp
        ├── test_reconciliation.cpp
        ├── test_input_buffer.cpp
        └── test_lag_compensation.cpp
```

---

## 5. 성능 요구사항

| 메트릭 | 목표 |
|--------|------|
| 예측 계산 | < 0.1ms |
| 리컨실리에이션 (10 입력) | < 0.5ms |
| 지연 보상 조회 | < 0.2ms |
| 입력 버퍼 지연 | 50ms (설정 가능) |

---

## 6. 테스트 전략

### 6.1 단위 테스트
- 예측 정확성 (동일 입력 → 동일 상태)
- 리컨실리에이션 정확성 (재시뮬레이션 결과)
- 입력 버퍼 순서 보장
- 지연 보상 보간 정확성

### 6.2 통합 테스트
- 네트워크 지연 시뮬레이션
- 패킷 손실 시나리오
- 다중 클라이언트 동기화

### 6.3 시각적 테스트
- 리컨실리에이션 부드러움 (스냅 없음)
- 예측 정확도 (서버 확정과 일치)
