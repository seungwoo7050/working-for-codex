# 고급 기능 및 최적화 설계 일지 (v2.0)
> "Ray Tracing: The Next Week" 기반의 BVH 가속화, 텍스처, 볼륨 렌더링 구현 기록

## 1. 문제 정의 & 요구사항

### 1.1 v1.0의 한계

v1.0에서는 **모든 객체를 선형 탐색**:
```cpp
for (const auto& object : objects) {
    if (object->hit(r, tMin, closest, rec)) {
        closest = rec.t;
        hitAnything = true;
    }
}
```

**N개 객체, M개 광선:**
- 총 교차 판정: O(N × M)
- N = 500개 구체, M = 400×225×10 = 900,000 광선
- **총 4.5억 번의 교차 판정**

**추가 한계:**
- 텍스처 없음: 모든 객체가 단색
- 광원 없음: 배경색만 존재
- 동적 객체 없음: 모든 것이 정적

### 1.2 목표

#### 1.2.1 BVH (Bounding Volume Hierarchy)
- 공간 분할 트리로 교차 판정 복잡도 O(N) → **O(log N)**
- 500개 객체 기준 **~50배 이상 성능 향상** 예상

#### 1.2.2 텍스처 시스템
- 절차적 텍스처: Solid Color, Checker, Perlin Noise
- 이미지 텍스처: UV 매핑 (placeholder)

#### 1.2.3 고급 프리미티브
- **Quad**: 사각형 평면 (벽, 바닥, 광원 등)
- **MovingSphere**: 시간에 따라 이동하는 구체 (Motion Blur)
- **ConstantMedium**: 볼륨 렌더링 (안개, 연기)

#### 1.2.4 인스턴싱
- **Translate**: 객체 이동
- **RotateY**: Y축 기준 회전

### 1.3 비기능 요구사항

#### 1.3.1 성능
- BVH 구축 시간: < 100ms (500개 객체)
- 렌더링 시간: v1.0 대비 **10배 이상 단축**
- 메모리: BVH 노드당 ~64 bytes

#### 1.3.2 확장성
- 텍스처 인터페이스로 새 텍스처 타입 추가 용이
- `Hittable` 상속으로 새 프리미티브 추가 용이

---

## 2. 기술적 배경 & 설계 동기

### 2.1 왜 BVH인가?

**공간 분할 구조 비교:**

| 구조 | 장점 | 단점 |
|------|------|------|
| **BVH** | 동적 객체 지원, 구현 간단 | 중첩 가능 |
| kd-tree | 균일 분할, 빠른 탐색 | 동적 객체 어려움 |
| Octree | 균일 공간 분할 | 메모리 비효율 |
| Grid | 구현 단순 | 빈 공간 낭비 |

**BVH 선택 이유:**
- Motion Blur 지원 필요 (동적 AABB)
- 구현 복잡도 낮음
- 대부분의 상용 렌더러에서 사용

### 2.2 AABB (Axis-Aligned Bounding Box)

**정의:**
- 각 축에 정렬된 최소/최대 좌표로 정의된 상자
- 모든 객체를 감싸는 가장 작은 AABB

```cpp
class AABB {
    Point3 minimum;
    Point3 maximum;
    
    bool hit(const Ray& r, double tMin, double tMax) const;
    static AABB surroundingBox(AABB box0, AABB box1);
};
```

**AABB-Ray 교차 판정 (Slab method):**
```cpp
bool AABB::hit(const Ray& r, double tMin, double tMax) const {
    for (int a = 0; a < 3; a++) {
        auto invD = 1.0 / r.direction()[a];
        auto t0 = (min()[a] - r.origin()[a]) * invD;
        auto t1 = (max()[a] - r.origin()[a]) * invD;
        if (invD < 0.0) std::swap(t0, t1);
        tMin = t0 > tMin ? t0 : tMin;
        tMax = t1 < tMax ? t1 : tMax;
        if (tMax <= tMin) return false;
    }
    return true;
}
```

### 2.3 펄린 노이즈 (Perlin Noise)

**Ken Perlin이 1983년 개발:**
- 자연스러운 랜덤 패턴 (대리석, 나무결, 구름)
- 연속적이고 부드러운 변화

**구현 핵심:**
1. 3D 격자점에 랜덤 그래디언트 벡터 할당
2. 입력 좌표 주변 8개 격자점의 그래디언트와 내적
3. 삼선형 보간 (Trilinear Interpolation)
4. Hermite 스무딩으로 격자 경계 부드럽게

**터뷸런스 (Turbulence):**
```cpp
double Perlin::turb(const Point3& p, int depth) const {
    auto accum = 0.0;
    auto tempP = p;
    auto weight = 1.0;
    
    for (int i = 0; i < depth; i++) {
        accum += weight * noise(tempP);
        weight *= 0.5;
        tempP *= 2;
    }
    return fabs(accum);
}
```

---

## 3. BVH 구조 설계

### 3.1 BVHNode 구조

```cpp
class BVHNode : public Hittable {
public:
    shared_ptr<Hittable> left;
    shared_ptr<Hittable> right;
    AABB box;
    
    BVHNode(vector<shared_ptr<Hittable>>& objects, 
            size_t start, size_t end, double time0, double time1);
    
    bool hit(const Ray& r, double tMin, double tMax, HitRecord& rec) const override;
    bool boundingBox(double time0, double time1, AABB& outputBox) const override;
};
```

### 3.2 구축 알고리즘

```cpp
BVHNode::BVHNode(vector<shared_ptr<Hittable>>& srcObjects,
                 size_t start, size_t end, double time0, double time1) {
    auto objects = srcObjects;
    
    // 1. 랜덤 축 선택 (0=x, 1=y, 2=z)
    int axis = randomInt(0, 2);
    auto comparator = (axis == 0) ? boxXCompare
                    : (axis == 1) ? boxYCompare
                                  : boxZCompare;
    
    size_t objectSpan = end - start;
    
    // 2. 객체 수에 따른 분기
    if (objectSpan == 1) {
        left = right = objects[start];
    } else if (objectSpan == 2) {
        if (comparator(objects[start], objects[start + 1])) {
            left = objects[start];
            right = objects[start + 1];
        } else {
            left = objects[start + 1];
            right = objects[start];
        }
    } else {
        // 3. 정렬 후 이진 분할
        std::sort(objects.begin() + start, objects.begin() + end, comparator);
        auto mid = start + objectSpan / 2;
        left = make_shared<BVHNode>(objects, start, mid, time0, time1);
        right = make_shared<BVHNode>(objects, mid, end, time0, time1);
    }
    
    // 4. 부모 AABB = 자식들의 AABB 합집합
    AABB boxLeft, boxRight;
    left->boundingBox(time0, time1, boxLeft);
    right->boundingBox(time0, time1, boxRight);
    box = AABB::surroundingBox(boxLeft, boxRight);
}
```

**시간 복잡도:**
- 구축: O(N log N) - 정렬 비용
- 탐색: O(log N) - 이진 트리 탐색

### 3.3 탐색 알고리즘

```cpp
bool BVHNode::hit(const Ray& r, double tMin, double tMax, HitRecord& rec) const {
    // 1. 현재 노드의 AABB와 교차하지 않으면 조기 종료
    if (!box.hit(r, tMin, tMax))
        return false;
    
    // 2. 왼쪽 자식 탐색
    bool hitLeft = left->hit(r, tMin, tMax, rec);
    
    // 3. 오른쪽 자식 탐색 (왼쪽에서 hit 시 tMax 갱신)
    bool hitRight = right->hit(r, tMin, hitLeft ? rec.t : tMax, rec);
    
    return hitLeft || hitRight;
}
```

**핵심 최적화:**
- AABB 미스 시 하위 트리 전체 스킵
- 왼쪽 충돌 시 오른쪽 탐색 범위 축소

---

## 4. 텍스처 시스템 설계

### 4.1 인터페이스

```cpp
class Texture {
public:
    virtual Color value(double u, double v, const Point3& p) const = 0;
};
```

### 4.2 구현 클래스

#### 4.2.1 SolidColor
```cpp
class SolidColor : public Texture {
    Color colorValue;
    
    Color value(double u, double v, const Point3& p) const override {
        return colorValue;
    }
};
```

#### 4.2.2 CheckerTexture
```cpp
class CheckerTexture : public Texture {
    double invScale;
    shared_ptr<Texture> even;
    shared_ptr<Texture> odd;
    
    Color value(double u, double v, const Point3& p) const override {
        auto sines = sin(invScale * p.x()) * sin(invScale * p.y()) * sin(invScale * p.z());
        return (sines < 0) ? odd->value(u, v, p) : even->value(u, v, p);
    }
};
```

#### 4.2.3 NoiseTexture
```cpp
class NoiseTexture : public Texture {
    Perlin noise;
    double scale;
    
    Color value(double u, double v, const Point3& p) const override {
        return Color(1, 1, 1) * 0.5 * (1 + sin(scale * p.z() + 10 * noise.turb(p)));
    }
};
```

---

## 5. 고급 프리미티브 설계

### 5.1 Quad (사각형)

```cpp
class Quad : public Hittable {
    Point3 Q;       // 모서리 점
    Vec3 u, v;      // 두 변 벡터
    Vec3 normal;    // 법선 (cross(u, v) 정규화)
    double D;       // 평면 방정식 상수
    Vec3 w;         // 면적 계산용 (n / dot(n, n))
    double area;    // 면적 (|cross(u, v)|)
};
```

**교차 판정:**
1. 광선이 평면과 교차하는지 확인
2. 교차점이 사각형 내부인지 확인 (알파, 베타 좌표 0~1)

### 5.2 ConstantMedium (볼륨)

```cpp
class ConstantMedium : public Hittable {
    shared_ptr<Hittable> boundary;  // 경계 객체
    double negInvDensity;           // -1/밀도
    shared_ptr<Material> phaseFunction;  // Isotropic 재질
};
```

**확률적 산란:**
```cpp
bool ConstantMedium::hit(const Ray& r, double tMin, double tMax, HitRecord& rec) const {
    // 1. 경계 진입/진출 지점 계산
    if (!boundary->hit(r, -INFINITY, INFINITY, rec1)) return false;
    if (!boundary->hit(r, rec1.t + 0.0001, INFINITY, rec2)) return false;
    
    // 2. 매질 내 이동 거리 계산
    auto distanceInsideBoundary = (rec2.t - rec1.t) * rayLength;
    
    // 3. Beer-Lambert 법칙에 따른 산란 거리
    auto hitDistance = negInvDensity * log(randomDouble());
    
    // 4. 산란 거리가 매질 내라면 산란 발생
    if (hitDistance > distanceInsideBoundary) return false;
    
    rec.t = rec1.t + hitDistance / rayLength;
    rec.mat = phaseFunction;  // 등방성 산란
    return true;
}
```

---

## 6. 광원 시스템

### 6.1 DiffuseLight

```cpp
class DiffuseLight : public Material {
    shared_ptr<Texture> tex;
    
    bool scatter(...) const override {
        return false;  // 산란하지 않음 (광원)
    }
    
    Color emitted(double u, double v, const Point3& p) const override {
        return tex->value(u, v, p);  // 발광 색상 반환
    }
};
```

### 6.2 Cornell Box 구성

```cpp
HittableList cornellBox() {
    HittableList world;
    
    auto red   = make_shared<Lambertian>(Color(.65, .05, .05));
    auto white = make_shared<Lambertian>(Color(.73, .73, .73));
    auto green = make_shared<Lambertian>(Color(.12, .45, .15));
    auto light = make_shared<DiffuseLight>(Color(15, 15, 15));
    
    // 벽 (Quad)
    world.add(make_shared<Quad>(Point3(555,0,0), Vec3(0,555,0), Vec3(0,0,555), green));  // 오른쪽
    world.add(make_shared<Quad>(Point3(0,0,0), Vec3(0,555,0), Vec3(0,0,555), red));      // 왼쪽
    world.add(make_shared<Quad>(Point3(343,554,332), Vec3(-130,0,0), Vec3(0,0,-105), light)); // 조명
    // ... 나머지 벽
    
    // 상자 (6개 Quad로 구성)
    shared_ptr<Hittable> box1 = box(Point3(0,0,0), Point3(165,330,165), white);
    box1 = make_shared<RotateY>(box1, 15);
    box1 = make_shared<Translate>(box1, Vec3(265,0,295));
    world.add(box1);
    
    return world;
}
```

---

## 7. 검증 전략

### 7.1 유닛 테스트

1. **AABB 테스트**
   ```cpp
   TEST(AABBTest, RayHitsBox) {
       AABB box(Point3(-1,-1,-1), Point3(1,1,1));
       Ray r(Point3(0,0,-5), Vec3(0,0,1));
       EXPECT_TRUE(box.hit(r, 0, INFINITY));
   }
   ```

2. **BVH 테스트**
   ```cpp
   TEST(BVHTest, ConstructionDoesNotCrash) {
       HittableList world;
       for (int i = 0; i < 100; i++)
           world.add(make_shared<Sphere>(...));
       BVHNode bvh(world, 0, 1);  // 크래시 없어야 함
   }
   ```

3. **텍스처 테스트**
   ```cpp
   TEST(CheckerTest, AlternatesColors) {
       CheckerTexture checker(1.0, Color(1,1,1), Color(0,0,0));
       EXPECT_EQ(checker.value(0, 0, Point3(0,0,0)), Color(1,1,1));
       EXPECT_EQ(checker.value(0, 0, Point3(1,0,0)), Color(0,0,0));
   }
   ```

### 7.2 성능 벤치마크

```cpp
// benchmark_bvh.cpp
void BM_WithoutBVH(benchmark::State& state) {
    HittableList world = createLargeScene(500);
    for (auto _ : state) {
        renderWithoutBVH(world);
    }
}

void BM_WithBVH(benchmark::State& state) {
    HittableList world = createLargeScene(500);
    BVHNode bvh(world, 0, 1);
    for (auto _ : state) {
        renderWithBVH(bvh);
    }
}
```

**예상 결과 (500개 구체):**
- Without BVH: ~300초
- With BVH: ~6초 (**50배 개선**)

---

## 8. 성능 예산

### 8.1 BVH 구축

| 객체 수 | 예상 시간 | 노드 수 |
|---------|----------|---------|
| 100 | ~5ms | ~199 |
| 500 | ~30ms | ~999 |
| 1000 | ~70ms | ~1999 |

### 8.2 렌더링 (400×225, 10 SPP)

| 씬 | v1.0 (선형) | v2.0 (BVH) | 개선 |
|-----|------------|-----------|------|
| 100 Spheres | ~30s | ~3s | 10x |
| 500 Spheres | ~150s | ~5s | 30x |
| Cornell Box | N/A | ~10s | - |

---

## 9. 이후 버전과의 연결

### v2.0에서 확립된 것
- BVH 가속 구조
- 텍스처 인터페이스 (`Texture::value`)
- `boundingBox()` 메서드 (모든 Hittable에 추가)
- 광원 시스템 (`emitted()`)
- 볼륨 렌더링

### v3.0에서 추가될 것
- PDF 기반 중요도 샘플링
- `pdfValue()`, `random()` 메서드 추가
- MixturePDF로 광원 직접 샘플링
- 노이즈 **4~5배 감소**

---

## 10. 알려진 제약 & 향후 개선점

### 10.1 현재 제약

1. **SAH 미적용**: 랜덤 축 선택, Surface Area Heuristic 미사용
   - 개선: SAH 기반 분할로 BVH 품질 향상

2. **이미지 텍스처 미완성**: placeholder 상태
   - 개선: stb_image 라이브러리 연동

3. **Motion Blur 제한**: 선형 이동만 지원
   - 개선: 곡선 경로, 회전 애니메이션

4. **볼륨 제한**: 볼록 경계만 지원
   - 개선: 오목 형태, 중첩 볼륨

### 10.2 확장 가능성

- **삼각형 메시**: OBJ 파일 로딩
- **환경 맵**: HDR 배경
- **Subsurface Scattering**: BSSRDF

---

## 11. 체크리스트 (v2.0 완료 기준)

- [x] `AABB` 클래스 및 교차 판정 구현
- [x] `BVHNode` 구축 및 탐색 알고리즘 구현
- [x] 벤치마크로 BVH 성능 향상 확인
- [x] `Texture` 인터페이스 정의
- [x] `SolidColor`, `CheckerTexture`, `NoiseTexture` 구현
- [x] `Perlin` 노이즈 생성기 구현
- [x] `Quad` 사각형 프리미티브 구현
- [x] `MovingSphere` Motion Blur 구현
- [x] `ConstantMedium` 볼륨 렌더링 구현
- [x] `Translate`, `RotateY` 인스턴싱 구현
- [x] `DiffuseLight` 광원 재질 구현
- [x] Cornell Box 씬 렌더링 확인
