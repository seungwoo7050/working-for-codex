# modern-irc - Phase 3: Production Infrastructure

> 설정 파일, 로깅, Rate Limiting, 관리자 명령, 서버 통계

---

## 1. 개요

### 1-1. Phase 3 목표
- INI 스타일 설정 파일 시스템
- 멀티 레벨 로깅 (콘솔 + 파일)
- Rate Limiting (플러드 방지)
- 관리자(OPER) 명령어
- 서버 통계 및 모니터링

### 1-2. 구현 범위
| 기능 | 상태 |
|------|------|
| 설정 파일 시스템 | ✅ |
| 런타임 설정 리로드 | ✅ |
| 멀티 레벨 로깅 | ✅ |
| Rate Limiting | ✅ |
| OPER, KILL, REHASH, RESTART, DIE | ✅ |
| STATS, INFO, VERSION, TIME, LUSERS | ✅ |

---

## 2. 설정 파일 시스템

### 2-1. Config 클래스
```cpp
// utils/Config.hpp
class Config {
public:
    static Config& getInstance();
    
    bool load(const std::string& filepath);
    bool reload();
    
    // Getters
    std::string getServerName() const;
    int getPort() const;
    int getMaxClients() const;
    std::string getServerPassword() const;
    std::string getOperatorPassword() const;
    
    // Rate limiting
    bool isRateLimitEnabled() const;
    int getRateLimitMessages() const;
    int getRateLimitWindow() const;
    
    // Logging
    bool isLogEnabled() const;
    std::string getLogFile() const;
    std::string getLogLevel() const;
    
private:
    Config();
    std::string _filepath;
    std::map<std::string, std::string> _settings;
    
    std::string get(const std::string& key, const std::string& defaultValue = "") const;
    int getInt(const std::string& key, int defaultValue = 0) const;
    bool getBool(const std::string& key, bool defaultValue = false) const;
};
```

### 2-2. 설정 파일 형식
```ini
# config/modern-irc.conf

# Server settings
server_name = irc.local
port = 6667
max_clients = 1000

# Authentication
server_password = password
operator_password = operpass

# Rate limiting
rate_limit_enabled = true
rate_limit_messages = 10
rate_limit_window = 10

# Logging
log_enabled = true
log_file = logs/modern-irc.log
log_level = INFO
```

### 2-3. 파싱 구현
```cpp
bool Config::load(const std::string& filepath) {
    _filepath = filepath;
    std::ifstream file(filepath.c_str());
    
    if (!file.is_open()) {
        return false;
    }
    
    std::string line;
    while (std::getline(file, line)) {
        // 공백 제거
        line = StringUtils::trim(line);
        
        // 빈 줄, 주석 무시
        if (line.empty() || line[0] == '#')
            continue;
        
        // key = value 파싱
        size_t pos = line.find('=');
        if (pos == std::string::npos)
            continue;
        
        std::string key = StringUtils::trim(line.substr(0, pos));
        std::string value = StringUtils::trim(line.substr(pos + 1));
        
        _settings[key] = value;
    }
    
    return true;
}

bool Config::reload() {
    _settings.clear();
    return load(_filepath);
}
```

---

## 3. 로깅 시스템

### 3-1. Logger 클래스
```cpp
// utils/Logger.hpp
class Logger {
public:
    enum Level {
        DEBUG,
        INFO,
        WARNING,
        ERROR
    };
    
    static Logger& getInstance();
    
    void init(bool enabled, const std::string& filepath, const std::string& levelStr);
    
    void debug(const std::string& message);
    void info(const std::string& message);
    void warning(const std::string& message);
    void error(const std::string& message);
    
    void log(Level level, const std::string& message);
    
private:
    Logger();
    ~Logger();
    
    bool _enabled;
    Level _level;
    std::ofstream _file;
    
    std::string levelToString(Level level);
    Level stringToLevel(const std::string& str);
    std::string getTimestamp();
};
```

### 3-2. 로깅 구현
```cpp
void Logger::log(Level level, const std::string& message) {
    if (!_enabled || level < _level)
        return;
    
    std::string timestamp = getTimestamp();
    std::string levelStr = levelToString(level);
    std::string formatted = "[" + timestamp + "] [" + levelStr + "] " + message;
    
    // 콘솔 출력
    std::cout << formatted << std::endl;
    
    // 파일 출력
    if (_file.is_open()) {
        _file << formatted << std::endl;
        _file.flush();
    }
}

std::string Logger::getTimestamp() {
    time_t now = time(NULL);
    struct tm* timeinfo = localtime(&now);
    char buffer[20];
    strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", timeinfo);
    return std::string(buffer);
}
```

### 3-3. 사용 예시
```cpp
// 서버 시작
Logger::getInstance().info("Server starting on port " + StringUtils::toString(port));

// 클라이언트 연결
Logger::getInstance().info("Client connected: " + client->getHostname());

// 명령어 처리
Logger::getInstance().debug("Processing command: " + msg.getCommand());

// 에러
Logger::getInstance().error("Failed to bind socket: " + std::string(strerror(errno)));
```

---

## 4. Rate Limiting

### 4-1. RateLimiter 구조
```cpp
// Client 클래스 내부
struct RateLimitInfo {
    std::vector<time_t> messageTimestamps;
    bool throttled;
    time_t throttleEndTime;
};
```

### 4-2. Rate Limit 검사
```cpp
bool Client::checkRateLimit() {
    if (!Config::getInstance().isRateLimitEnabled())
        return true;
    
    time_t now = time(NULL);
    int window = Config::getInstance().getRateLimitWindow();
    int maxMessages = Config::getInstance().getRateLimitMessages();
    
    // 쓰로틀 상태 확인
    if (_rateLimit.throttled) {
        if (now < _rateLimit.throttleEndTime)
            return false;
        _rateLimit.throttled = false;
    }
    
    // 오래된 타임스탬프 제거
    _rateLimit.messageTimestamps.erase(
        std::remove_if(_rateLimit.messageTimestamps.begin(),
                       _rateLimit.messageTimestamps.end(),
                       [now, window](time_t t) { return now - t > window; }),
        _rateLimit.messageTimestamps.end()
    );
    
    // 제한 초과 검사
    if (_rateLimit.messageTimestamps.size() >= (size_t)maxMessages) {
        _rateLimit.throttled = true;
        _rateLimit.throttleEndTime = now + window;
        Logger::getInstance().warning("Rate limit exceeded for " + _nickname);
        return false;
    }
    
    _rateLimit.messageTimestamps.push_back(now);
    return true;
}
```

### 4-3. 서버에서 사용
```cpp
void Server::handleClientData(int fd) {
    Client* client = _clients[fd];
    
    // 데이터 수신
    char buffer[512];
    ssize_t bytes = recv(fd, buffer, sizeof(buffer) - 1, 0);
    
    if (bytes <= 0) {
        disconnectClient(client);
        return;
    }
    
    buffer[bytes] = '\0';
    client->appendToBuffer(buffer);
    
    // 메시지 처리
    std::string line;
    while (!(line = client->extractLine()).empty()) {
        // Rate limit 검사
        if (!client->checkRateLimit()) {
            client->send(":server NOTICE " + client->getNickname() + 
                        " :You are sending too many messages. Slow down.\r\n");
            continue;
        }
        
        Message msg = Message::parse(line);
        processCommand(client, msg);
    }
}
```

---

## 5. 관리자 명령어

### 5-1. OPER (관리자 인증)
```cpp
void handleOper(Server& server, Client* client, const Message& msg) {
    if (msg.getParams().size() < 2) {
        client->send(":server 461 " + client->getNickname() + " OPER :Not enough parameters\r\n");
        return;
    }
    
    const std::string& name = msg.getParams()[0];
    const std::string& password = msg.getParams()[1];
    
    // 간단한 인증 (실제로는 더 복잡한 검증 필요)
    if (password != Config::getInstance().getOperatorPassword()) {
        client->send(":server 464 " + client->getNickname() + " :Password incorrect\r\n");
        return;
    }
    
    client->setOperator(true);
    client->send(":server 381 " + client->getNickname() + " :You are now an IRC operator\r\n");
    
    Logger::getInstance().info(client->getNickname() + " is now an IRC operator");
}
```

### 5-2. KILL (강제 연결 종료)
```cpp
void handleKill(Server& server, Client* client, const Message& msg) {
    if (!client->isServerOperator()) {
        client->send(":server 481 " + client->getNickname() + " :Permission Denied- You're not an IRC operator\r\n");
        return;
    }
    
    if (msg.getParams().size() < 2) {
        client->send(":server 461 " + client->getNickname() + " KILL :Not enough parameters\r\n");
        return;
    }
    
    const std::string& targetNick = msg.getParams()[0];
    const std::string& reason = msg.getParams()[1];
    
    Client* target = server.findClientByNick(targetNick);
    if (!target) {
        client->send(":server 401 " + client->getNickname() + " " + targetNick + " :No such nick/channel\r\n");
        return;
    }
    
    // KILL 메시지 전송
    target->send(":" + client->getNickname() + " KILL " + targetNick + " :" + reason + "\r\n");
    
    Logger::getInstance().info(client->getNickname() + " killed " + targetNick + ": " + reason);
    
    // 연결 종료
    server.disconnectClient(target);
}
```

### 5-3. REHASH (설정 리로드)
```cpp
void handleRehash(Server& server, Client* client, const Message& msg) {
    if (!client->isServerOperator()) {
        client->send(":server 481 " + client->getNickname() + " :Permission Denied- You're not an IRC operator\r\n");
        return;
    }
    
    if (Config::getInstance().reload()) {
        client->send(":server 382 " + client->getNickname() + " modern-irc.conf :Rehashing\r\n");
        Logger::getInstance().info("Configuration reloaded by " + client->getNickname());
        
        // 로거 설정 업데이트
        Logger::getInstance().init(
            Config::getInstance().isLogEnabled(),
            Config::getInstance().getLogFile(),
            Config::getInstance().getLogLevel()
        );
    } else {
        client->send(":server NOTICE " + client->getNickname() + " :Error reloading configuration\r\n");
    }
}
```

### 5-4. DIE (서버 종료)
```cpp
void handleDie(Server& server, Client* client, const Message& msg) {
    if (!client->isServerOperator()) {
        client->send(":server 481 " + client->getNickname() + " :Permission Denied- You're not an IRC operator\r\n");
        return;
    }
    
    Logger::getInstance().info("Server shutdown initiated by " + client->getNickname());
    
    // 모든 클라이언트에게 알림
    server.broadcast(":server NOTICE * :Server is shutting down\r\n");
    
    server.stop();
}
```

---

## 6. 서버 통계

### 6-1. Statistics 구조
```cpp
struct ServerStats {
    time_t startTime;
    size_t totalConnections;
    size_t totalMessages;
    size_t peakClients;
    size_t currentClients;
    size_t currentChannels;
    size_t operators;
};
```

### 6-2. STATS
```cpp
void handleStats(Server& server, Client* client, const Message& msg) {
    if (msg.getParams().empty()) {
        client->send(":server 219 " + client->getNickname() + " * :End of /STATS report\r\n");
        return;
    }
    
    char query = msg.getParams()[0][0];
    
    switch (query) {
        case 'u':  // Uptime
            {
                time_t uptime = time(NULL) - server.getStats().startTime;
                int days = uptime / 86400;
                int hours = (uptime % 86400) / 3600;
                int mins = (uptime % 3600) / 60;
                int secs = uptime % 60;
                
                std::ostringstream ss;
                ss << "Server Up " << days << " days " << hours << ":" 
                   << std::setfill('0') << std::setw(2) << mins << ":"
                   << std::setw(2) << secs;
                
                client->send(":server 242 " + client->getNickname() + " :" + ss.str() + "\r\n");
            }
            break;
            
        case 'm':  // Messages
            client->send(":server 212 " + client->getNickname() + " :Total messages: " + 
                        StringUtils::toString(server.getStats().totalMessages) + "\r\n");
            break;
            
        case 'c':  // Connections
            client->send(":server 212 " + client->getNickname() + " :Total connections: " + 
                        StringUtils::toString(server.getStats().totalConnections) + "\r\n");
            client->send(":server 212 " + client->getNickname() + " :Peak clients: " + 
                        StringUtils::toString(server.getStats().peakClients) + "\r\n");
            break;
    }
    
    client->send(":server 219 " + client->getNickname() + " " + query + " :End of /STATS report\r\n");
}
```

### 6-3. LUSERS
```cpp
void handleLusers(Server& server, Client* client, const Message& msg) {
    const ServerStats& stats = server.getStats();
    
    client->send(":server 251 " + client->getNickname() + 
                " :There are " + StringUtils::toString(stats.currentClients - stats.operators) + 
                " users and " + StringUtils::toString(stats.operators) + 
                " operators on 1 server\r\n");
    
    client->send(":server 254 " + client->getNickname() + " " + 
                StringUtils::toString(stats.currentChannels) + " :channels formed\r\n");
    
    client->send(":server 255 " + client->getNickname() + 
                " :I have " + StringUtils::toString(stats.currentClients) + 
                " clients and 1 server\r\n");
    
    client->send(":server 265 " + client->getNickname() + 
                " :Current local users: " + StringUtils::toString(stats.currentClients) + 
                " Max: " + StringUtils::toString(stats.peakClients) + "\r\n");
}
```

### 6-4. INFO, VERSION, TIME
```cpp
void handleInfo(Server& server, Client* client, const Message& msg) {
    client->send(":server 371 " + client->getNickname() + " :modern-irc - Phase 3 Implementation\r\n");
    client->send(":server 371 " + client->getNickname() + " :RFC 1459/2810-2813 compliant IRC server\r\n");
    client->send(":server 371 " + client->getNickname() + " :Written in C++17\r\n");
    client->send(":server 374 " + client->getNickname() + " :End of /INFO list\r\n");
}

void handleVersion(Server& server, Client* client, const Message& msg) {
    client->send(":server 351 " + client->getNickname() + " modern-irc-3.0 " + 
                server.getName() + " :Production Infrastructure\r\n");
}

void handleTime(Server& server, Client* client, const Message& msg) {
    time_t now = time(NULL);
    char buffer[64];
    strftime(buffer, sizeof(buffer), "%c", localtime(&now));
    
    client->send(":server 391 " + client->getNickname() + " " + 
                server.getName() + " :" + buffer + "\r\n");
}
```

---

## 7. 커밋 포인트

```bash
git commit -m "feat(config): implement INI-style configuration file system"
git commit -m "feat(config): add runtime configuration reload (REHASH)"
git commit -m "feat(logger): implement multi-level logging to console and file"
git commit -m "feat(rate): implement rate limiting for flood protection"
git commit -m "feat(oper): implement OPER, KILL commands"
git commit -m "feat(admin): implement REHASH, RESTART, DIE commands"
git commit -m "feat(stats): implement STATS, INFO, VERSION, TIME, LUSERS"
git commit -m "feat(stats): add server statistics tracking"
# v3.0.0 tag
```

---

## 8. 프로덕션 체크리스트

### 8-1. 보안
- [ ] 서버 비밀번호 설정
- [ ] 오퍼레이터 비밀번호 설정
- [ ] Rate limiting 활성화
- [ ] 로깅 활성화

### 8-2. 모니터링
- [ ] 로그 파일 위치 확인
- [ ] 로그 로테이션 설정
- [ ] STATS 명령으로 상태 확인

### 8-3. 운영
- [ ] REHASH로 설정 리로드 테스트
- [ ] 백업 절차 확립
- [ ] 장애 대응 절차 문서화
